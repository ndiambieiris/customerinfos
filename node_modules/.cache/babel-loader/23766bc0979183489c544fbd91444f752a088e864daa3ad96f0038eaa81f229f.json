{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-grid-core\n * Generated: 2022-07-12\n * Version: 3.0.4\n * License: https://js.devexpress.com/Licensing\n */\n\nimport { slice, easeOutCubic } from '@devexpress/dx-core';\nvar GRID_GROUP_TYPE = Symbol('group');\nvar GRID_GROUP_CHECK = Symbol(GRID_GROUP_TYPE.toString() + \"_check\");\nvar GRID_GROUP_LEVEL_KEY = Symbol(GRID_GROUP_TYPE.toString() + \"_levelKey\");\nvar GRID_GROUP_COLLAPSED_ROWS = Symbol(GRID_GROUP_TYPE.toString() + \"_collapsedRows\");\nvar warnIfRowIdUndefined = function warnIfRowIdUndefined(getRowId) {\n  return function (row) {\n    var result = getRowId(row);\n    if (!row[GRID_GROUP_CHECK] && result === undefined) {\n      // tslint:disable-next-line: no-console\n      console.warn('The row id is undefined. Check the getRowId function. The row is', row);\n    }\n    return result;\n  };\n};\nvar rowIdGetter = function rowIdGetter(getRowId, rows) {\n  if (!getRowId) {\n    var map_1 = new Map(rows.map(function (row, rowIndex) {\n      return [row, rowIndex];\n    }));\n    return function (row) {\n      return map_1.get(row);\n    };\n  }\n  return warnIfRowIdUndefined(getRowId);\n};\nvar defaultGetCellValue = function defaultGetCellValue(row, columnName) {\n  return row[columnName];\n};\nvar cellValueGetter = function cellValueGetter(getCellValue, columns) {\n  if (getCellValue === void 0) {\n    getCellValue = defaultGetCellValue;\n  }\n  var useFastAccessor = true;\n  var map = columns.reduce(function (acc, column) {\n    if (column.getCellValue) {\n      useFastAccessor = false;\n      acc[column.name] = column.getCellValue;\n    }\n    return acc;\n  }, {});\n  if (useFastAccessor) {\n    return getCellValue;\n  }\n  return function (row, columnName) {\n    return map[columnName] ? map[columnName](row, columnName) : getCellValue(row, columnName);\n  };\n};\nvar changeColumnSorting = function changeColumnSorting(state, _a) {\n  var columnName = _a.columnName,\n    direction = _a.direction,\n    keepOther = _a.keepOther,\n    sortIndex = _a.sortIndex;\n  var sorting = state.sorting;\n  var nextSorting = [];\n  if (keepOther === true) {\n    nextSorting = sorting;\n  }\n  if (Array.isArray(keepOther)) {\n    nextSorting = slice(sorting).filter(function (s) {\n      return keepOther.indexOf(s.columnName) > -1;\n    });\n  }\n  var columnSortingIndex = sorting.findIndex(function (s) {\n    return s.columnName === columnName;\n  });\n  var columnSorting = sorting[columnSortingIndex];\n  var newColumnSorting = {\n    columnName: columnName,\n    direction: direction || (!columnSorting || columnSorting.direction === 'desc' ? 'asc' : 'desc')\n  };\n  if (columnSortingIndex > -1) {\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(columnSortingIndex, 1);\n  }\n  if (direction !== null) {\n    var newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;\n    var newIndex = sortIndex !== undefined ? sortIndex : newIndexFallback;\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(newIndex, 0, newColumnSorting);\n  }\n  return {\n    sorting: nextSorting\n  };\n};\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return _assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\nvar unique = function unique(arr) {\n  return __spread(Array.from(new Set(arr)));\n};\nvar getColumnSortingDirection = function getColumnSortingDirection(sorting, columnName) {\n  var columnSorting = sorting.filter(function (s) {\n    return s.columnName === columnName;\n  })[0];\n  return columnSorting ? columnSorting.direction : null;\n};\nvar getPersistentSortedColumns = function getPersistentSortedColumns(sorting, columnExtensions) {\n  if (columnExtensions === void 0) {\n    columnExtensions = [];\n  }\n  return columnExtensions.reduce(function (acc, _a) {\n    var columnName = _a.columnName,\n      sortingEnabled = _a.sortingEnabled;\n    if (!sortingEnabled) {\n      if (sorting.findIndex(function (sortItem) {\n        return sortItem.columnName === columnName;\n      }) > -1) {\n        acc.push(columnName);\n      }\n    }\n    return acc;\n  }, []);\n};\nvar calculateKeepOther = function calculateKeepOther(sorting, keepOther, persistentSortedColumns) {\n  if (persistentSortedColumns === void 0) {\n    persistentSortedColumns = [];\n  }\n  if (!persistentSortedColumns.length) return keepOther;\n  if (!keepOther) return persistentSortedColumns;\n  return Array.isArray(keepOther) ? unique(__spread(keepOther, persistentSortedColumns)) : unique(__spread(sorting.map(function (item) {\n    return item.columnName;\n  }), persistentSortedColumns));\n};\n\n/* eslint-disable no-plusplus, no-param-reassign, no-use-before-define, no-constant-condition */\n/* tslint:disable no-increment-decrement */\nvar merge = function merge(array, auxiliary, lo, mid, hi, compare) {\n  var i = lo;\n  var j = mid + 1;\n  var k = lo;\n  while (true) {\n    var cmp = compare(array[i], array[j]);\n    if (cmp <= 0) {\n      auxiliary[k++] = array[i++];\n      if (i > mid) {\n        do {\n          auxiliary[k++] = array[j++];\n        } while (j <= hi);\n        break;\n      }\n    } else {\n      auxiliary[k++] = array[j++];\n      if (j > hi) {\n        do {\n          auxiliary[k++] = array[i++];\n        } while (i <= mid);\n        break;\n      }\n    }\n  }\n};\nvar sortArrayToAuxiliary = function sortArrayToAuxiliary(array, auxiliary, lo, hi, compare) {\n  if (hi < lo) return;\n  if (hi === lo) {\n    auxiliary[lo] = array[lo];\n    return;\n  }\n  var mid = Math.floor(lo + (hi - lo) / 2);\n  sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);\n  sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);\n  merge(array, auxiliary, lo, mid, hi, compare);\n};\nvar sortAuxiliaryToArray = function sortAuxiliaryToArray(array, auxiliary, lo, hi, compare) {\n  if (hi <= lo) return;\n  var mid = Math.floor(lo + (hi - lo) / 2);\n  sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);\n  sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);\n  merge(auxiliary, array, lo, mid, hi, compare);\n};\nvar mergeSort = function mergeSort(array, compare) {\n  if (compare === void 0) {\n    compare = function compare(a, b) {\n      if (a < b) return -1;\n      if (a > b) return 1;\n      return 0;\n    };\n  }\n  var result = slice(array);\n  var auxiliary = slice(array);\n  sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);\n  return result;\n};\nvar NODE_CHECK = Symbol('node');\nvar rowsToTree = function rowsToTree(rows, getRowLevelKey) {\n  if (!rows.length) return rows;\n  var levels = [{\n    children: []\n  }];\n  rows.forEach(function (row) {\n    var _a;\n    var levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      var levelIndex = levels.slice(1).findIndex(function (level) {\n        return getRowLevelKey(level.root) === levelKey;\n      }) + 1;\n      if (levelIndex > 0) {\n        levels.splice(levelIndex, levels.length - levelIndex);\n      }\n      var node = (_a = {}, _a[NODE_CHECK] = true, _a.root = row, _a.children = [], _a);\n      levels[levels.length - 1].children.push(node);\n      levels.push(node);\n    } else {\n      levels[levels.length - 1].children.push(row);\n    }\n  });\n  return levels[0].children;\n};\nvar treeToRows = function treeToRows(tree, rows) {\n  if (rows === void 0) {\n    rows = [];\n  }\n  if (!tree.length) return tree;\n  return tree.reduce(function (acc, node) {\n    if (node[NODE_CHECK]) {\n      acc.push(node.root);\n      treeToRows(node.children, rows);\n    } else {\n      acc.push(node);\n    }\n    return acc;\n  }, rows);\n};\nvar defaultCompare = function defaultCompare(a, b) {\n  if (a === b) return 0;\n  if (a === null) {\n    return b === undefined ? -1 : 1;\n  }\n  if (a === undefined) {\n    return 1;\n  }\n  if (b === null || b === undefined) {\n    return -1;\n  }\n  return a < b ? -1 : 1;\n};\nvar createCompare = function createCompare(sorting, getColumnCompare, getComparableValue) {\n  return sorting.reduceRight(function (prevCompare, columnSorting) {\n    var columnName = columnSorting.columnName;\n    var inverse = columnSorting.direction === 'desc';\n    var columnCompare = getColumnCompare && getColumnCompare(columnName) || defaultCompare;\n    return function (aRow, bRow) {\n      var a = getComparableValue(aRow, columnName);\n      var b = getComparableValue(bRow, columnName);\n      var result = columnCompare(a, b);\n      if (result !== 0) {\n        return inverse ? -result : result;\n      }\n      return prevCompare(aRow, bRow);\n    };\n  }, function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return 0;\n  });\n};\nvar sortTree = function sortTree(tree, compare) {\n  var sortedTree = tree.map(function (node) {\n    if (node[NODE_CHECK]) {\n      return _assign(_assign({}, node), {\n        children: sortTree(node.children, compare)\n      });\n    }\n    return node;\n  });\n  return mergeSort(sortedTree, function (a, b) {\n    return compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b);\n  });\n};\nvar sortHierarchicalRows = function sortHierarchicalRows(rows, compare, getRowLevelKey) {\n  var tree = rowsToTree(rows, getRowLevelKey);\n  var sortedTree = sortTree(tree, compare);\n  return treeToRows(sortedTree);\n};\nvar sortedRows = function sortedRows(rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey) {\n  if (!sorting.length || !rows.length) return rows;\n  var compare;\n  if (!getRowLevelKey) {\n    compare = createCompare(sorting, getColumnCompare, getCellValue);\n    return mergeSort(rows.slice(), compare);\n  }\n  compare = createCompare(sorting, getColumnCompare, function (row, columnName) {\n    if (isGroupRow && isGroupRow(row)) {\n      if (row.groupedBy === columnName) {\n        return row.value;\n      }\n      return undefined;\n    }\n    return getCellValue(row, columnName);\n  });\n  return sortHierarchicalRows(rows, compare, getRowLevelKey);\n};\nvar changeColumnFilter = function changeColumnFilter(filters, _a) {\n  var columnName = _a.columnName,\n    config = _a.config;\n  var filterIndex = filters.findIndex(function (f) {\n    return f.columnName === columnName;\n  });\n  var nextState = slice(filters);\n  if (config) {\n    var filter = _assign({\n      columnName: columnName\n    }, config);\n    if (filterIndex > -1) {\n      nextState.splice(filterIndex, 1, filter);\n    } else {\n      nextState.push(filter);\n    }\n  } else if (filterIndex > -1) {\n    nextState.splice(filterIndex, 1);\n  }\n  return nextState;\n};\nvar getColumnFilterConfig = function getColumnFilterConfig(filters, columnName) {\n  return filters.length && filters.filter(function (s) {\n    return s.columnName === columnName;\n  })[0] || null;\n};\nvar filterExpression = function filterExpression(filters, expression) {\n  // tslint:disable-next-line: no-object-literal-type-assertion\n  var selfFilterExpr = {\n    filters: filters,\n    operator: 'and'\n  };\n  if (!expression) {\n    return selfFilterExpr;\n  }\n  return {\n    operator: 'and',\n    filters: [expression, selfFilterExpr]\n  };\n};\nvar operators = {\n  or: function or(predicates) {\n    return function (row) {\n      return predicates.reduce(function (acc, predicate) {\n        return acc || predicate(row);\n      }, false);\n    };\n  },\n  and: function and(predicates) {\n    return function (row) {\n      return predicates.reduce(function (acc, predicate) {\n        return acc && predicate(row);\n      }, true);\n    };\n  }\n};\nvar toLowerCase = function toLowerCase(value) {\n  return String(value).toLowerCase();\n};\nvar operationPredicates = {\n  contains: function contains(value, filter) {\n    return toLowerCase(value).indexOf(toLowerCase(filter.value)) > -1;\n  },\n  notContains: function notContains(value, filter) {\n    return toLowerCase(value).indexOf(toLowerCase(filter.value)) === -1;\n  },\n  startsWith: function startsWith(value, filter) {\n    return toLowerCase(value).startsWith(toLowerCase(filter.value));\n  },\n  endsWith: function endsWith(value, filter) {\n    return toLowerCase(value).endsWith(toLowerCase(filter.value));\n  },\n  equal: function equal(value, filter) {\n    return String(value) === String(filter.value);\n  },\n  notEqual: function notEqual(value, filter) {\n    return String(value) !== String(filter.value);\n  },\n  greaterThan: function greaterThan(value, filter) {\n    return value > filter.value;\n  },\n  greaterThanOrEqual: function greaterThanOrEqual(value, filter) {\n    return value >= filter.value;\n  },\n  lessThan: function lessThan(value, filter) {\n    return value < filter.value;\n  },\n  lessThanOrEqual: function lessThanOrEqual(value, filter) {\n    return value <= filter.value;\n  }\n};\nvar defaultFilterPredicate = function defaultFilterPredicate(value, filter) {\n  var operation = filter.operation || 'contains';\n  return operationPredicates[operation](value, filter);\n};\nvar filterTree = function filterTree(tree, predicate) {\n  return tree.reduce(function (acc, node) {\n    if (node[NODE_CHECK]) {\n      var filteredChildren = filterTree(node.children, predicate);\n      if (filteredChildren.length > 0) {\n        acc.push(_assign(_assign({}, node), {\n          children: filteredChildren\n        }));\n        return acc;\n      }\n      if (predicate(node.root, true)) {\n        acc.push(node.root);\n        return acc;\n      }\n      return acc;\n    }\n    if (predicate(node)) {\n      acc.push(node);\n      return acc;\n    }\n    return acc;\n  }, []);\n};\nvar filterHierarchicalRows = function filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows) {\n  var tree = rowsToTree(rows, getRowLevelKey);\n  var collapsedRowsMeta = [];\n  var filteredTree = filterTree(tree, function (row, isNode) {\n    if (isNode) {\n      var collapsedRows = getCollapsedRows && getCollapsedRows(row);\n      if (collapsedRows && collapsedRows.length) {\n        var filteredCollapsedRows = collapsedRows.filter(predicate);\n        collapsedRowsMeta.push([row, filteredCollapsedRows]);\n        return !!filteredCollapsedRows.length || predicate(row);\n      }\n      if (predicate(row)) {\n        collapsedRowsMeta.push([row, []]);\n        return true;\n      }\n      return false;\n    }\n    return predicate(row);\n  });\n  return {\n    rows: treeToRows(filteredTree),\n    collapsedRowsMeta: new Map(collapsedRowsMeta)\n  };\n};\nvar buildPredicate = function buildPredicate(initialFilterExpression, getCellValue, getColumnPredicate) {\n  var getSimplePredicate = function getSimplePredicate(filter) {\n    var columnName = filter.columnName;\n    var customPredicate = getColumnPredicate && getColumnPredicate(columnName);\n    var predicate = customPredicate || defaultFilterPredicate;\n    return function (row) {\n      return predicate(getCellValue(row, columnName), filter, row);\n    };\n  };\n  var getOperatorPredicate = function getOperatorPredicate(filterExpression) {\n    var build = operators[toLowerCase(filterExpression.operator)];\n    return build && build(filterExpression.filters.map(getPredicate));\n  };\n  var getPredicate = function getPredicate(filterExpression) {\n    return getOperatorPredicate(filterExpression) || getSimplePredicate(filterExpression);\n  };\n  return getPredicate(initialFilterExpression);\n};\nvar filteredRows = function filteredRows(rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows) {\n  if (!(filterExpression && Object.keys(filterExpression).length && rows.length)) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {\n      rows: rows\n    };\n  }\n  var predicate = buildPredicate(filterExpression, getCellValue, getColumnPredicate);\n  return getRowLevelKey ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows) : {\n    rows: rows.filter(predicate)\n  };\n};\nvar filteredCollapsedRowsGetter = function filteredCollapsedRowsGetter(_a) {\n  var collapsedRowsMeta = _a.collapsedRowsMeta;\n  return function (row) {\n    return collapsedRowsMeta && collapsedRowsMeta.get(row);\n  };\n};\nvar unwrappedFilteredRows = function unwrappedFilteredRows(_a) {\n  var rows = _a.rows;\n  return rows;\n};\nvar GROUP_KEY_SEPARATOR = '|';\nvar applyColumnGrouping = function applyColumnGrouping(grouping, _a) {\n  var columnName = _a.columnName,\n    groupIndex = _a.groupIndex;\n  var nextGrouping = grouping;\n  var groupingIndex = nextGrouping.findIndex(function (g) {\n    return g.columnName === columnName;\n  });\n  var targetIndex = groupIndex;\n  if (groupingIndex > -1) {\n    nextGrouping = slice(grouping);\n    nextGrouping.splice(groupingIndex, 1);\n  } else if (groupIndex === undefined) {\n    targetIndex = nextGrouping.length;\n  }\n  if (targetIndex > -1) {\n    nextGrouping = slice(nextGrouping);\n    nextGrouping.splice(targetIndex, 0, {\n      columnName: columnName\n    });\n  }\n  return nextGrouping;\n};\nvar changeColumnGrouping = function changeColumnGrouping(_a, _b) {\n  var grouping = _a.grouping,\n    expandedGroups = _a.expandedGroups;\n  var columnName = _b.columnName,\n    groupIndex = _b.groupIndex;\n  var nextGrouping = applyColumnGrouping(grouping, {\n    columnName: columnName,\n    groupIndex: groupIndex\n  });\n  var ungroupedColumnIndex = grouping.findIndex(function (group, index) {\n    return !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName;\n  });\n  if (ungroupedColumnIndex === -1) {\n    return {\n      grouping: nextGrouping\n    };\n  }\n  var filteredExpandedGroups = expandedGroups.filter(function (group) {\n    return group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex;\n  });\n  if (filteredExpandedGroups.length === expandedGroups.length) {\n    return {\n      grouping: nextGrouping\n    };\n  }\n  return {\n    grouping: nextGrouping,\n    expandedGroups: filteredExpandedGroups\n  };\n};\nvar toggleExpandedGroups = function toggleExpandedGroups(state, _a) {\n  var groupKey = _a.groupKey;\n  var expandedGroups = slice(state.expandedGroups);\n  var groupKeyIndex = expandedGroups.indexOf(groupKey);\n  if (groupKeyIndex > -1) {\n    expandedGroups.splice(groupKeyIndex, 1);\n  } else {\n    expandedGroups.push(groupKey);\n  }\n  return {\n    expandedGroups: expandedGroups\n  };\n};\nvar draftColumnGrouping = function draftColumnGrouping(_a, _b) {\n  var grouping = _a.grouping,\n    draftGrouping = _a.draftGrouping;\n  var columnName = _b.columnName,\n    groupIndex = _b.groupIndex;\n  return {\n    draftGrouping: applyColumnGrouping(draftGrouping || grouping, {\n      columnName: columnName,\n      groupIndex: groupIndex\n    })\n  };\n};\nvar cancelColumnGroupingDraft = function cancelColumnGroupingDraft() {\n  return {\n    draftGrouping: null\n  };\n};\nvar adjustSortIndex = function adjustSortIndex(groupingIndex, grouping, sorting) {\n  return Math.max(grouping.slice(0, groupingIndex).reduce(function (acc, columnGrouping) {\n    var columnSortingIndex = sorting.findIndex(function (columnSorting) {\n      return columnSorting.columnName === columnGrouping.columnName;\n    });\n    return columnSortingIndex === -1 ? acc - 1 : acc;\n  }, groupingIndex), 0);\n};\nvar defaultColumnCriteria = function defaultColumnCriteria(value) {\n  return {\n    value: value,\n    key: String(value)\n  };\n};\nvar getGroupRows = function getGroupRows(rows, grouping, groupsGetter) {\n  if (grouping.length === 0) {\n    return rows;\n  }\n  var keyPrefixes = [{\n    prefix: '',\n    level: 0,\n    rows: rows\n  }];\n  var resultRows = [];\n  var compoundKeys = {};\n  var _loop_1 = function _loop_1() {\n    var _a = keyPrefixes.pop(),\n      keyPrefix = _a.prefix,\n      level = _a.level,\n      currentRows = _a.rows;\n    var currentCompoundKey = keyPrefix.slice(0, keyPrefix.length - 1);\n    var groupIndex = (_a = compoundKeys[currentCompoundKey]) !== null && _a !== void 0 ? _a : -1;\n    var groupRows = grouping[level] && currentRows.length ? groupsGetter(currentRows, grouping[level], keyPrefix).map(function (_a, rowIndex) {\n      var childRows = _a.childRows,\n        params = __rest(_a, [\"childRows\"]);\n      var compoundKey = params.compoundKey;\n      compoundKeys[compoundKey] = groupIndex + rowIndex + 1;\n      keyPrefixes.push({\n        prefix: \"\" + compoundKey + GROUP_KEY_SEPARATOR,\n        level: level + 1,\n        rows: childRows || []\n      });\n      return params;\n    }) : currentRows;\n    if (groupIndex > -1) {\n      resultRows.splice.apply(resultRows, __spread([groupIndex + 1, 0], groupRows));\n    } else {\n      groupRows.forEach(function (row) {\n        return resultRows.push(row);\n      });\n    }\n  };\n  while (keyPrefixes.length) {\n    _loop_1();\n  }\n  return resultRows;\n};\nvar getIntegratedGroups = function getIntegratedGroups(rows, grouping, keyPrefix, getCellValue, getColumnCriteria) {\n  var columnName = grouping.columnName;\n  var groupCriteria = getColumnCriteria && getColumnCriteria(columnName) || defaultColumnCriteria;\n  var groups = new Map();\n  rows.forEach(function (row) {\n    var rawValue = getCellValue(row, columnName);\n    var _a = groupCriteria(rawValue, row),\n      key = _a.key,\n      value = _a.value;\n    var sameKeyItems = groups.get(key);\n    if (!sameKeyItems) {\n      var groupingValue = value === rawValue ? value : value || key;\n      groups.set(key, [groupingValue, key, [row]]);\n    } else {\n      sameKeyItems[2].push(row);\n    }\n  });\n  var groupedBy = columnName;\n  return __spread(groups.values()).map(function (_a) {\n    var _b;\n    var _c = __read(_a, 3),\n      value = _c[0],\n      key = _c[1],\n      childRows = _c[2];\n    return _b = {\n      groupedBy: groupedBy,\n      compoundKey: \"\" + keyPrefix + key,\n      key: key,\n      value: value\n    }, _b[GRID_GROUP_CHECK] = true, _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + \"_\" + groupedBy, _b.childRows = childRows, _b;\n  });\n};\nvar groupRowChecker = function groupRowChecker(row) {\n  return row[GRID_GROUP_CHECK];\n};\nvar groupRowLevelKeyGetter = function groupRowLevelKeyGetter(row) {\n  return row ? row[GRID_GROUP_LEVEL_KEY] : undefined;\n};\nvar groupedRows = function groupedRows(rows, grouping, getCellValue, getColumnCriteria) {\n  var groupsGetter = function groupsGetter(currentRows, currentGrouping, prefix) {\n    return getIntegratedGroups(currentRows, currentGrouping, prefix, getCellValue, getColumnCriteria);\n  };\n  return getGroupRows(rows, grouping, groupsGetter);\n};\nvar expandedGroupRows = function expandedGroupRows(rows, grouping, expandedGroups, isExporting) {\n  if (!grouping.length) return rows;\n  var groupingColumnNames = grouping.map(function (columnGrouping) {\n    return columnGrouping.columnName;\n  });\n  var expandedGroupsSet = new Set(expandedGroups);\n  var currentGroupExpanded = true;\n  var currentGroupLevel = 0;\n  return rows.reduce(function (acc, row) {\n    var _a;\n    if (!row[GRID_GROUP_CHECK]) {\n      if (currentGroupExpanded) {\n        acc.push(row);\n      } else {\n        acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);\n      }\n      return acc;\n    }\n    var groupLevel = groupingColumnNames.indexOf(row.groupedBy);\n    if (groupLevel > currentGroupLevel && !currentGroupExpanded) {\n      return acc;\n    }\n    currentGroupExpanded = expandedGroupsSet.has(row.compoundKey) || isExporting;\n    currentGroupLevel = groupLevel;\n    if (currentGroupExpanded) {\n      acc.push(row);\n    } else {\n      acc.push(_assign(_assign({}, row), (_a = {}, _a[GRID_GROUP_COLLAPSED_ROWS] = [], _a)));\n    }\n    return acc;\n  }, []);\n};\nvar groupCollapsedRowsGetter = function groupCollapsedRowsGetter(getCollapsedRows) {\n  return function (row) {\n    return row[GRID_GROUP_COLLAPSED_ROWS] || getCollapsedRows && getCollapsedRows(row);\n  };\n};\nvar getCustomGroups = function getCustomGroups(rows, grouping, keyPrefix, getChildGroups, rootRows) {\n  var groupedBy = grouping.columnName;\n  return getChildGroups(rows, grouping, rootRows).map(function (_a) {\n    var _b;\n    var key = _a.key,\n      _c = _a.value,\n      value = _c === void 0 ? key : _c,\n      childRows = _a.childRows;\n    return _b = {\n      groupedBy: groupedBy,\n      compoundKey: \"\" + keyPrefix + key,\n      key: key,\n      value: value\n    }, _b[GRID_GROUP_CHECK] = true, _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + \"_\" + groupedBy, _b.childRows = childRows, _b;\n  });\n};\nvar customGroupedRows = function customGroupedRows(rows, grouping, getChildGroups, rootRows) {\n  if (rootRows === void 0) {\n    rootRows = rows;\n  }\n  var groupsGetter = function groupsGetter(currentRows, currentGrouping, prefix) {\n    return getCustomGroups(currentRows, currentGrouping, prefix, getChildGroups, rootRows);\n  };\n  return getGroupRows(rows, grouping, groupsGetter);\n};\nvar customGroupingRowIdGetter = function customGroupingRowIdGetter(getRowId, rows) {\n  var firstRow = rows.find(function (row) {\n    return !row[GRID_GROUP_CHECK];\n  });\n  if (!firstRow || getRowId(firstRow) !== undefined) {\n    return getRowId;\n  }\n  var map = new Map(rows.filter(function (row) {\n    return !row[GRID_GROUP_CHECK];\n  }).map(function (row, rowIndex) {\n    return [row, rowIndex];\n  }));\n  return function (row) {\n    return map.get(row);\n  };\n};\nvar groupingPanelItems = function groupingPanelItems(columns, grouping, draftGrouping) {\n  var items = draftGrouping.map(function (_a) {\n    var columnName = _a.columnName;\n    return {\n      column: columns.find(function (c) {\n        return c.name === columnName;\n      }),\n      draft: !grouping.some(function (columnGrouping) {\n        return columnGrouping.columnName === columnName;\n      })\n    };\n  });\n  grouping.forEach(function (_a, index) {\n    var columnName = _a.columnName;\n    if (draftGrouping.some(function (columnGrouping) {\n      return columnGrouping.columnName === columnName;\n    })) return;\n    items.splice(index, 0, {\n      column: columns.find(function (c) {\n        return c.name === columnName;\n      }),\n      draft: true\n    });\n  });\n  return items;\n};\nvar setCurrentPage = function setCurrentPage(prevPage, page) {\n  return page;\n};\nvar setPageSize = function setPageSize(prevPageSize, size) {\n  return size;\n};\nvar clamp = function clamp(value, max) {\n  return Math.max(Math.min(value, max), 0);\n};\n\n// tslint:disable-next-line:max-line-length\nvar PAGE_HEADERS_OVERFLOW_ERROR = 'Max row level exceeds the page size. Consider increasing the page size.';\nvar paginatedRows = function paginatedRows(rows, pageSize, page) {\n  return pageSize ? rows.slice(pageSize * page, pageSize * (page + 1)) : rows;\n};\nvar rowsWithPageHeaders = function rowsWithPageHeaders(rows, pageSize, getRowLevelKey) {\n  if (!pageSize || !getRowLevelKey) return rows;\n  var result = rows.slice();\n  var headerRows = [];\n  var currentIndex = 0;\n  var _loop_1 = function _loop_1() {\n    var row = result[currentIndex];\n    var levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      var headerIndex = headerRows.findIndex(function (headerRow) {\n        return getRowLevelKey(headerRow) === levelKey;\n      });\n      // tslint:disable-next-line:prefer-conditional-expression\n      if (headerIndex === -1) {\n        headerRows = __spread(headerRows, [row]);\n      } else {\n        headerRows = __spread(headerRows.slice(0, headerIndex), [row]);\n      }\n      if (headerRows.length >= pageSize) {\n        throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);\n      }\n    }\n    var indexInPage = currentIndex % pageSize;\n    if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {\n      result = __spread(result.slice(0, currentIndex), [headerRows[indexInPage]], result.slice(currentIndex));\n    }\n    currentIndex += 1;\n  };\n  while (result.length > currentIndex) {\n    _loop_1();\n  }\n  return result;\n};\nvar rowCount = function rowCount(rows) {\n  return rows.length;\n};\nvar pageCount = function pageCount(count, pageSize) {\n  return pageSize ? Math.ceil(count / pageSize) : 1;\n};\nvar currentPage = function currentPage(page, totalCount, pageSize, setCurrentPage) {\n  var totalPages = pageCount(totalCount, pageSize);\n  var adjustedCurrentPage = clamp(page, totalPages - 1);\n  if (page !== adjustedCurrentPage) {\n    setTimeout(function () {\n      return setCurrentPage(adjustedCurrentPage);\n    });\n  }\n  return adjustedCurrentPage;\n};\nvar firstRowOnPage = function firstRowOnPage(currentPage, pageSize, totalCount) {\n  if (totalCount === 0) {\n    return 0;\n  }\n  return pageSize ? currentPage * pageSize + 1 : 1;\n};\nvar lastRowOnPage = function lastRowOnPage(currentPage, pageSize, totalRowCount) {\n  var result = totalRowCount;\n  if (pageSize) {\n    var index = (currentPage + 1) * pageSize;\n    result = index > totalRowCount ? totalRowCount : index;\n  }\n  return result;\n};\nvar calculateStartPage = function calculateStartPage(currentPage, maxButtonCount, totalPageCount) {\n  return Math.max(Math.min(currentPage - Math.floor(maxButtonCount / 2), totalPageCount - maxButtonCount + 1), 1);\n};\nvar toggle = function toggle(source, items, state) {\n  var itemsSet = new Set(items);\n  var sourceState = state;\n  if (sourceState === undefined) {\n    var availableSelection = source.filter(function (item) {\n      return itemsSet.has(item);\n    });\n    sourceState = availableSelection.length !== itemsSet.size;\n  }\n  if (sourceState) {\n    var sourceSet_1 = new Set(source);\n    return __spread(source, items.filter(function (item) {\n      return !sourceSet_1.has(item);\n    }));\n  }\n  return source.filter(function (item) {\n    return !itemsSet.has(item);\n  });\n};\nvar toggleSelection = function toggleSelection(selection, _a) {\n  var rowIds = _a.rowIds,\n    state = _a.state;\n  return toggle(selection, rowIds, state);\n};\nvar rowsWithAvailableToSelect = function rowsWithAvailableToSelect(rows, getRowId, isGroupRow) {\n  var dataRows = rows;\n  if (isGroupRow) {\n    dataRows = dataRows.filter(function (row) {\n      return !isGroupRow(row);\n    });\n  }\n  return {\n    rows: rows,\n    availableToSelect: dataRows.map(function (row) {\n      return getRowId(row);\n    })\n  };\n};\nvar someSelected = function someSelected(_a, selection) {\n  var availableToSelect = _a.availableToSelect;\n  var selectionSet = new Set(selection);\n  return availableToSelect.length !== 0 && selectionSet.size !== 0 && availableToSelect.some(function (elem) {\n    return selectionSet.has(elem);\n  }) && availableToSelect.some(function (elem) {\n    return !selectionSet.has(elem);\n  });\n};\nvar allSelected = function allSelected(_a, selection) {\n  var availableToSelect = _a.availableToSelect;\n  var selectionSet = new Set(selection);\n  return selectionSet.size !== 0 && availableToSelect.length !== 0 && !availableToSelect.some(function (elem) {\n    return !selectionSet.has(elem);\n  });\n};\nvar unwrapSelectedRows = function unwrapSelectedRows(_a) {\n  var rows = _a.rows;\n  return rows;\n};\nvar startEditRows = function startEditRows(prevEditingRowIds, _a) {\n  var rowIds = _a.rowIds;\n  return __spread(prevEditingRowIds, rowIds);\n};\nvar stopEditRows = function stopEditRows(prevEditingRowIds, _a) {\n  var rowIds = _a.rowIds;\n  var rowIdSet = new Set(rowIds);\n  return prevEditingRowIds.filter(function (id) {\n    return !rowIdSet.has(id);\n  });\n};\nvar startEditCells = function startEditCells(prevEditingCells, _a) {\n  var editingCells = _a.editingCells;\n  return __spread(prevEditingCells, editingCells);\n};\nvar stopEditCells = function stopEditCells(prevEditingCells, _a) {\n  var editingCells = _a.editingCells;\n  return prevEditingCells.filter(function (_a) {\n    var rowId = _a.rowId,\n      columnName = _a.columnName;\n    return !editingCells.some(function (_a) {\n      var currentRowId = _a.rowId,\n        currentColumnName = _a.columnName;\n      return currentRowId === rowId && currentColumnName === columnName;\n    });\n  });\n};\nvar addRow = function addRow(addedRows, _a) {\n  var _b = _a === void 0 ? {\n      row: {}\n    } : _a,\n    row = _b.row;\n  return __spread(addedRows, [row]);\n};\nvar changeAddedRow = function changeAddedRow(addedRows, _a) {\n  var rowId = _a.rowId,\n    change = _a.change;\n  var result = addedRows.slice();\n  result[rowId] = _assign(_assign({}, result[rowId]), change);\n  return result;\n};\nvar cancelAddedRows = function cancelAddedRows(addedRows, _a) {\n  var rowIds = _a.rowIds;\n  var result = [];\n  var indexSet = new Set(rowIds);\n  addedRows.forEach(function (row, index) {\n    if (!indexSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\nvar changeRow = function changeRow(prevRowChanges, _a) {\n  var _b;\n  var rowId = _a.rowId,\n    change = _a.change;\n  var prevChange = prevRowChanges[rowId] || {};\n  return _assign(_assign({}, prevRowChanges), (_b = {}, _b[rowId] = _assign(_assign({}, prevChange), change), _b));\n};\nvar cancelChanges = function cancelChanges(prevRowChanges, _a) {\n  var rowIds = _a.rowIds;\n  var result = _assign({}, prevRowChanges);\n  rowIds.forEach(function (rowId) {\n    delete result[rowId];\n  });\n  return result;\n};\nvar deleteRows = function deleteRows(deletedRowIds, _a) {\n  var rowIds = _a.rowIds;\n  return __spread(deletedRowIds, rowIds);\n};\nvar cancelDeletedRows = function cancelDeletedRows(deletedRowIds, _a) {\n  var rowIds = _a.rowIds;\n  var rowIdSet = new Set(rowIds);\n  return deletedRowIds.filter(function (rowId) {\n    return !rowIdSet.has(rowId);\n  });\n};\nvar changedRowsByIds = function changedRowsByIds(changes, rowIds) {\n  var result = {};\n  rowIds.forEach(function (rowId) {\n    result[rowId] = changes[rowId];\n  });\n  return result;\n};\nvar addedRowsByIds = function addedRowsByIds(addedRows, rowIds) {\n  var rowIdSet = new Set(rowIds);\n  var result = [];\n  addedRows.forEach(function (row, index) {\n    if (rowIdSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\nvar defaultCreateRowChange = function defaultCreateRowChange(row, value, columnName) {\n  var _a;\n  return _a = {}, _a[columnName] = value, _a;\n};\nvar createRowChangeGetter = function createRowChangeGetter(createRowChange, columnExtensions) {\n  if (createRowChange === void 0) {\n    createRowChange = defaultCreateRowChange;\n  }\n  if (columnExtensions === void 0) {\n    columnExtensions = [];\n  }\n  var map = columnExtensions.reduce(function (acc, columnExtension) {\n    if (columnExtension.createRowChange) {\n      acc[columnExtension.columnName] = columnExtension.createRowChange;\n    }\n    return acc;\n  }, {});\n  return function (row, value, columnName) {\n    if (map[columnName]) {\n      return map[columnName](row, value, columnName);\n    }\n    return createRowChange(row, value, columnName);\n  };\n};\nvar getRowChange = function getRowChange(rowChanges, rowId) {\n  return rowChanges[rowId] || {};\n};\nvar TABLE_REORDERING_TYPE = Symbol('reordering');\nvar changeColumnOrder = function changeColumnOrder(order, _a) {\n  var sourceColumnName = _a.sourceColumnName,\n    targetColumnName = _a.targetColumnName;\n  var sourceColumnIndex = order.indexOf(sourceColumnName);\n  var targetColumnIndex = order.indexOf(targetColumnName);\n  var newOrder = slice(order);\n  newOrder.splice(sourceColumnIndex, 1);\n  newOrder.splice(targetColumnIndex, 0, sourceColumnName);\n  return newOrder;\n};\nvar TABLE_DATA_TYPE = Symbol('data');\nvar TABLE_NODATA_TYPE = Symbol('nodata');\nvar TABLE_FLEX_TYPE = Symbol('flex');\nvar orderedColumns = function orderedColumns(tableColumns, order) {\n  if (tableColumns === void 0) {\n    tableColumns = [];\n  }\n  return mergeSort(tableColumns, function (a, b) {\n    if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE) return 0;\n    var aPos = order.indexOf(a.column.name);\n    var bPos = order.indexOf(b.column.name);\n    return aPos - bPos;\n  });\n};\nvar tableHeaderRowsWithReordering = function tableHeaderRowsWithReordering(tableHeaderRows) {\n  return __spread(tableHeaderRows, [{\n    key: TABLE_REORDERING_TYPE.toString(),\n    type: TABLE_REORDERING_TYPE,\n    height: 0\n  }]);\n};\nvar draftOrder = function draftOrder(order, sourceColumnIndex, targetColumnIndex) {\n  if (sourceColumnIndex === -1 || targetColumnIndex === -1 || sourceColumnIndex === targetColumnIndex) {\n    return order;\n  }\n  var result = slice(order);\n  var sourceColumn = order[sourceColumnIndex];\n  result.splice(sourceColumnIndex, 1);\n  result.splice(targetColumnIndex, 0, sourceColumn);\n  return result;\n};\nvar getColumnWidth = function getColumnWidth(columnWidths, name, _a) {\n  var columnName = _a.columnName,\n    cachedWidths = _a.cachedWidths,\n    shift = _a.shift,\n    minColumnWidth = _a.minColumnWidth,\n    maxColumnWidth = _a.maxColumnWidth,\n    _b = _a.columnExtensions,\n    columnExtensions = _b === void 0 ? [] : _b;\n  var change = name === columnName ? shift : -shift;\n  var column = columnWidths.find(function (elem) {\n    return elem.columnName === name;\n  });\n  var extension = columnExtensions.find(function (elem) {\n    return elem.columnName === name;\n  });\n  var width = typeof column.width === 'number' ? column.width : cachedWidths[name];\n  var minWidth = extension && extension.minWidth >= 0 ? extension.minWidth : minColumnWidth;\n  var maxWidth = extension && extension.maxWidth >= 0 ? extension.maxWidth : maxColumnWidth;\n  var size = Math.max(minWidth, Math.min(width + change, maxWidth));\n  return {\n    width: width,\n    size: size\n  };\n};\nvar getColumnSizes = function getColumnSizes(columnWidths, payload) {\n  var columnName = payload.columnName,\n    nextColumnName = payload.nextColumnName,\n    resizingMode = payload.resizingMode,\n    shift = payload.shift;\n  var _a = getColumnWidth(columnWidths, columnName, payload),\n    width = _a.width,\n    size = _a.size;\n  if (resizingMode === 'nextColumn') {\n    var _b = getColumnWidth(columnWidths, nextColumnName, payload),\n      nextWidth = _b.width,\n      nextSize = _b.size;\n    if (size + nextSize !== width + nextWidth) {\n      var moreThanLimit = size + nextSize > width + nextWidth;\n      var columnExpand = shift > 0;\n      if (moreThanLimit !== columnExpand) {\n        return {\n          size: size,\n          nextSize: width + nextWidth - size\n        };\n      }\n      return {\n        size: width + nextWidth - nextSize,\n        nextSize: nextSize\n      };\n    }\n    return {\n      size: size,\n      nextSize: nextSize\n    };\n  }\n  return {\n    size: size\n  };\n};\nvar isValidValue = function isValidValue(value, validUnits) {\n  var numb = parseInt(value, 10);\n  var unit = numb ? value.substr(numb.toString().length) : value;\n  var sizeIsAuto = isNaN(numb) && unit === 'auto';\n  var sizeIsValid = numb >= 0 && validUnits.some(function (validUnit) {\n    return validUnit === unit;\n  });\n  return sizeIsAuto || sizeIsValid;\n};\nvar convertWidth = function convertWidth(value) {\n  if (typeof value === 'string') {\n    var numb = parseInt(value, 10);\n    if (value.substr(numb.toString().length).length > 0) {\n      return value;\n    }\n    return numb;\n  }\n  return value;\n};\nvar VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nvar NOT_FOR_WIDGET_UNITS = ['%'];\n/* tslint:disable max-line-length */\nvar COLUMN_RESIZING_ERROR = 'The columnWidths property of the TableColumnResizing plugin is given an invalid value.';\nvar specifyWidths = function specifyWidths(tableColumns, widths, resizingMode, onError) {\n  if (resizingMode !== 'widget' && resizingMode !== 'nextColumn') {\n    onError();\n  }\n  if (!widths.length) return tableColumns;\n  return tableColumns.reduce(function (acc, tableColumn) {\n    if (tableColumn.type === TABLE_DATA_TYPE) {\n      var columnName_1 = tableColumn.column.name;\n      var column = widths.find(function (el) {\n        return el.columnName === columnName_1;\n      });\n      var width = column && column.width;\n      if (typeof width !== 'number') {\n        if (width === undefined) {\n          onError();\n        } else if (!isValidValue(width, VALID_UNITS)) {\n          onError();\n        } else if (resizingMode === 'widget' && isValidValue(width, NOT_FOR_WIDGET_UNITS)) {\n          onError();\n        }\n      } else if (width < 0) {\n        onError();\n      }\n      if (width === undefined) {\n        acc.push(tableColumn);\n      } else {\n        acc.push(_assign(_assign({}, tableColumn), {\n          width: convertWidth(width)\n        }));\n      }\n    } else {\n      acc.push(tableColumn);\n    }\n    return acc;\n  }, []);\n};\nvar tableColumnsWithWidths = function tableColumnsWithWidths(tableColumns, columnWidths, resizingMode) {\n  return specifyWidths(tableColumns, columnWidths, resizingMode, throwError);\n};\nvar tableColumnsWithDraftWidths = function tableColumnsWithDraftWidths(tableColumns, draftColumnWidths, resizingMode) {\n  return specifyWidths(tableColumns, draftColumnWidths, resizingMode, function () {});\n};\nvar throwError = function throwError() {\n  throw new Error(COLUMN_RESIZING_ERROR);\n};\nvar changeTableColumnWidth = function changeTableColumnWidth(state, payload) {\n  var columnWidths = state.columnWidths;\n  var columnName = payload.columnName,\n    nextColumnName = payload.nextColumnName,\n    resizingMode = payload.resizingMode;\n  var nextColumnWidth = slice(columnWidths);\n  var index = nextColumnWidth.findIndex(function (elem) {\n    return elem.columnName === columnName;\n  });\n  var nextIndex = nextColumnWidth.findIndex(function (elem) {\n    return elem.columnName === nextColumnName;\n  });\n  var _a = getColumnSizes(columnWidths, payload),\n    size = _a.size,\n    nextSize = _a.nextSize;\n  nextColumnWidth.splice(index, 1, {\n    columnName: columnName,\n    width: size\n  });\n  if (resizingMode === 'nextColumn') {\n    nextColumnWidth.splice(nextIndex, 1, {\n      columnName: nextColumnName,\n      width: nextSize\n    });\n  }\n  return {\n    columnWidths: nextColumnWidth\n  };\n};\nvar draftTableColumnWidth = function draftTableColumnWidth(state, payload) {\n  var columnWidths = state.columnWidths;\n  var columnName = payload.columnName,\n    nextColumnName = payload.nextColumnName,\n    resizingMode = payload.resizingMode;\n  var _a = getColumnSizes(columnWidths, payload),\n    size = _a.size,\n    nextSize = _a.nextSize;\n  if (resizingMode === 'nextColumn') {\n    return {\n      draftColumnWidths: [{\n        columnName: columnName,\n        width: size\n      }, {\n        columnName: nextColumnName,\n        width: nextSize\n      }]\n    };\n  }\n  return {\n    draftColumnWidths: [{\n      columnName: columnName,\n      width: size\n    }]\n  };\n};\nvar cancelTableColumnWidthDraft = function cancelTableColumnWidthDraft() {\n  return {\n    draftColumnWidths: []\n  };\n};\nvar TABLE_EDIT_COMMAND_TYPE = Symbol('editCommand');\nvar TABLE_ADDED_TYPE = Symbol('added');\nvar TABLE_EDIT_TYPE = Symbol('edit');\nvar TABLE_HEADING_TYPE = Symbol('heading');\nvar isHeadingEditCommandsTableCell = function isHeadingEditCommandsTableCell(tableRow, tableColumn) {\n  return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\n};\nvar isEditCommandsTableCell = function isEditCommandsTableCell(tableRow, tableColumn) {\n  return (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\n};\nvar tableColumnsWithEditing = function tableColumnsWithEditing(tableColumns, width) {\n  return __spread([{\n    width: convertWidth(width),\n    key: TABLE_EDIT_COMMAND_TYPE.toString(),\n    type: TABLE_EDIT_COMMAND_TYPE\n  }], tableColumns);\n};\nvar isEditTableCell = function isEditTableCell(tableRow, tableColumn) {\n  return (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isAddedTableRow = function isAddedTableRow(tableRow) {\n  return tableRow.type === TABLE_ADDED_TYPE;\n};\nvar isEditTableRow = function isEditTableRow(tableRow) {\n  return tableRow.type === TABLE_EDIT_TYPE;\n};\nvar tableRowsWithEditing = function tableRowsWithEditing(tableRows, editingRowIds, addedRows, rowHeight) {\n  var rowIds = new Set(editingRowIds);\n  var editedTableRows = tableRows.map(function (tableRow) {\n    return tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId) ? _assign(_assign({}, tableRow), {\n      type: TABLE_EDIT_TYPE,\n      height: rowHeight\n    }) : tableRow;\n  });\n  var addedTableRows = addedRows.map(function (row, rowIndex) {\n    return {\n      row: row,\n      key: TABLE_ADDED_TYPE.toString() + \"_\" + rowIndex,\n      type: TABLE_ADDED_TYPE,\n      rowId: rowIndex,\n      height: rowHeight\n    };\n  });\n  return __spread(slice(addedTableRows).reverse(), editedTableRows);\n};\nvar rowsWithEditingCells = function rowsWithEditingCells(tableBodyRows, editingCells) {\n  return tableBodyRows.map(function (row) {\n    var rowId = row.rowId,\n      type = row.type;\n    if (rowId !== undefined && type === TABLE_DATA_TYPE && editingCells.some(function (elem) {\n      return elem.rowId === rowId;\n    })) {\n      return _assign(_assign({}, row), {\n        hasEditCell: true\n      });\n    }\n    return row;\n  });\n};\nvar columnsWithEditingCells = function columnsWithEditingCells(tableColumns, editingCells) {\n  return tableColumns.map(function (tableColumn) {\n    var columnName = tableColumn.column ? tableColumn.column.name : undefined;\n    if (columnName !== undefined && editingCells.some(function (elem) {\n      return elem.columnName === columnName;\n    })) {\n      return _assign(_assign({}, tableColumn), {\n        hasEditCell: true\n      });\n    }\n    return tableColumn;\n  });\n};\nvar TABLE_FILTER_TYPE = Symbol('filter');\nvar DEFAULT_FILTER_OPERATIONS = ['contains', 'notContains', 'startsWith', 'endsWith', 'equal', 'notEqual'];\nvar isFilterTableCell = function isFilterTableCell(tableRow, tableColumn) {\n  return tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isFilterTableRow = function isFilterTableRow(tableRow) {\n  return tableRow.type === TABLE_FILTER_TYPE;\n};\nvar getColumnFilterOperations = function getColumnFilterOperations(getAvailableFilterOperations, columnName) {\n  return getAvailableFilterOperations && getAvailableFilterOperations(columnName) || DEFAULT_FILTER_OPERATIONS;\n};\nvar isFilterValueEmpty = function isFilterValueEmpty(value) {\n  return value === undefined || !String(value).length;\n};\nvar getSelectedFilterOperation = function getSelectedFilterOperation(filterOperations, columnName, columnFilter, columnFilterOperations) {\n  if (columnFilter && columnFilter.operation) {\n    return columnFilter.operation;\n  }\n  if (filterOperations[columnName]) {\n    return filterOperations[columnName];\n  }\n  return columnFilterOperations[0];\n};\nvar tableHeaderRowsWithFilter = function tableHeaderRowsWithFilter(headerRows, rowHeight) {\n  return __spread(headerRows, [{\n    key: TABLE_FILTER_TYPE.toString(),\n    type: TABLE_FILTER_TYPE,\n    height: rowHeight\n  }]);\n};\nvar TABLE_GROUP_TYPE = Symbol('group');\nvar TABLE_STUB_TYPE = Symbol('stub');\nvar getVisibleBoundaryWithFixed = function getVisibleBoundaryWithFixed(visibleBoundary, items) {\n  return items.reduce(function (acc, item, index) {\n    if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {\n      acc.push([index, index]);\n    }\n    return acc;\n  }, [visibleBoundary]);\n};\nvar getVisibleBoundary = function getVisibleBoundary(items, viewportStart, viewportSize, getItemSize, skipItems, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var start;\n  var end;\n  var index = items[0] && items[0].rowId >= skipItems[0] ? 0 : skipItems[0];\n  var itemSize = getItemSize();\n  var beforePosition = offset !== 0 ? (offset - skipItems[0]) * itemSize : 0;\n  var viewportEnd = viewportStart + viewportSize;\n  while (end === undefined && index < items.length) {\n    var item = items[index];\n    var afterPosition = beforePosition + getItemSize(item);\n    var isVisible = beforePosition >= viewportStart && beforePosition < viewportEnd || afterPosition > viewportStart && afterPosition <= viewportEnd || beforePosition < viewportStart && afterPosition > viewportEnd;\n    if (isVisible && start === undefined) {\n      start = index;\n    }\n    if (!isVisible && start !== undefined) {\n      end = index - 1;\n      break;\n    }\n    index += 1;\n    beforePosition = afterPosition;\n  }\n  if (start !== undefined && end === undefined) {\n    end = index - 1;\n  }\n  end = end === undefined ? 0 : end;\n  start = start === undefined ? 0 : start;\n  return [start + offset, end + offset];\n};\nvar getRenderBoundary = function getRenderBoundary(itemsCount, visibleBoundary, overscan) {\n  var _a = __read(visibleBoundary, 2),\n    start = _a[0],\n    end = _a[1];\n  start = Math.max(0, start - overscan);\n  end = Math.min(itemsCount - 1, end + overscan);\n  return [start, end];\n};\nvar getColumnBoundaries = function getColumnBoundaries(columns, left, width, getColumnWidth) {\n  return getVisibleBoundaryWithFixed(getColumnsRenderBoundary(columns.length, getVisibleBoundary(columns, left, width, getColumnWidth, [0, 0], 0)), columns);\n};\nvar getRowsVisibleBoundary = function getRowsVisibleBoundary(rows, top, height, getRowHeight, skipItems, offset, isDataRemote) {\n  var rowHeight = getRowHeight();\n  var beforePosition = offset !== 0 ? (offset - skipItems[0]) * rowHeight : 0;\n  var noVisibleRowsLoaded = rowHeight > 0 && beforePosition + rows.length * rowHeight < top || top < beforePosition;\n  var boundaries;\n  if (isDataRemote && noVisibleRowsLoaded) {\n    var topIndex = Math.round(top / rowHeight) + skipItems[0];\n    boundaries = [topIndex, topIndex];\n  } else {\n    boundaries = getVisibleBoundary(rows, top, height, getRowHeight, skipItems, offset);\n  }\n  return boundaries;\n};\nvar getColumnsRenderBoundary = function getColumnsRenderBoundary(columnCount, visibleBoundary) {\n  return getRenderBoundary(columnCount, visibleBoundary, 1);\n};\nvar getRowsRenderBoundary = function getRowsRenderBoundary(rowsCount, visibleBoundary) {\n  return getRenderBoundary(rowsCount, visibleBoundary, 3);\n};\nvar getSpanBoundary = function getSpanBoundary(items, visibleBoundaries, getItemSpan) {\n  return visibleBoundaries.map(function (visibleBoundary) {\n    var endIndex = Math.min(visibleBoundary[1], items.length - 1);\n    var end = endIndex;\n    var start = visibleBoundary[0] <= end ? visibleBoundary[0] : 0;\n    for (var index = 0; index <= endIndex; index += 1) {\n      var span = getItemSpan(items[index]);\n      if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {\n        start = index;\n      }\n      if (index + (span - 1) > visibleBoundary[1]) {\n        end = index + (span - 1);\n      }\n    }\n    return [start, end];\n  });\n};\nvar collapseBoundaries = function collapseBoundaries(itemsCount, visibleBoundaries, spanBoundaries) {\n  var breakpoints = new Set([0, itemsCount]);\n  spanBoundaries.forEach(function (rowBoundaries) {\n    return rowBoundaries.forEach(function (boundary) {\n      breakpoints.add(boundary[0]);\n      // next interval starts after span end point\n      breakpoints.add(Math.min(boundary[1] + 1, itemsCount));\n    });\n  });\n  visibleBoundaries.filter(function (boundary) {\n    return boundary.every(function (bound) {\n      return 0 <= bound && bound < itemsCount;\n    });\n  }).forEach(function (boundary) {\n    for (var point = boundary[0]; point <= boundary[1]; point += 1) {\n      breakpoints.add(point);\n    }\n    if (boundary[1] + 1 < itemsCount) {\n      // close last visible point\n      breakpoints.add(boundary[1] + 1);\n    }\n  });\n  var bp = __spread(breakpoints).sort(function (a, b) {\n    return a - b;\n  });\n  var bounds = [];\n  for (var i = 0; i < bp.length - 1; i += 1) {\n    bounds.push([bp[i], bp[i + 1] - 1]);\n  }\n  return bounds;\n};\nvar getItemsSize = function getItemsSize(items, startIndex, endIndex, getItemSize) {\n  var size = 0;\n  for (var i = startIndex; i <= endIndex; i += 1) {\n    size += getItemSize(items[i]);\n  }\n  return size;\n};\nvar getCollapsedColumns = function getCollapsedColumns(columns, visibleBoundaries, boundaries, getColumnWidth) {\n  var collapsedColumns = [];\n  boundaries.forEach(function (boundary) {\n    var isVisible = visibleBoundaries.reduce(function (acc, visibleBoundary) {\n      return acc || visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];\n    }, false);\n    if (isVisible) {\n      var column = columns[boundary[0]];\n      collapsedColumns.push(_assign(_assign({}, column), {\n        width: getColumnWidth(column)\n      }));\n    } else {\n      collapsedColumns.push({\n        key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\n        type: TABLE_STUB_TYPE,\n        width: getItemsSize(columns, boundary[0], boundary[1], getColumnWidth)\n      });\n    }\n  });\n  return collapsedColumns;\n};\nvar getCollapsedRows = function getCollapsedRows(rows, visibleBoundary, boundaries, skipItems, getRowHeight, getCells, offset) {\n  var collapsedRows = [];\n  boundaries.forEach(function (boundary) {\n    var isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];\n    if (isVisible) {\n      var row = rows[boundary[0] - offset];\n      collapsedRows.push({\n        row: row,\n        cells: getCells(row)\n      });\n    } else {\n      var row = {};\n      collapsedRows.push({\n        row: {\n          key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\n          type: TABLE_STUB_TYPE,\n          height: calculateRowHeight(rows, skipItems, getRowHeight, boundary[0], boundary[1])\n        },\n        cells: getCells(row)\n      });\n    }\n  });\n  return collapsedRows;\n};\nvar calculateRowHeight = function calculateRowHeight(rows, skipItems, getRowHeight, bound1, bound2) {\n  if (bound1 === 0) {\n    var end = bound2;\n    if (rows.length && bound2 > rows[rows.length - 1].rowId) {\n      end = bound2 - skipItems[1];\n    }\n    return getItemsSize(rows, skipItems[0], end, getRowHeight);\n  }\n  return getItemsSize(rows, bound1, bound2 - skipItems[1], getRowHeight);\n};\nvar getCollapsedCells = function getCollapsedCells(row, columns, spanBoundaries, boundaries, getColSpan) {\n  var collapsedCells = [];\n  var index = 0;\n  var _loop_1 = function _loop_1() {\n    var boundary = boundaries[index];\n    var isSpan = spanBoundaries.reduce(function (acc, spanBoundary) {\n      return acc || spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1];\n    }, false);\n    if (isSpan) {\n      var column = columns[boundary[0]];\n      var realColSpan = getColSpan(row, column);\n      if (realColSpan + index - 1 !== columns.length) {\n        var realColSpanEnd_1 = realColSpan + boundary[0] - 1;\n        var colSpanEnd = boundaries.findIndex(function (colSpanBoundary) {\n          return colSpanBoundary[0] <= realColSpanEnd_1 && realColSpanEnd_1 <= colSpanBoundary[1];\n        });\n        collapsedCells.push({\n          column: column,\n          colSpan: colSpanEnd - index + 1\n        });\n      } else {\n        collapsedCells.push({\n          column: column,\n          colSpan: realColSpan\n        });\n      }\n      index += 1;\n    } else {\n      collapsedCells.push({\n        column: {\n          key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\n          type: TABLE_STUB_TYPE\n        },\n        colSpan: 1\n      });\n      index += 1;\n    }\n  };\n  while (index < boundaries.length) {\n    _loop_1();\n  }\n  return collapsedCells;\n};\nvar getVisibleColumnBoundaries = function getVisibleColumnBoundaries(rows, boundaries, columns, columnsVisibleBoundary, getColSpan) {\n  var rowSpanBoundaries = rows.slice(boundaries[0], boundaries[1] + 1).map(function (row) {\n    return getSpanBoundaryByRow(row, columns, columnsVisibleBoundary, getColSpan);\n  });\n  return collapseBoundaries(columns.length, columnsVisibleBoundary, rowSpanBoundaries);\n};\nvar getCollapsedGrid = function getCollapsedGrid(_a) {\n  var rows = _a.rows,\n    columns = _a.columns,\n    rowsVisibleBoundary = _a.rowsVisibleBoundary,\n    columnsVisibleBoundary = _a.columnsVisibleBoundary,\n    getColumnWidth = _a.getColumnWidth,\n    getRowHeight = _a.getRowHeight,\n    getColSpan = _a.getColSpan,\n    totalRowCount = _a.totalRowCount,\n    offset = _a.offset;\n  if (!columns.length) {\n    return {\n      columns: [],\n      rows: []\n    };\n  }\n  var boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];\n  var columnBoundaries = getVisibleColumnBoundaries(rows, boundaries, columns, columnsVisibleBoundary, getColSpan);\n  var rowBoundaries = collapseBoundaries(totalRowCount, [boundaries], []);\n  return {\n    columns: getCollapsedColumns(columns, columnsVisibleBoundary, columnBoundaries, getColumnWidth),\n    rows: getCollapsedRows(rows, boundaries, rowBoundaries, [0, 0], getRowHeight, function (row) {\n      return getCollapsedCells(row, columns, getSpanBoundaryByRow(row, columns, columnsVisibleBoundary, getColSpan), columnBoundaries, getColSpan);\n    }, offset)\n  };\n};\nvar getColumnWidthGetter = function getColumnWidthGetter(tableColumns, tableWidth, minColumnWidth) {\n  var colsHavingWidth = tableColumns.filter(function (col) {\n    return typeof col.width === 'number';\n  });\n  var columnsWidth = colsHavingWidth.reduce(function (acc, col) {\n    return acc + col.width;\n  }, 0);\n  var autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);\n  var autoColWidth = Math.max(autoWidth, minColumnWidth);\n  return function (column) {\n    if (column) {\n      return column.type === TABLE_FLEX_TYPE ? 0 : typeof column.width === 'number' ? column.width : autoColWidth;\n    }\n    return autoColWidth;\n  };\n};\nvar getSpanBoundaryByRow = function getSpanBoundaryByRow(row, columns, visibleColumns, getColSpan) {\n  return getSpanBoundary(columns, visibleColumns, function (column) {\n    return getColSpan(row, column);\n  });\n};\nvar getCollapsedGrids = function getCollapsedGrids(_a) {\n  var headerRows = _a.headerRows,\n    bodyRows = _a.bodyRows,\n    footerRows = _a.footerRows,\n    columns = _a.columns,\n    loadedRowsStart = _a.loadedRowsStart,\n    totalRowCount = _a.totalRowCount,\n    getCellColSpan = _a.getCellColSpan,\n    viewport = _a.viewport,\n    skipItems = _a.skipItems,\n    getRowHeight = _a.getRowHeight,\n    getColumnWidth = _a.getColumnWidth;\n  if (!columns.length) {\n    return {\n      headerGrid: {\n        columns: [],\n        rows: []\n      },\n      bodyGrid: {\n        columns: [],\n        rows: []\n      },\n      footerGrid: {\n        columns: [],\n        rows: []\n      }\n    };\n  }\n  var getColSpan = function getColSpan(tableRow, tableColumn) {\n    return getCellColSpan({\n      tableRow: tableRow,\n      tableColumn: tableColumn,\n      tableColumns: columns\n    });\n  };\n  var getCollapsedGridRows = function getCollapsedGridRows(rows, rowsBoundary, columnsBoundary, rowCount, offset) {\n    if (rowCount === void 0) {\n      rowCount = rows.length;\n    }\n    if (offset === void 0) {\n      offset = 0;\n    }\n    return getCollapsedRows(rows, rowsBoundary, collapseBoundaries(rowCount, [rowsBoundary], []), skipItems, getRowHeight, function (row) {\n      return getCollapsedCells(row, columns, getSpanBoundaryByRow(row, columns, viewport.columns, getColSpan), columnsBoundary, getColSpan);\n    }, offset);\n  };\n  var rowsVisibleBoundary = adjustedRenderRowBounds(viewport.rows, bodyRows.length, loadedRowsStart);\n  var columnBoundaries = getVisibleColumnBoundaries(bodyRows, rowsVisibleBoundary, columns, viewport.columns, getColSpan);\n  var commonColumns = getCollapsedColumns(columns, viewport.columns, columnBoundaries, getColumnWidth);\n  return {\n    headerGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(headerRows, getRowsRenderBoundary(headerRows.length, viewport.headerRows), columnBoundaries)\n    },\n    bodyGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(bodyRows, rowsVisibleBoundary, columnBoundaries, totalRowCount || 1, loadedRowsStart)\n    },\n    footerGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(footerRows, getRowsRenderBoundary(footerRows.length, viewport.footerRows), columnBoundaries)\n    }\n  };\n};\nvar adjustedRenderRowBounds = function adjustedRenderRowBounds(visibleBounds, rowCount, loadedRowsStart) {\n  var renderRowBoundaries = getRowsRenderBoundary(loadedRowsStart + rowCount, visibleBounds);\n  var adjustedInterval = intervalUtil.intersect({\n    start: renderRowBoundaries[0],\n    end: renderRowBoundaries[1]\n  }, {\n    start: loadedRowsStart,\n    end: loadedRowsStart + rowCount\n  });\n  return [adjustedInterval.start, adjustedInterval.end];\n};\nvar getGroupIndexByColumn = function getGroupIndexByColumn(grouping, tableColumn) {\n  return grouping.findIndex(function (columnGrouping) {\n    return !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name;\n  });\n};\nvar isIndentCell = function isIndentCell(tableRow, tableColumn, grouping) {\n  if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name) return false;\n  var rowGroupIndex = grouping.findIndex(function (columnGrouping) {\n    return columnGrouping.columnName === tableRow.row.groupedBy;\n  });\n  var columnGroupIndex = getGroupIndexByColumn(grouping, tableColumn);\n  return columnGroupIndex < rowGroupIndex;\n};\nvar isGroupTableCell = function isGroupTableCell(tableRow, tableColumn) {\n  return !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE && tableColumn.column && tableColumn.column.name === tableRow.row.groupedBy);\n};\nvar isGroupIndentTableCell = function isGroupIndentTableCell(tableRow, tableColumn, grouping) {\n  return tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE && isIndentCell(tableRow, tableColumn, grouping);\n};\nvar isGroupIndentStubTableCell = function isGroupIndentStubTableCell(tableRow, tableColumn, grouping) {\n  return tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_STUB_TYPE && isIndentCell(tableRow, tableColumn, grouping);\n};\nvar isGroupTableRow = function isGroupTableRow(tableRow) {\n  return tableRow.type === TABLE_GROUP_TYPE;\n};\nvar isGroupRowOrdinaryCell = function isGroupRowOrdinaryCell(tableRow, tableColumn) {\n  return isGroupTableRow(tableRow) && !isGroupTableCell(tableRow, tableColumn);\n};\nvar columnHasGroupRowSummary = function columnHasGroupRowSummary(tableColumn, groupSummaryItems) {\n  return !!(groupSummaryItems && groupSummaryItems.some(function (item) {\n    return !item.showInGroupFooter && item.alignByColumn && item.columnName === (tableColumn.column && tableColumn.column.name);\n  }));\n};\nvar isRowSummaryCell = function isRowSummaryCell(tableRow, tableColumn, grouping, groupSummaryItems) {\n  return columnHasGroupRowSummary(tableColumn, groupSummaryItems) && !isGroupIndentTableCell(tableRow, tableColumn, grouping);\n};\nvar isPreviousCellContainSummary = function isPreviousCellContainSummary(tableRow, tableColumn, tableColumns, grouping, groupSummaryItems) {\n  var columnIndex = tableColumns.indexOf(tableColumn);\n  return columnIndex > 0 && isRowSummaryCell(tableRow, tableColumns[columnIndex - 1], grouping, groupSummaryItems);\n};\nvar calculateGroupCellIndent = function calculateGroupCellIndent(tableColumn, grouping, indentWidth) {\n  return indentWidth * getGroupIndexByColumn(grouping, tableColumn);\n};\nvar sortAndSpliceColumns = function sortAndSpliceColumns(tableColumns, firstVisibleColumnIndex) {\n  var groupColumns = tableColumns.filter(function (col) {\n    return col.type === TABLE_GROUP_TYPE;\n  });\n  var dataColumns = tableColumns.filter(function (col) {\n    return col.type === TABLE_DATA_TYPE;\n  });\n  var otherColumns = tableColumns.filter(function (col) {\n    return col.type !== TABLE_DATA_TYPE && col.type !== TABLE_GROUP_TYPE && col.type !== TABLE_FLEX_TYPE;\n  });\n  if (firstVisibleColumnIndex) {\n    var firstGroupIndex = tableColumns.indexOf(groupColumns[0]);\n    otherColumns.splice(0, Math.min(firstVisibleColumnIndex, firstGroupIndex));\n  }\n  return __spread(groupColumns, otherColumns, dataColumns);\n};\nvar tableColumnsWithDraftGrouping = function tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped) {\n  return tableColumns.reduce(function (acc, tableColumn) {\n    if (tableColumn.type !== TABLE_DATA_TYPE) {\n      acc.push(tableColumn);\n      return acc;\n    }\n    var columnName = tableColumn.column && tableColumn.column.name || '';\n    var columnGroupingExists = grouping.some(function (columnGrouping) {\n      return columnGrouping.columnName === columnName;\n    });\n    var columnDraftGroupingExists = draftGrouping.some(function (columnGrouping) {\n      return columnGrouping.columnName === columnName;\n    });\n    if (!columnGroupingExists && !columnDraftGroupingExists || showColumnWhenGrouped(columnName)) {\n      acc.push(tableColumn);\n    } else if (!columnGroupingExists && columnDraftGroupingExists || columnGroupingExists && !columnDraftGroupingExists) {\n      acc.push(_assign(_assign({}, tableColumn), {\n        draft: true\n      }));\n    }\n    return acc;\n    // tslint:disable-next-line: prefer-array-literal\n  }, []);\n};\nvar tableColumnsWithGrouping = function tableColumnsWithGrouping(columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped) {\n  return __spread(grouping.map(function (columnGrouping) {\n    var groupedColumn = columns.find(function (column) {\n      return column.name === columnGrouping.columnName;\n    });\n    return {\n      key: TABLE_GROUP_TYPE.toString() + \"_\" + groupedColumn.name,\n      type: TABLE_GROUP_TYPE,\n      column: groupedColumn,\n      width: indentColumnWidth\n    };\n  }), tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped));\n};\nvar tableRowsWithGrouping = function tableRowsWithGrouping(tableRows, isGroupRow) {\n  return tableRows.map(function (tableRow) {\n    if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {\n      return tableRow;\n    }\n    return _assign(_assign({}, tableRow), {\n      key: TABLE_GROUP_TYPE.toString() + \"_\" + tableRow.row.compoundKey,\n      type: TABLE_GROUP_TYPE\n    });\n  });\n};\nvar isRowLevelSummary = function isRowLevelSummary(groupSummaryItems, colName) {\n  return groupSummaryItems.some(function (item) {\n    return !item.showInGroupFooter && item.alignByColumn && item.columnName === colName;\n  });\n};\nvar groupSummaryChains = function groupSummaryChains(tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex) {\n  var captionStarted = false;\n  return sortAndSpliceColumns(tableColumns, firstVisibleColumnIndex).reduce(function (acc, col) {\n    var colName = col.column && col.column.name;\n    var colKey = col.key;\n    var isStartOfGroupCaption = col.type === TABLE_GROUP_TYPE && tableRow.row.groupedBy === colName;\n    var isIndentColumn = col.type === TABLE_GROUP_TYPE && tableRow.row.groupedBy !== colName && !captionStarted;\n    if (isStartOfGroupCaption) {\n      captionStarted = true;\n    }\n    if (isStartOfGroupCaption || isIndentColumn) {\n      acc.push([colKey]);\n    } else if (groupSummaryItems && isRowLevelSummary(groupSummaryItems, colName)) {\n      acc.push([colKey]);\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(colKey);\n    }\n    return acc;\n  }, [[]]);\n};\nvar tableGroupCellColSpanGetter = function tableGroupCellColSpanGetter(getTableCellColSpan, groupSummaryItems, firstVisibleColumnIndex) {\n  return function (params) {\n    var tableRow = params.tableRow,\n      tableColumns = params.tableColumns,\n      tableColumn = params.tableColumn;\n    if (tableRow.type === TABLE_GROUP_TYPE) {\n      var colKey_1 = tableColumn.key;\n      var chains = groupSummaryChains(tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex);\n      var chain = chains.find(function (ch) {\n        return ch[0] === colKey_1;\n      });\n      if (chain) {\n        return chain.length;\n      }\n    }\n    return getTableCellColSpan(params);\n  };\n};\nvar isHeadingTableCell = function isHeadingTableCell(tableRow, tableColumn) {\n  return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isHeadingTableRow = function isHeadingTableRow(tableRow) {\n  return tableRow.type === TABLE_HEADING_TYPE;\n};\nvar findChainByColumnIndex = function findChainByColumnIndex(chains, columnIndex) {\n  return chains.find(function (chain) {\n    return chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length;\n  });\n};\nvar splitHeaderColumnChains = function splitHeaderColumnChains(tableColumnChains, tableColumns, shouldSplitChain, extendChainProps) {\n  return tableColumnChains.map(function (row, rowIndex) {\n    return row.reduce(function (acc, chain) {\n      var currentChain = null;\n      chain.columns.forEach(function (col) {\n        var column = tableColumns.find(function (c) {\n          return c.key === col.key;\n        });\n        var isNewGroup = shouldSplitChain(currentChain, column, rowIndex);\n        if (isNewGroup) {\n          var start = currentChain ? currentChain.start + currentChain.columns.length : chain.start;\n          acc.push(_assign(_assign(_assign({}, chain), extendChainProps(column)), {\n            start: start,\n            columns: []\n          }));\n          currentChain = acc[acc.length - 1];\n        }\n        currentChain.columns.push(column);\n      });\n      return acc;\n    }, []);\n  });\n};\nvar generateSimpleChains = function generateSimpleChains(rows, columns) {\n  return rows.map(function () {\n    return [{\n      columns: columns,\n      start: 0\n    }];\n  });\n};\nvar nextColumnName = function nextColumnName(tableColumns, index) {\n  var isNextColumnHasName = index < tableColumns.length - 1 && tableColumns[index + 1].column;\n  return isNextColumnHasName ? tableColumns[index + 1].column.name : undefined;\n};\nvar getNextColumnName = function getNextColumnName(tableColumns, columnName) {\n  var index = tableColumns.findIndex(function (elem) {\n    return elem.column && elem.column.name === columnName;\n  });\n  return index >= 0 ? nextColumnName(tableColumns, index) : undefined;\n};\nvar tableRowsWithHeading = function tableRowsWithHeading(headerRows) {\n  return __spread([{\n    key: TABLE_HEADING_TYPE.toString(),\n    type: TABLE_HEADING_TYPE\n  }], headerRows);\n};\nvar TABLE_BAND_TYPE = Symbol('band');\nvar BAND_GROUP_CELL = 'bandGroupCell';\nvar BAND_HEADER_CELL = 'bandHeaderCell';\nvar BAND_EMPTY_CELL = 'bandEmptyCell';\nvar BAND_DUPLICATE_RENDER = 'bandDuplicateRender';\nvar BAND_FILL_LEVEL_CELL = 'bandFillLevelCell';\nvar isBandedTableRow = function isBandedTableRow(tableRow) {\n  return tableRow.type === TABLE_BAND_TYPE;\n};\nvar isBandedOrHeaderRow = function isBandedOrHeaderRow(tableRow) {\n  return isBandedTableRow(tableRow) || tableRow.type === TABLE_HEADING_TYPE;\n};\nvar isNoDataColumn = function isNoDataColumn(columnType) {\n  return columnType !== TABLE_DATA_TYPE;\n};\nvar getColumnMeta = function getColumnMeta(columnName, bands, tableRowLevel, key, level, title, result) {\n  if (key === void 0) {\n    key = '';\n  }\n  if (level === void 0) {\n    level = 0;\n  }\n  if (title === void 0) {\n    title = null;\n  }\n  if (result === void 0) {\n    result = null;\n  }\n  return bands.reduce(function (acc, band) {\n    if (band.columnName === columnName) {\n      return _assign(_assign({}, acc), {\n        title: title,\n        level: level,\n        key: key\n      });\n    }\n    if (band.children !== undefined) {\n      var rowLevelPassed = level > tableRowLevel;\n      var bandTitle = rowLevelPassed ? title : band.title;\n      var bandKey = rowLevelPassed ? key : key + \"_\" + bandTitle;\n      return getColumnMeta(columnName, band.children, tableRowLevel, bandKey, level + 1, bandTitle, acc);\n    }\n    return acc;\n  }, result || {\n    level: level,\n    title: title,\n    key: title\n  });\n};\nvar calculateBand = function calculateBand(visibleBound, headerChain) {\n  if (visibleBound) {\n    var bandStart = Math.max(visibleBound[0], headerChain.start);\n    var bandEnd = Math.min(visibleBound[1] + 1, headerChain.start + headerChain.columns.length);\n    return [bandStart, bandEnd];\n  }\n  return [headerChain.start, headerChain.start + headerChain.columns.length];\n};\nvar getBandComponent = function getBandComponent(_a, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains, columnVisibleIntervals, bandLevelsVisibility) {\n  var currentTableColumn = _a.tableColumn,\n    tableRow = _a.tableRow,\n    rowSpan = _a.rowSpan;\n  if (rowSpan) return {\n    type: BAND_DUPLICATE_RENDER,\n    payload: null\n  };\n  var maxLevel = tableHeaderRows.filter(function (column) {\n    return column.type === TABLE_BAND_TYPE;\n  }).length + 1;\n  var level = tableRow.level;\n  var currentRowLevel = level === undefined ? maxLevel - 1 : level;\n  var currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE ? getColumnMeta(currentTableColumn.column.name, columnBands, currentRowLevel) : {\n    level: 0,\n    title: ''\n  };\n  var currentColumnIndex = tableColumns.findIndex(function (column) {\n    return column.key === currentTableColumn.key;\n  });\n  var levelsCount = bandLevelsVisibility.length;\n  var visibleLevelsCount = bandLevelsVisibility.filter(Boolean).length;\n  if (currentColumnMeta.level < currentRowLevel) {\n    var shouldFillLevel = currentRowLevel > 0 && visibleLevelsCount < levelsCount && !bandLevelsVisibility[currentRowLevel] && currentTableColumn.type === TABLE_STUB_TYPE;\n    if (shouldFillLevel) {\n      return {\n        type: BAND_FILL_LEVEL_CELL,\n        payload: null\n      };\n    }\n    return {\n      type: BAND_EMPTY_CELL,\n      payload: null\n    };\n  }\n  var previousTableColumn = tableColumns[currentColumnIndex - 1];\n  var beforeBorder = false;\n  if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE && isNoDataColumn(previousTableColumn.type)) {\n    beforeBorder = true;\n  }\n  var isStubColumn = currentTableColumn.type === TABLE_STUB_TYPE;\n  var isColumnVisible = currentColumnIndex >= 0;\n  if (currentColumnMeta.level === currentRowLevel) {\n    if (isStubColumn) {\n      var cellRowSpan = visibleLevelsCount < levelsCount ? visibleLevelsCount || 1 : maxLevel;\n      return {\n        type: BAND_FILL_LEVEL_CELL,\n        payload: {\n          rowSpan: cellRowSpan\n        }\n      };\n    }\n    if (isColumnVisible) {\n      return {\n        type: BAND_HEADER_CELL,\n        payload: _assign({\n          tableRow: tableHeaderRows.find(function (row) {\n            return row.type === TABLE_HEADING_TYPE;\n          }),\n          rowSpan: maxLevel - currentRowLevel\n        }, beforeBorder && {\n          beforeBorder: beforeBorder\n        })\n      };\n    }\n  }\n  if (!isColumnVisible) return {\n    type: BAND_EMPTY_CELL,\n    payload: null\n  };\n  var currentColumnChain = findChainByColumnIndex(tableHeaderColumnChains[currentRowLevel], currentColumnIndex);\n  var columnVisibleBoundary = columnVisibleIntervals.find(function (_a) {\n    var _b = __read(_a, 2),\n      start = _b[0],\n      end = _b[1];\n    return start <= currentColumnIndex && currentColumnIndex <= end;\n  });\n  var _b = __read(calculateBand(columnVisibleBoundary, currentColumnChain), 2),\n    bandStart = _b[0],\n    bandEnd = _b[1];\n  if (bandStart < currentColumnIndex) {\n    return {\n      type: null,\n      payload: null\n    };\n  }\n  return {\n    type: BAND_GROUP_CELL,\n    payload: _assign({\n      colSpan: bandEnd - bandStart,\n      value: currentColumnMeta.title,\n      column: currentColumnMeta\n    }, beforeBorder && {\n      beforeBorder: beforeBorder\n    })\n  };\n};\nvar emptyVirtualRows = {\n  skip: Number.POSITIVE_INFINITY,\n  rows: []\n};\nvar pluckSubarray = function pluckSubarray(source, sourceStart, left, right) {\n  return source.slice(left - sourceStart, right - sourceStart);\n};\nvar mergeRows = function mergeRows(rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart) {\n  var breakpoints = [rowsInterval.start, rowsInterval.end, cacheInterval.start, cacheInterval.end].filter(function (i) {\n    return 0 <= i && i < Number.POSITIVE_INFINITY;\n  }).sort(function (a, b) {\n    return a - b;\n  });\n  var result = [];\n  if (breakpoints.length > 1) {\n    for (var i = 0; i < breakpoints.length - 1; i += 1) {\n      var left = breakpoints[i];\n      var right = breakpoints[i + 1];\n      var chunk = rowsInterval.start <= left && right <= rowsInterval.end ? pluckSubarray(rows, rowsStart, left, right) // rows have higher priority\n      : pluckSubarray(cacheRows, cacheStart, left, right);\n      result = result.concat(chunk);\n    }\n  }\n  return {\n    skip: breakpoints[0],\n    rows: result\n  };\n};\nvar correctRequestedRange = function correctRequestedRange(calculatedRange, referenceIndex, pageSize) {\n  var start = calculatedRange.start,\n    end = calculatedRange.end;\n  if (start - referenceIndex > pageSize / 2) {\n    return {\n      start: start - pageSize,\n      end: start\n    };\n  }\n  return {\n    start: start,\n    end: end\n  };\n};\nvar calculateRequestedRange = function calculateRequestedRange(virtualRows, newRange, pageSize, referenceIndex, isInfiniteScroll) {\n  var loadedInterval = intervalUtil.getRowsInterval(virtualRows);\n  var isAdjacentPage = Math.abs(loadedInterval.start - newRange.start) < 2 * pageSize;\n  if (isAdjacentPage) {\n    var calculatedRange = intervalUtil.difference(newRange, loadedInterval);\n    if (isInfiniteScroll && calculatedRange !== intervalUtil.empty) {\n      return correctRequestedRange(calculatedRange, referenceIndex, pageSize);\n    }\n    return calculatedRange;\n  }\n  // load 3 pages at once because a missing page will be loaded anyway\n  return newRange;\n};\nvar rowToPageIndex = function rowToPageIndex(rowIndex, pageSize) {\n  return Math.floor(rowIndex / pageSize);\n};\nvar recalculateBounds = function recalculateBounds(middleIndex, pageSize, totalCount) {\n  var currentPageIndex = rowToPageIndex(middleIndex, pageSize);\n  var prevPageIndex = currentPageIndex - 1;\n  var nextPageIndex = currentPageIndex + 2;\n  var start = Math.max(0, prevPageIndex * pageSize);\n  var end = Math.min(nextPageIndex * pageSize, totalCount);\n  return {\n    start: start,\n    end: end\n  };\n};\nvar trimRowsToInterval = function trimRowsToInterval(virtualRows, targetInterval) {\n  var rowsInterval = intervalUtil.getRowsInterval(virtualRows);\n  var intersection = intervalUtil.intersect(rowsInterval, targetInterval);\n  if (intervalUtil.empty === intersection) {\n    return emptyVirtualRows;\n  }\n  var rows = pluckSubarray(virtualRows.rows, virtualRows.skip, intersection.start, intersection.end);\n  return {\n    rows: rows,\n    skip: intersection.start\n  };\n};\nvar getAvailableRowCount = function getAvailableRowCount(isInfiniteScroll, newRowCount, lastRowCount, totalRowCount) {\n  return isInfiniteScroll ? Math.min(Math.max(newRowCount, lastRowCount), totalRowCount) : totalRowCount;\n};\nvar getForceReloadInterval = function getForceReloadInterval(virtualRows, pageSize, totalRowCount) {\n  var _a = intervalUtil.getRowsInterval(virtualRows),\n    start = _a.start,\n    intervalEnd = _a.end;\n  var end = Math.min(Math.max(start + pageSize * 2, intervalEnd), Math.max(start + pageSize * 2, totalRowCount));\n  return {\n    start: start,\n    end: end\n  };\n};\nvar getRequestMeta = function getRequestMeta(referenceIndex, virtualRows, pageSize, totalRowCount, forceReload, isInfiniteScroll) {\n  var actualBounds = forceReload ? getForceReloadInterval(virtualRows, pageSize, totalRowCount) : recalculateBounds(referenceIndex, pageSize, totalRowCount);\n  var requestedRange = forceReload ? actualBounds : calculateRequestedRange(virtualRows, actualBounds, pageSize, referenceIndex, isInfiniteScroll);\n  return {\n    requestedRange: requestedRange,\n    actualBounds: actualBounds\n  };\n};\nvar needFetchMorePages = function needFetchMorePages(virtualRows, referenceIndex, pageSize) {\n  var _a = intervalUtil.getRowsInterval(virtualRows),\n    start = _a.start,\n    end = _a.end;\n  var loadCount = end - start;\n  var topTriggerIndex = start > 0 ? start + pageSize : 0;\n  var bottomTriggerIndex = Math.max(topTriggerIndex + pageSize, end - pageSize * 1.5);\n  if (loadCount <= 0) {\n    return false;\n  }\n  return referenceIndex < topTriggerIndex || bottomTriggerIndex < referenceIndex;\n};\nvar getReferenceIndex = function getReferenceIndex(_a) {\n  var _b = __read(_a.rows, 2),\n    top = _b[0],\n    bottom = _b[1];\n  return (top + bottom) / 2;\n};\nvar shouldSendRequest = function shouldSendRequest(_a, requestedPageIndex, requestedEndIndex) {\n  var start = _a.start,\n    end = _a.end;\n  var loadCount = end - start;\n  return (start !== requestedPageIndex || end !== requestedEndIndex) && loadCount > 0;\n};\nvar empty = {\n  start: Number.POSITIVE_INFINITY,\n  end: Number.NEGATIVE_INFINITY\n};\nvar getRowsInterval = function getRowsInterval(r) {\n  return r === emptyVirtualRows ? empty : {\n    start: r.skip,\n    end: r.skip + r.rows.length\n  };\n};\nvar getLength = function getLength(a) {\n  return a.end - a.start;\n};\nvar intersect = function intersect(a, b) {\n  if (a.end < b.start || b.end < a.start) {\n    return empty;\n  }\n  return {\n    start: Math.max(a.start, b.start),\n    end: Math.min(a.end, b.end)\n  };\n};\nvar difference = function difference(a, b) {\n  if (empty === intervalUtil.intersect(a, b)) {\n    return a;\n  }\n  if (b.end < a.end) {\n    return {\n      start: b.end,\n      end: a.end\n    };\n  }\n  if (a.start < b.start) {\n    return {\n      start: a.start,\n      end: b.start\n    };\n  }\n  return empty;\n};\nvar intervalUtil = {\n  empty: empty,\n  getRowsInterval: getRowsInterval,\n  getLength: getLength,\n  intersect: intersect,\n  difference: difference\n};\nvar tableRowsWithBands = function tableRowsWithBands(tableHeaderRows, columnBands, tableColumns) {\n  var tableDataColumns = tableColumns.filter(function (column) {\n    return column.type === TABLE_DATA_TYPE;\n  });\n  var getMaxNestedLevel = function getMaxNestedLevel(bands, level, result) {\n    if (level === void 0) {\n      level = 0;\n    }\n    if (result === void 0) {\n      result = null;\n    }\n    return bands.reduce(function (acc, column) {\n      if (column.children !== undefined) {\n        return getMaxNestedLevel(column.children, level + 1, acc);\n      }\n      var isDataColumn = tableDataColumns.findIndex(function (dataColumn) {\n        return !!dataColumn.column && dataColumn.column.name === column.columnName;\n      }) > -1;\n      if (level > acc.level && isDataColumn) {\n        return _assign(_assign({}, acc), {\n          level: level\n        });\n      }\n      return acc;\n    }, result || {\n      level: 0\n    });\n  };\n  var tableBandHeaders = Array.from({\n    length: getMaxNestedLevel(columnBands, 0).level\n  }).map(function (row, index) {\n    return {\n      key: TABLE_BAND_TYPE.toString() + \"_\" + index,\n      type: TABLE_BAND_TYPE,\n      level: index\n    };\n  });\n  return __spread(tableBandHeaders, tableHeaderRows);\n};\nvar tableHeaderColumnChainsWithBands = function tableHeaderColumnChainsWithBands(tableHeaderRows, tableColumns, bands) {\n  var chains = generateSimpleChains(tableHeaderRows, tableColumns);\n  var maxBandRowIndex = tableHeaderRows.filter(function (row) {\n    return row.type === TABLE_BAND_TYPE;\n  }).length;\n  var rawBandChains = chains.slice(0, maxBandRowIndex);\n  var currentBand = null;\n  var shouldSplitChain = function shouldSplitChain(chain, column, rowIndex) {\n    if (rowIndex > maxBandRowIndex) return false;\n    var columnName = column.column && column.column.name || '';\n    currentBand = getColumnMeta(columnName, bands, rowIndex);\n    return !chain || chain.key !== currentBand.key || chain.columns[0].type === TABLE_GROUP_TYPE;\n  };\n  var extendChainProps = function extendChainProps() {\n    return {\n      bandTitle: currentBand === null || currentBand === void 0 ? void 0 : currentBand.title,\n      key: currentBand === null || currentBand === void 0 ? void 0 : currentBand.key\n    };\n  };\n  var bandChains = splitHeaderColumnChains(rawBandChains, tableColumns, shouldSplitChain, extendChainProps);\n  return __spread(bandChains, chains.slice(maxBandRowIndex));\n};\nvar getBandLevels = function getBandLevels(columnsBands, levels, level) {\n  if (levels === void 0) {\n    levels = {};\n  }\n  if (level === void 0) {\n    level = 0;\n  }\n  columnsBands.forEach(function (band) {\n    if (band.title) {\n      levels[band.title] = level;\n    }\n    if (band.children) {\n      getBandLevels(band.children, levels, level + 1);\n    }\n  });\n  return levels;\n};\nvar columnBandLevels = function columnBandLevels(columnsBands) {\n  return getBandLevels(columnsBands);\n};\nvar bandLevelsVisibility = function bandLevelsVisibility(columnIntervals, tableHeaderColumnChains, bandLevels) {\n  var rowsWithBands = tableHeaderColumnChains.filter(function (r) {\n    return r.filter(function (ch) {\n      return !!ch.bandTitle;\n    }).length;\n  });\n  var visibleIntervals = columnIntervals.map(function (_a) {\n    var _b = __read(_a, 2),\n      start = _b[0],\n      end = _b[1];\n    return {\n      start: start,\n      end: end\n    };\n  });\n  var isBandChainVisible = function isBandChainVisible(chain) {\n    return visibleIntervals.some(function (interval) {\n      return intervalUtil.intersect(interval, {\n        start: chain.start,\n        end: chain.start + chain.columns.length - 1\n      }) !== intervalUtil.empty;\n    });\n  };\n  var getVisibleBandsByLevel = function getVisibleBandsByLevel(level) {\n    return (\n      // Note: a visible band level always matches with it's row\n      rowsWithBands[level] ? rowsWithBands[level].filter(function (chain) {\n        return bandLevels[chain.bandTitle] === level && isBandChainVisible(chain);\n      }) : []\n    );\n  };\n  return rowsWithBands.reduce(function (acc, _, index) {\n    var rowBands = getVisibleBandsByLevel(index);\n    return __spread(acc, [!!rowBands.length]);\n  }, []);\n};\nvar columnVisibleIntervals = function columnVisibleIntervals(viewport, tableColumns) {\n  return viewport ? viewport.columns : [[0, tableColumns.length]];\n};\nvar toggleDetailRowExpanded = function toggleDetailRowExpanded(prevExpanded, _a) {\n  var rowId = _a.rowId,\n    state = _a.state;\n  return toggle(prevExpanded, [rowId], state);\n};\nvar TABLE_DETAIL_TYPE = Symbol('detail');\nvar isDetailRowExpanded = function isDetailRowExpanded(expandedDetailRowIds, rowId) {\n  return expandedDetailRowIds.indexOf(rowId) > -1;\n};\nvar isDetailToggleTableCell = function isDetailToggleTableCell(tableRow, tableColumn) {\n  return tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE;\n};\nvar isDetailTableRow = function isDetailTableRow(tableRow) {\n  return tableRow.type === TABLE_DETAIL_TYPE;\n};\nvar isDetailTableCell = function isDetailTableCell(tableColumn, tableColumns) {\n  return tableColumns.indexOf(tableColumn) === 0;\n};\nvar tableRowsWithExpandedDetail = function tableRowsWithExpandedDetail(tableRows, expandedDetailRowIds, rowHeight) {\n  var result = tableRows;\n  expandedDetailRowIds.forEach(function (expandedRowId) {\n    var rowIndex = result.findIndex(function (tableRow) {\n      return tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId;\n    });\n    if (rowIndex === -1) return;\n    var insertIndex = rowIndex + 1;\n    var _a = result[rowIndex],\n      row = _a.row,\n      rowId = _a.rowId;\n    result = __spread(result.slice(0, insertIndex), [{\n      rowId: rowId,\n      row: row,\n      key: TABLE_DETAIL_TYPE.toString() + \"_\" + rowId,\n      type: TABLE_DETAIL_TYPE,\n      height: rowHeight\n    }], result.slice(insertIndex));\n  });\n  return result;\n};\nvar tableColumnsWithDetail = function tableColumnsWithDetail(tableColumns, toggleColumnWidth) {\n  return __spread([{\n    key: TABLE_DETAIL_TYPE.toString(),\n    type: TABLE_DETAIL_TYPE,\n    width: toggleColumnWidth\n  }], tableColumns);\n};\nvar tableDetailCellColSpanGetter = function tableDetailCellColSpanGetter(getTableCellColSpan) {\n  return function (params) {\n    var tableRow = params.tableRow,\n      tableColumns = params.tableColumns,\n      tableColumn = params.tableColumn;\n    if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n      return tableColumns.length;\n    }\n    return getTableCellColSpan(params);\n  };\n};\nvar TABLE_SELECT_TYPE = Symbol('select');\nvar isSelectTableCell = function isSelectTableCell(tableRow, tableColumn) {\n  return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE;\n};\nvar isSelectAllTableCell = function isSelectAllTableCell(tableRow, tableColumn) {\n  return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE;\n};\nvar isRowHighlighted = function isRowHighlighted(highlightRow, selection, tableRow, focused) {\n  var highlightion = selection ? selection.concat(focused || []) : focused;\n  return !!(highlightRow && highlightion && highlightion.includes(tableRow.rowId));\n};\nvar tableColumnsWithSelection = function tableColumnsWithSelection(tableColumns, selectionColumnWidth, showSelectionColumn) {\n  if (showSelectionColumn) {\n    return __spread([{\n      key: TABLE_SELECT_TYPE.toString(),\n      type: TABLE_SELECT_TYPE,\n      width: selectionColumnWidth\n    }], tableColumns);\n  }\n  return tableColumns;\n};\nvar VALID_UNITS$1 = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nvar TABLE_ERROR = 'The columnExtension property of the Table plugin is given an invalid value.';\nvar isDataTableCell = function isDataTableCell(tableRow, tableColumn) {\n  return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isHeaderStubTableCell = function isHeaderStubTableCell(tableRow, headerRows) {\n  return headerRows.indexOf(tableRow) > -1;\n};\nvar isDataTableRow = function isDataTableRow(tableRow) {\n  return tableRow.type === TABLE_DATA_TYPE;\n};\nvar isNoDataTableRow = function isNoDataTableRow(tableRow) {\n  return tableRow.type === TABLE_NODATA_TYPE;\n};\nvar isNoDataTableCell = function isNoDataTableCell(tableColumn, tableColumns) {\n  return tableColumns.indexOf(tableColumn) === 0;\n};\nvar isStubTableCell = function isStubTableCell(tableRow) {\n  return tableRow.type === TABLE_STUB_TYPE;\n};\nvar checkTableColumnExtensions = function checkTableColumnExtensions(columnExtensions) {\n  if (columnExtensions) {\n    columnExtensions.map(function (column) {\n      var width = column.width;\n      if (typeof width === 'string') {\n        if (!isValidValue(width, VALID_UNITS$1)) {\n          throw new Error(TABLE_ERROR);\n        }\n      }\n    });\n  }\n};\nvar getColumnExtension = function getColumnExtension(columnExtensions, columnName) {\n  if (!columnExtensions) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {};\n  }\n  var columnExtension = columnExtensions.find(function (extension) {\n    return extension.columnName === columnName;\n  });\n  if (!columnExtension) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {};\n  }\n  return columnExtension;\n};\nvar getColumnExtensionValueGetter = function getColumnExtensionValueGetter(columnExtensions, extensionName, defaultValue) {\n  return function (columnName) {\n    if (columnExtensions) {\n      var columnExtension = getColumnExtension(columnExtensions, columnName);\n      var extensionValue = columnExtension[extensionName];\n      return extensionValue !== undefined ? extensionValue : defaultValue;\n    }\n    return defaultValue;\n  };\n};\nvar tableColumnsWithDataRows = function tableColumnsWithDataRows(columns, columnExtensions) {\n  return columns.map(function (column) {\n    var name = column.name;\n    var columnExtension = getColumnExtension(columnExtensions, name);\n    var width = convertWidth(columnExtension.width);\n    return {\n      column: column,\n      key: TABLE_DATA_TYPE.toString() + \"_\" + name,\n      type: TABLE_DATA_TYPE,\n      width: width,\n      align: columnExtension.align,\n      wordWrapEnabled: columnExtension.wordWrapEnabled\n    };\n  });\n};\nvar tableRowsWithDataRows = function tableRowsWithDataRows(rows, getRowId, isRemoteRowsLoading) {\n  return !rows.length && !isRemoteRowsLoading ? [{\n    key: TABLE_NODATA_TYPE.toString(),\n    type: TABLE_NODATA_TYPE\n  }] : rows.map(function (row, dataIndex) {\n    var rowId = getRowId(row);\n    return {\n      row: row,\n      // dataIndex,\n      rowId: rowId,\n      type: TABLE_DATA_TYPE,\n      key: TABLE_DATA_TYPE.toString() + \"_\" + rowId\n    };\n  });\n};\nvar tableCellColSpanGetter = function tableCellColSpanGetter(params) {\n  var tableRow = params.tableRow,\n    tableColumns = params.tableColumns,\n    tableColumn = params.tableColumn;\n  if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n    return tableColumns.length;\n  }\n  return 1;\n};\nvar visibleTableColumns = function visibleTableColumns(tableColumns, hiddenColumnNames) {\n  if (tableColumns === void 0) {\n    tableColumns = [];\n  }\n  return tableColumns.filter(function (tableColumn) {\n    return tableColumn.type !== TABLE_DATA_TYPE || hiddenColumnNames.indexOf(tableColumn.column.name) === -1;\n  });\n};\nvar tableDataColumnsExist = function tableDataColumnsExist(tableColumns) {\n  return tableColumns.some(function (column) {\n    return column.type === TABLE_DATA_TYPE;\n  });\n};\nvar columnChooserItems = function columnChooserItems(columns, hiddenColumnNames) {\n  return columns.map(function (column) {\n    return {\n      column: column,\n      hidden: hiddenColumnNames.indexOf(column.name) !== -1\n    };\n  });\n};\nvar toggleColumn = function toggleColumn(hiddenColumnNames, columnName) {\n  return hiddenColumnNames.indexOf(columnName) === -1 ? __spread(hiddenColumnNames, [columnName]) : hiddenColumnNames.filter(function (hiddenColumn) {\n    return hiddenColumn !== columnName;\n  });\n};\nvar toggleRowExpanded = function toggleRowExpanded(prevExpanded, _a) {\n  var rowId = _a.rowId,\n    state = _a.state;\n  return toggle(prevExpanded, [rowId], state);\n};\nvar GRID_TREE_NODE_TYPE = Symbol('treeNode');\nvar customTreeRowsWithMeta = function customTreeRowsWithMeta(rows, getChildRows) {\n  var rowsToProcess = [{\n    row: null,\n    level: -1\n  }];\n  var treeRows = [];\n  var _loop_1 = function _loop_1() {\n    var _a = rowsToProcess.shift(),\n      currentRow = _a.row,\n      level = _a.level;\n    var rowIndex = treeRows.findIndex(function (_a) {\n      var row = _a.row;\n      return row === currentRow;\n    });\n    var nestedRows = (_a = getChildRows(currentRow, rows)) === null || _a === void 0 ? void 0 : _a.map(function (childRow) {\n      return {\n        row: childRow,\n        level: level + 1,\n        leaf: !getChildRows(childRow, rows)\n      };\n    });\n    if (nestedRows) {\n      if (rowIndex > -1) {\n        treeRows.splice.apply(treeRows, __spread([rowIndex + 1, 0], nestedRows));\n      } else {\n        treeRows.push.apply(treeRows, __spread(nestedRows));\n      }\n      rowsToProcess.push.apply(rowsToProcess, __spread(nestedRows));\n    }\n  };\n  while (rowsToProcess === null || rowsToProcess === void 0 ? void 0 : rowsToProcess.length) {\n    _loop_1();\n  }\n  var result = treeRows.reduce(function (acc, _a) {\n    var row = _a.row,\n      level = _a.level,\n      leaf = _a.leaf;\n    acc.rows.push(row);\n    acc.treeMeta.push([row, {\n      level: level,\n      leaf: leaf\n    }]);\n    return acc;\n  }, {\n    rows: [],\n    treeMeta: []\n  });\n  return {\n    rows: result.rows,\n    treeMeta: new Map(result.treeMeta)\n  };\n};\nvar customTreeRowIdGetter = function customTreeRowIdGetter(getRowId, _a) {\n  var rows = _a.rows,\n    treeMeta = _a.treeMeta;\n  var firstNestedRowIndex = rows.findIndex(function (row) {\n    return treeMeta.get(row).level > 0;\n  });\n  if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== undefined) {\n    return getRowId;\n  }\n  var map = new Map(rows.map(function (row, rowIndex) {\n    return [row, rowIndex];\n  }));\n  return function (row) {\n    return map.get(row);\n  };\n};\nvar customTreeRowLevelKeyGetter = function customTreeRowLevelKeyGetter(getRowLevelKey, _a) {\n  var treeMeta = _a.treeMeta;\n  return function (row) {\n    var rowMeta = treeMeta.get(row);\n    if (rowMeta !== undefined) {\n      return GRID_TREE_NODE_TYPE.toString() + \"_\" + rowMeta.level;\n    }\n    return getRowLevelKey && getRowLevelKey();\n  };\n};\nvar expandedTreeRows = function expandedTreeRows(_a, getRowId, expandedRowIds) {\n  var rows = _a.rows,\n    treeMeta = _a.treeMeta;\n  var expandedRowIdsSet = new Set(expandedRowIds);\n  var currentExpanded = true;\n  var currentLevel = 0;\n  var collapsedRowsMeta = new Map();\n  var resultRows = [];\n  rows.forEach(function (row) {\n    var rowMeta = treeMeta.get(row);\n    var level = rowMeta && rowMeta.level;\n    if (level === undefined && currentExpanded) {\n      resultRows.push(row);\n    } else if (!currentExpanded && (level === undefined || level > currentLevel)) {\n      var lastRow = resultRows[resultRows.length - 1];\n      var collapsedItems = collapsedRowsMeta.get(lastRow);\n      if (!collapsedItems) {\n        collapsedItems = [];\n        collapsedRowsMeta.set(lastRow, collapsedItems);\n      }\n      collapsedItems.push(row);\n    } else {\n      currentExpanded = expandedRowIdsSet.has(getRowId(row));\n      currentLevel = level;\n      resultRows.push(row);\n    }\n  });\n  return {\n    treeMeta: treeMeta,\n    collapsedRowsMeta: collapsedRowsMeta,\n    rows: resultRows\n  };\n};\nvar collapsedTreeRowsGetter = function collapsedTreeRowsGetter(getCollapsedRows, _a) {\n  var collapsedRowsMeta = _a.collapsedRowsMeta;\n  return function (row) {\n    return collapsedRowsMeta.get(row) || getCollapsedRows && getCollapsedRows(row);\n  };\n};\nvar isTreeRowLeafGetter = function isTreeRowLeafGetter(_a) {\n  var treeMeta = _a.treeMeta;\n  return function (row) {\n    var rowMeta = treeMeta.get(row);\n    return rowMeta && rowMeta.leaf;\n  };\n};\nvar getTreeRowLevelGetter = function getTreeRowLevelGetter(_a) {\n  var treeMeta = _a.treeMeta;\n  return function (row) {\n    var rowMeta = treeMeta.get(row);\n    return rowMeta && rowMeta.level;\n  };\n};\nvar unwrappedCustomTreeRows = function unwrappedCustomTreeRows(_a) {\n  var rows = _a.rows;\n  return rows;\n};\nvar isTreeTableCell = function isTreeTableCell(tableRow, tableColumn, forColumnName) {\n  return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE && tableColumn.column.name === forColumnName;\n};\nvar changeSearchValue = function changeSearchValue(prevSearchValue, searchValue) {\n  return searchValue;\n};\nvar searchFilterExpression = function searchFilterExpression(searchValue, columns, filterExpression) {\n  var filters = columns.map(function (_a) {\n    var name = _a.name;\n    return {\n      columnName: name,\n      value: searchValue\n    };\n  });\n  var selfFilterExpression = {\n    filters: filters,\n    operator: 'or'\n  };\n  if (!filterExpression) {\n    return selfFilterExpression;\n  }\n  return {\n    operator: 'and',\n    filters: [filterExpression, selfFilterExpression]\n  };\n};\nvar getAvailableFilterOperationsGetter = function getAvailableFilterOperationsGetter(getAvailableFilterOperations, availableFilterOperations, columnNames) {\n  return function (columnName) {\n    return columnNames.indexOf(columnName) > -1 && availableFilterOperations\n    // tslint:disable-next-line: max-line-length\n    || typeof getAvailableFilterOperations === 'function' && getAvailableFilterOperations(columnName) || undefined;\n  };\n};\nvar FIXED_COLUMN_LEFT_SIDE = 'left';\nvar FIXED_COLUMN_RIGHT_SIDE = 'right';\nvar TABLE_FIXED_TYPE = Symbol('fixed');\nvar getFixedColumnKeys = function getFixedColumnKeys(tableColumns, fixedNames) {\n  return tableColumns.filter(function (tableColumn) {\n    return tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column.name) !== -1 || fixedNames.indexOf(tableColumn.type) !== -1;\n  }).map(function (_a) {\n    var key = _a.key;\n    return key;\n  });\n};\nvar isFixedTableRow = function isFixedTableRow(tableRow) {\n  return tableRow.type === TABLE_FIXED_TYPE;\n};\nvar calculatePosition = function calculatePosition(array, index, tableColumnDimensions) {\n  return index === 0 ? 0 : array.slice(0, index).reduce(function (acc, target) {\n    return acc + tableColumnDimensions[target] || 0;\n  }, 0);\n};\nvar calculateFixedColumnProps = function calculateFixedColumnProps(_a, _b, tableColumns, tableColumnDimensions, tableHeaderColumnChains) {\n  var tableColumn = _a.tableColumn;\n  var leftColumns = _b.leftColumns,\n    rightColumns = _b.rightColumns;\n  var side = tableColumn.fixed;\n  var targetArray = side === FIXED_COLUMN_LEFT_SIDE ? getFixedColumnKeys(tableColumns, leftColumns) : slice(getFixedColumnKeys(tableColumns, rightColumns)).reverse();\n  var index = tableColumns.findIndex(function (_a) {\n    var key = _a.key;\n    return key === tableColumn.key;\n  });\n  var fixedIndex = targetArray.indexOf(tableColumn.key);\n  var columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index);\n  var showLeftDivider = columnChain.start === index && index !== 0;\n  var showRightDivider = columnChain.start + columnChain.columns.length - 1 === index && index < tableColumns.length - 1;\n  var position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);\n  return {\n    showRightDivider: showRightDivider,\n    showLeftDivider: showLeftDivider,\n    position: position,\n    side: side\n  };\n};\nvar tableColumnsWithFixed = function tableColumnsWithFixed(tableColumns, leftColumns, rightColumns) {\n  return tableColumns.map(function (tableColumn) {\n    var fixed;\n    if (tableColumn.type === TABLE_DATA_TYPE && leftColumns.indexOf(tableColumn.column.name) !== -1 || leftColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_LEFT_SIDE;\n    }\n    if (tableColumn.type === TABLE_DATA_TYPE && rightColumns.indexOf(tableColumn.column.name) !== -1 || rightColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_RIGHT_SIDE;\n    }\n    return fixed ? _assign(_assign({}, tableColumn), {\n      fixed: fixed\n    }) : tableColumn;\n  });\n};\nvar tableHeaderRowsWithFixed = function tableHeaderRowsWithFixed(tableHeaderRows) {\n  return __spread(tableHeaderRows, [{\n    key: TABLE_FIXED_TYPE.toString(),\n    type: TABLE_FIXED_TYPE,\n    height: 0\n  }]);\n};\nvar tableHeaderColumnChainsWithFixed = function tableHeaderColumnChainsWithFixed(tableHeaderColumnChains, tableHeaderRows, tableColumns) {\n  var chains = tableHeaderColumnChains || generateSimpleChains(tableHeaderRows, tableColumns);\n  var shouldSplitChain = function shouldSplitChain(currentGroup, column) {\n    return !currentGroup || currentGroup.fixed !== column.fixed;\n  };\n  var extendChainProps = function extendChainProps(column) {\n    return {\n      fixed: column.fixed\n    };\n  };\n  return splitHeaderColumnChains(chains, tableColumns, shouldSplitChain, extendChainProps);\n};\nvar defaultSummaryCalculators = {\n  count: function count(rows) {\n    return rows.length;\n  },\n  sum: function sum(rows, getValue) {\n    return rows.reduce(function (acc, row) {\n      return acc + getValue(row);\n    }, 0);\n  },\n  max: function max(rows, getValue) {\n    return rows.length ? rows.reduce(function (acc, row) {\n      return Math.max(acc, getValue(row));\n    }, -Infinity) : null;\n  },\n  min: function min(rows, getValue) {\n    return rows.length ? rows.reduce(function (acc, row) {\n      return Math.min(acc, getValue(row));\n    }, Infinity) : null;\n  },\n  avg: function avg(rows, getValue) {\n    return rows.length ? rows.reduce(function (acc, row) {\n      return acc + getValue(row);\n    }, 0) / rows.length : null;\n  }\n};\nvar defaultSummaryCalculator = function defaultSummaryCalculator(type, rows, getValue) {\n  var summaryCalculator = defaultSummaryCalculators[type];\n  if (!summaryCalculator) {\n    throw new Error(\"The summary type '\" + type + \"' is not defined\");\n  }\n  return summaryCalculator(rows, getValue);\n};\nvar rowsSummary = function rowsSummary(rows, summaryItems, getCellValue, calculator) {\n  return summaryItems.reduce(function (acc, _a) {\n    var type = _a.type,\n      columnName = _a.columnName;\n    var getValue = function getValue(row) {\n      return getCellValue(row, columnName);\n    };\n    acc.push(calculator(type, rows, getValue));\n    return acc;\n  }, []);\n};\nvar expandRows = function expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow, includeGroupRow) {\n  if (includeGroupRow === void 0) {\n    includeGroupRow = false;\n  }\n  var shouldIncludeRow = includeGroupRow || !isGroupRow ? function () {\n    return true;\n  } : function (row) {\n    return !isGroupRow(row);\n  };\n  return rows.reduce(function (acc, row) {\n    if (getRowLevelKey && getRowLevelKey(row)) {\n      if (shouldIncludeRow(row)) {\n        acc.push(row);\n      }\n      var collapsedRows = getCollapsedRows && getCollapsedRows(row);\n      if (collapsedRows) {\n        acc.push.apply(acc, __spread(collapsedRows));\n      }\n      return acc;\n    }\n    acc.push(row);\n    return acc;\n  }, []);\n};\nvar totalSummaryValues = function totalSummaryValues(rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {\n  if (calculator === void 0) {\n    calculator = defaultSummaryCalculator;\n  }\n  var plainRows = expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow);\n  return rowsSummary(plainRows, summaryItems, getCellValue, calculator);\n};\nvar groupSummaryValues = function groupSummaryValues(rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {\n  if (calculator === void 0) {\n    calculator = defaultSummaryCalculator;\n  }\n  var levels = [];\n  var getLevelIndex = function getLevelIndex(levelKey) {\n    return levels.findIndex(function (level) {\n      return level.levelKey === levelKey;\n    });\n  };\n  var summaries = {};\n  var anyRowLevelSummaryExist = summaryItems.some(function (item) {\n    return !item.showInGroupFooter;\n  });\n  var expandedRows = anyRowLevelSummaryExist ? expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow, true) : rows;\n  expandedRows.forEach(function (row) {\n    var levelKey = getRowLevelKey(row);\n    var collapsedRows = getCollapsedRows && getCollapsedRows(row);\n    var levelIndex = getLevelIndex(levelKey);\n    if (levelIndex > -1) {\n      levels.forEach(function (level) {\n        summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n    if (isGroupRow(row)) {\n      levels.push({\n        levelKey: levelKey,\n        row: row,\n        rows: []\n      });\n      levelIndex = getLevelIndex(levelKey);\n    }\n    // when row level summary exists, these rows had already been expanded earlier\n    var isCollapsedNestedGroupRow = collapsedRows && levelIndex > 0 && !anyRowLevelSummaryExist;\n    var rowsToAppend = !levelKey ? [row] : collapsedRows;\n    if (!levelKey || isCollapsedNestedGroupRow) {\n      levels.forEach(function (level) {\n        var _a;\n        (_a = level.rows).push.apply(_a, __spread(rowsToAppend));\n      });\n    }\n  }, {});\n  levels.forEach(function (level) {\n    summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n  });\n  return summaries;\n};\nvar treeSummaryValues = function treeSummaryValues(rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator) {\n  if (calculator === void 0) {\n    calculator = defaultSummaryCalculator;\n  }\n  var levels = [];\n  var summaries = {};\n  rows.forEach(function (row) {\n    var levelKey = getRowLevelKey(row);\n    if (!levelKey) {\n      levels[levels.length - 1].rows.push(row);\n      return;\n    }\n    var levelIndex = levels.findIndex(function (level) {\n      return level.levelKey === levelKey;\n    });\n    if (levelIndex > -1) {\n      levels.slice(levelIndex).forEach(function (level) {\n        if (level.rows.length) {\n          summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n        }\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n    if (!isGroupRow || !isGroupRow(row)) {\n      if (levels.length) {\n        levels[levels.length - 1].rows.push(row);\n      }\n      levels.push({\n        levelKey: levelKey,\n        row: row,\n        rows: []\n      });\n    }\n  }, {});\n  levels.forEach(function (level) {\n    if (level.rows.length) {\n      summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n    }\n  });\n  return summaries;\n};\nvar TABLE_TOTAL_SUMMARY_TYPE = Symbol('totalSummary');\nvar TABLE_GROUP_SUMMARY_TYPE = Symbol('groupSummary');\nvar TABLE_TREE_SUMMARY_TYPE = Symbol('treeSummary');\nvar defaultFormatlessSummaries = ['count'];\nvar isTotalSummaryTableCell = function isTotalSummaryTableCell(tableRow, tableColumn) {\n  return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isGroupSummaryTableCell = function isGroupSummaryTableCell(tableRow, tableColumn) {\n  return tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isTreeSummaryTableCell = function isTreeSummaryTableCell(tableRow, tableColumn) {\n  return tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isTotalSummaryTableRow = function isTotalSummaryTableRow(tableRow) {\n  return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE;\n};\nvar isGroupSummaryTableRow = function isGroupSummaryTableRow(tableRow) {\n  return tableRow.type === TABLE_GROUP_SUMMARY_TYPE;\n};\nvar isTreeSummaryTableRow = function isTreeSummaryTableRow(tableRow) {\n  return tableRow.type === TABLE_TREE_SUMMARY_TYPE;\n};\nvar getColumnSummaries = function getColumnSummaries(summaryItems, columnName, summaryValues, predicate) {\n  if (predicate === void 0) {\n    predicate = function predicate() {\n      return true;\n    };\n  }\n  return summaryItems.map(function (item, index) {\n    return [item, index];\n  }).filter(function (_a) {\n    var _b = __read(_a, 1),\n      item = _b[0];\n    return item.columnName === columnName && predicate(item);\n  }).map(function (_a) {\n    var _b = __read(_a, 2),\n      item = _b[0],\n      index = _b[1];\n    return {\n      type: item.type,\n      value: summaryValues[index]\n    };\n  });\n};\nvar isFooterSummary = function isFooterSummary(summaryItem) {\n  return summaryItem.showInGroupFooter;\n};\nvar isInlineGroupCaptionSummary = function isInlineGroupCaptionSummary(summaryItem) {\n  return !(summaryItem.showInGroupFooter || summaryItem.alignByColumn);\n};\nvar groupFooterSummaryExists = function groupFooterSummaryExists(groupSummaryItems) {\n  return groupSummaryItems === null || groupSummaryItems === void 0 ? void 0 : groupSummaryItems.some(isFooterSummary);\n};\nvar getGroupInlineSummaries = function getGroupInlineSummaries(summaryItems, columns, summaryValues) {\n  if (!summaryItems.some(isInlineGroupCaptionSummary)) {\n    return [];\n  }\n  return columns.reduce(function (acc, column) {\n    var colName = column.name;\n    var summaries = getColumnSummaries(summaryItems, colName, summaryValues, isInlineGroupCaptionSummary);\n    if (summaries.length) {\n      acc.push({\n        column: column,\n        summaries: summaries\n      });\n    }\n    return acc;\n  }, []);\n};\nvar tableRowsWithTotalSummaries = function tableRowsWithTotalSummaries(footerRows) {\n  return __spread([{\n    key: TABLE_TOTAL_SUMMARY_TYPE.toString(),\n    type: TABLE_TOTAL_SUMMARY_TYPE\n  }], footerRows);\n};\nvar tableRowsWithSummaries = function tableRowsWithSummaries(tableRows, groupSummaryItems, treeSummaryItems, getRowLevelKey, isGroupRow, getRowId) {\n  var hasGroupFooterSummary = groupFooterSummaryExists(groupSummaryItems);\n  if (!getRowLevelKey || !(hasGroupFooterSummary || treeSummaryItems.length)) return tableRows;\n  var result = [];\n  var closeLevel = function closeLevel(level) {\n    if (!level.opened) return;\n    if (hasGroupFooterSummary && isGroupRow && isGroupRow(level.row)) {\n      var compoundKey = level.row.compoundKey;\n      result.push({\n        key: TABLE_GROUP_SUMMARY_TYPE.toString() + \"_\" + compoundKey,\n        type: TABLE_GROUP_SUMMARY_TYPE,\n        row: level.row\n      });\n    } else if (treeSummaryItems.length) {\n      var rowId = getRowId(level.row);\n      result.push({\n        key: TABLE_TREE_SUMMARY_TYPE.toString() + \"_\" + rowId,\n        type: TABLE_TREE_SUMMARY_TYPE,\n        row: level.row\n      });\n    }\n  };\n  var levels = [];\n  tableRows.forEach(function (tableRow) {\n    var row = tableRow.row;\n    var levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      var levelIndex = levels.findIndex(function (level) {\n        return level.levelKey === levelKey;\n      });\n      if (levelIndex > -1) {\n        levels.slice(levelIndex).reverse().forEach(closeLevel);\n        levels = levels.slice(0, levelIndex);\n      }\n      if (!isGroupRow || !isGroupRow(row)) {\n        levels = levels.map(function (level) {\n          return _assign(_assign({}, level), {\n            opened: true\n          });\n        });\n      }\n      levels.push({\n        levelKey: levelKey,\n        row: row,\n        opened: false\n      });\n    } else {\n      levels = levels.map(function (level) {\n        return _assign(_assign({}, level), {\n          opened: true\n        });\n      });\n    }\n    result.push(tableRow);\n  });\n  levels.slice().reverse().forEach(closeLevel);\n  return result;\n};\nvar prepareGroupSummaryItems = function prepareGroupSummaryItems(items) {\n  return !!items ? items.map(function (item) {\n    return _assign(_assign({}, item), {\n      showInGroupFooter: item.showInGroupFooter === undefined && !item.alignByColumn ? true : item.showInGroupFooter\n    });\n  }) : items;\n};\nvar HEADING_TYPE = TABLE_HEADING_TYPE.toString();\nvar FILTER_TYPE = TABLE_FILTER_TYPE.toString();\nvar DATA_TYPE = TABLE_DATA_TYPE.toString();\nvar BAND_TYPE = TABLE_BAND_TYPE.toString();\nvar TOTAL_SUMMARY_TYPE = TABLE_TOTAL_SUMMARY_TYPE.toString();\nvar STUB_TYPE = TABLE_STUB_TYPE.toString();\nvar GROUP_TYPE = TABLE_GROUP_TYPE.toString();\nvar tableParts = [HEADING_TYPE, FILTER_TYPE, DATA_TYPE, TOTAL_SUMMARY_TYPE];\nvar getIndex = function getIndex(arr, key) {\n  return arr.findIndex(function (el) {\n    return el.key === key;\n  });\n};\nvar isSpanInput = function isSpanInput(innerElements) {\n  return innerElements[0].tagName === 'SPAN' || innerElements[0].tagName === 'INPUT' && innerElements[0].type === 'text';\n};\nvar isDefined = function isDefined(value) {\n  return value !== undefined;\n};\nvar hasInsideElements = function hasInsideElements(innerElements, focusedElementIndex) {\n  if (innerElements.length && focusedElementIndex === undefined || isDefined(focusedElementIndex) && focusedElementIndex < innerElements.length - 1) {\n    if (innerElements.length === 1 && focusedElementIndex === undefined) {\n      return !isSpanInput(innerElements);\n    }\n    return true;\n  }\n  return false;\n};\nvar getIndexInnerElement = function getIndexInnerElement(elements, rowKey, columnKey, direction) {\n  var innerElements = getInnerElements(elements, rowKey, columnKey);\n  var index = direction > 0 ? 0 : innerElements.length - 1;\n  return cellEmptyOrHasSpanAndInput(elements, rowKey, columnKey) ? undefined : index;\n};\nvar getNextPrevClosestColumnKey = function getNextPrevClosestColumnKey(tableColumns, columnIndex, rowKey, elements, direction) {\n  var columnKey;\n  if (direction > 0) {\n    for (var i = columnIndex; i <= tableColumns.length - 1; i += 1) {\n      if (elements[rowKey][tableColumns[i].key]) {\n        columnKey = tableColumns[i].key;\n        break;\n      }\n    }\n  } else {\n    for (var i = columnIndex; i >= 0; i -= 1) {\n      if (elements[rowKey][tableColumns[i].key]) {\n        columnKey = tableColumns[i].key;\n        break;\n      }\n    }\n  }\n  return columnKey;\n};\nvar shouldBeScrolled = function shouldBeScrolled(elements, key1, key2, scrollToColumn) {\n  if (scrollToColumn && !elements[key1][key2]) {\n    return Object.keys(elements[key1]).some(function (column) {\n      return column.includes(STUB_TYPE);\n    });\n  }\n  return false;\n};\nvar convertPart = function convertPart(part, elements, tableBodyRows) {\n  if (part === DATA_TYPE && elements[tableBodyRows[0].key]) {\n    return DATA_TYPE;\n  }\n  if (elements[part]) {\n    return part;\n  }\n  return;\n};\nvar getLastPart = function getLastPart(elements, tableBodyRows, partIndex) {\n  var index = partIndex || tableParts.length;\n  var part;\n  do {\n    index = index - 1;\n    part = convertPart(tableParts[index], elements, tableBodyRows);\n  } while (index > 0 && !part);\n  return part;\n};\nvar getRowKey = function getRowKey(part, key, headerRowKey) {\n  if (headerRowKey && part === HEADING_TYPE) {\n    return headerRowKey;\n  }\n  return part === DATA_TYPE ? key : part;\n};\nvar getPrevPart = function getPrevPart(focusedElement, elements, tableBodyRows) {\n  var index = tableParts.findIndex(function (p) {\n    return p === focusedElement.part;\n  });\n  if (index === 0) {\n    return;\n  }\n  return getLastPart(elements, tableBodyRows, index);\n};\nvar getNextPart = function getNextPart(focusedElement, elements, tableBodyRows) {\n  var index = tableParts.findIndex(function (p) {\n    return p === focusedElement.part;\n  });\n  if (index === tableParts.length - 1) {\n    return;\n  }\n  var part = tableParts.find(function (p, i) {\n    if (i > index) {\n      return convertPart(p, elements, tableBodyRows);\n    }\n    return false;\n  });\n  return part;\n};\nvar getCellNextPart = function getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn) {\n  var part = getNextPart(focusedElement, elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n  var rowKey = getRowKey(part, tableBodyRows[0].key);\n  var columnKey = tableColumns[0].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey: rowKey,\n        columnKey: columnKey,\n        part: part\n      },\n      scrolling: 'left'\n    };\n  }\n  return {\n    element: {\n      rowKey: rowKey,\n      columnKey: columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n      part: part\n    }\n  };\n};\nvar getCellPrevPart = function getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn) {\n  var part = getPrevPart(focusedElement, elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n  var rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);\n  var columnKeyIndex = tableColumns.length - 1;\n  var columnKey = tableColumns[columnKeyIndex].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey: rowKey,\n        columnKey: columnKey,\n        part: part\n      },\n      scrolling: 'right'\n    };\n  }\n  var nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnKeyIndex, rowKey, elements, -1);\n  return {\n    element: nextColumnKey ? {\n      rowKey: rowKey,\n      columnKey: nextColumnKey,\n      index: getIndexInnerElement(elements, rowKey, nextColumnKey, -1),\n      part: part\n    } : undefined\n  };\n};\nvar getPrevCellFromBody = function getPrevCellFromBody(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn) {\n  var prevRowKey = focusedElement.rowKey;\n  var prevColumnKey;\n  if (columnIndex === 0 && rowIndex === 0) {\n    return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  if (columnIndex === 0) {\n    prevRowKey = tableBodyRows[rowIndex - 1].key;\n    if (prevRowKey.includes(GROUP_TYPE)) {\n      prevColumnKey = getNextPrevClosestColumnKey(tableColumns, tableColumns.length - 1, prevRowKey, elements, -1);\n    } else {\n      prevColumnKey = tableColumns[tableColumns.length - 1].key;\n    }\n    if (prevColumnKey && shouldBeScrolled(elements, prevRowKey, prevColumnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey: prevRowKey,\n          columnKey: prevColumnKey,\n          part: focusedElement.part\n        },\n        scrolling: 'right'\n      };\n    }\n  } else {\n    prevColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex - 1, prevRowKey, elements, -1);\n  }\n  return {\n    element: prevColumnKey ? {\n      rowKey: prevRowKey,\n      columnKey: prevColumnKey,\n      index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1),\n      part: focusedElement.part\n    } : undefined\n  };\n};\nvar getPrevCellFromHeading = function getPrevCellFromHeading(tableHeaderRows, tableColumns, columnIndex, _a, elements) {\n  var rowKey = _a.rowKey,\n    part = _a.part;\n  var prevColumnKey;\n  var prevRowKey;\n  var headIndex = getIndex(tableHeaderRows, rowKey);\n  prevColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex - 1, rowKey, elements, -1);\n  if (prevColumnKey) {\n    return {\n      element: {\n        columnKey: prevColumnKey,\n        rowKey: rowKey,\n        part: part,\n        index: getIndexInnerElement(elements, rowKey, prevColumnKey, -1)\n      }\n    };\n  }\n  if (headIndex > 0) {\n    var abort = false;\n    for (var i = headIndex - 1; i >= 0 && !abort; i -= 1) {\n      for (var j = tableColumns.length - 1; j >= 0; j -= 1) {\n        if (elements[tableHeaderRows[i].key][tableColumns[j].key]) {\n          prevColumnKey = tableColumns[j].key;\n          prevRowKey = tableHeaderRows[i].key;\n          abort = true;\n          break;\n        }\n      }\n    }\n    if (prevColumnKey && prevRowKey) {\n      return {\n        element: {\n          columnKey: prevColumnKey,\n          rowKey: prevRowKey,\n          part: part,\n          index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1)\n        }\n      };\n    }\n  }\n  return {};\n};\nvar getPrevElement = function getPrevElement(focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn) {\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (isDefined(focusedElement.index) && focusedElement.index > 0) {\n    return {\n      element: _assign(_assign({}, focusedElement), {\n        index: focusedElement.index - 1\n      })\n    };\n  }\n  if (focusedElement.part === DATA_TYPE) {\n    return getPrevCellFromBody(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn);\n  }\n  if (focusedElement.part === HEADING_TYPE) {\n    var cell = getPrevCellFromHeading(tableHeaderRows, tableColumns, columnIndex, focusedElement, elements);\n    if (cell.element) {\n      return {\n        element: _assign(_assign({}, cell.element), {\n          index: getIndexInnerElement(elements, cell.element.rowKey, cell.element.columnKey, -1)\n        })\n      };\n    }\n    return {\n      element: cell.element\n    };\n  }\n  if (columnIndex === 0) {\n    return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  var rowKey = focusedElement.part;\n  var columnKey = tableColumns[columnIndex - 1].key;\n  return {\n    element: {\n      rowKey: rowKey,\n      columnKey: columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, -1),\n      part: focusedElement.part\n    }\n  };\n};\nvar getNextCellFromBody = function getNextCellFromBody(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn) {\n  var nextRowKey = focusedElement.rowKey;\n  var nextColumnKey;\n  if (columnIndex === tableColumns.length - 1 && rowIndex === tableBodyRows.length - 1) {\n    return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  if (columnIndex === tableColumns.length - 1) {\n    nextRowKey = tableBodyRows[rowIndex + 1].key;\n    nextColumnKey = tableColumns[0].key;\n    if (shouldBeScrolled(elements, nextRowKey, nextColumnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey: nextRowKey,\n          columnKey: nextColumnKey,\n          part: focusedElement.part\n        },\n        scrolling: 'left'\n      };\n    }\n  } else {\n    nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + 1, nextRowKey, elements, 1);\n    if (!nextColumnKey) {\n      if (rowIndex === tableBodyRows.length - 1) {\n        return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n      }\n      nextRowKey = tableBodyRows[rowIndex + 1].key;\n      nextColumnKey = tableColumns[0].key;\n    }\n  }\n  return {\n    element: {\n      rowKey: nextRowKey,\n      columnKey: nextColumnKey,\n      index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1),\n      part: focusedElement.part\n    }\n  };\n};\nvar getNextCellFromHeading = function getNextCellFromHeading(tableHeaderRows, tableBodyRows, tableColumns, columnIndex, focusedElement, elements, scrollToColumn) {\n  var headIndex = getIndex(tableHeaderRows, focusedElement.rowKey);\n  var nextRowKey;\n  var nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + 1, focusedElement.rowKey, elements, 1);\n  if (nextColumnKey) {\n    return {\n      element: {\n        columnKey: nextColumnKey,\n        rowKey: focusedElement.rowKey,\n        part: focusedElement.part,\n        index: getIndexInnerElement(elements, focusedElement.rowKey, nextColumnKey, 1)\n      }\n    };\n  }\n  if (headIndex !== tableHeaderRows.length - 1) {\n    var abort = false;\n    for (var i = headIndex + 1; i <= tableHeaderRows.length - 1 && !abort; i += 1) {\n      for (var j = 0; j <= tableColumns.length - 1; j += 1) {\n        if (elements[tableHeaderRows[i].key][tableColumns[j].key]) {\n          nextColumnKey = tableColumns[j].key;\n          nextRowKey = tableHeaderRows[i].key;\n          abort = true;\n          break;\n        }\n      }\n    }\n    if (nextColumnKey && nextRowKey) {\n      return {\n        element: {\n          columnKey: nextColumnKey,\n          rowKey: nextRowKey,\n          part: focusedElement.part,\n          index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1)\n        }\n      };\n    }\n  }\n  return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n};\nvar getNextElement = function getNextElement(focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn) {\n  var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (hasInsideElements(innerElements, focusedElement.index)) {\n    return {\n      element: _assign(_assign({}, focusedElement), {\n        index: !isDefined(focusedElement.index) ? 0 : focusedElement.index + 1\n      })\n    };\n  }\n  if (focusedElement.part === DATA_TYPE) {\n    return getNextCellFromBody(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn);\n  }\n  if (focusedElement.part === HEADING_TYPE) {\n    return getNextCellFromHeading(tableHeaderRows, tableBodyRows, tableColumns, columnIndex, focusedElement, elements, scrollToColumn);\n  }\n  if (columnIndex === tableColumns.length - 1) {\n    return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  var rowKey = focusedElement.rowKey;\n  var columnKey = tableColumns[columnIndex + 1].key;\n  return {\n    element: {\n      rowKey: rowKey,\n      columnKey: columnKey,\n      part: focusedElement.part,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1)\n    }\n  };\n};\nvar hasCellInput = function hasCellInput(innerElements) {\n  return innerElements.length ? innerElements[0].tagName === 'INPUT' : false;\n};\nvar cellEmptyOrHasSpanAndInput = function cellEmptyOrHasSpanAndInput(elements, key1, key2) {\n  var innerElements = getInnerElements(elements, key1, key2);\n  if (innerElements.length) {\n    return isSpanInput(innerElements);\n  }\n  return true;\n};\nvar getCellRightLeft = function getCellRightLeft(direction, focusedElement, tableColumns, elements) {\n  if (focusedElement.part !== DATA_TYPE) {\n    return;\n  }\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  if (tableColumns[columnIndex + direction]) {\n    var columnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + direction, focusedElement.rowKey, elements, direction);\n    if (columnKey) {\n      return {\n        rowKey: focusedElement.rowKey,\n        columnKey: columnKey,\n        part: focusedElement.part\n      };\n    }\n  }\n  return;\n};\nvar getFirstCell = function getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows, scrollToColumn, withInnerElements) {\n  var part = tableParts.find(function (p) {\n    return convertPart(p, elements, tableBodyRows);\n  });\n  if (!part) {\n    return {};\n  }\n  var rowKey = getRowKey(part, tableBodyRows[0].key, tableHeaderRows[0].key);\n  var columnKey = tableColumns[0].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey: rowKey,\n        columnKey: columnKey,\n        part: part\n      },\n      scrolling: 'left'\n    };\n  }\n  return {\n    element: {\n      rowKey: rowKey,\n      columnKey: columnKey,\n      index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : undefined,\n      part: part\n    }\n  };\n};\nvar getLastCell = function getLastCell(elements, tableBodyRows, tableColumns) {\n  var part = getLastPart(elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n  var rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);\n  var columnKey = getNextPrevClosestColumnKey(tableColumns, tableColumns.length - 1, rowKey, elements, -1);\n  return {\n    element: columnKey ? {\n      rowKey: rowKey,\n      columnKey: columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n      part: part\n    } : undefined\n  };\n};\nvar getToolbarPagingElements = function getToolbarPagingElements(elements) {\n  return {\n    toolbarElements: elements.toolbar && getInnerElements(elements, 'toolbar', 'none'),\n    pagingElements: elements.paging && getInnerElements(elements, 'paging', 'none').filter(function (el) {\n      return !el.hasAttribute('disabled') && el.getAttribute('tabindex') !== '-1';\n    })\n  };\n};\nvar getFirstCellInLastPart = function getFirstCellInLastPart(elements, tableBodyRows, tableColumns, scrollToColumn, withInnerElements) {\n  var lastPart = getLastPart(elements, tableBodyRows);\n  if (lastPart) {\n    var columnKey = tableColumns[0].key;\n    var rowKey = getRowKey(lastPart, tableBodyRows[0].key);\n    if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey: rowKey,\n          columnKey: columnKey,\n          part: lastPart\n        },\n        scrolling: 'left'\n      };\n    }\n    return {\n      element: {\n        columnKey: columnKey,\n        rowKey: rowKey,\n        index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : undefined,\n        part: lastPart\n      }\n    };\n  }\n  return {};\n};\nvar applyEnterAction = function applyEnterAction(elements, _a, tableColumns, tableBodyRows, focusedElement) {\n  var commitChangedRows = _a.commitChangedRows,\n    stopEditCells = _a.stopEditCells,\n    startEditCells = _a.startEditCells;\n  if (!focusedElement) {\n    return;\n  }\n  var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (focusedElement.part === DATA_TYPE && commitChangedRows) {\n    if (focusedElement.index === 0) {\n      commitChangedRows({\n        rowIds: [tableBodyRows[rowIndex].rowId]\n      });\n      stopEditCells({\n        editingCells: [{\n          rowId: tableBodyRows[rowIndex].rowId,\n          columnName: tableColumns[columnIndex].column.name\n        }]\n      });\n      return {\n        part: focusedElement.part,\n        columnKey: focusedElement.columnKey,\n        rowKey: focusedElement.rowKey\n      };\n    }\n    startEditCells({\n      editingCells: [{\n        rowId: tableBodyRows[rowIndex].rowId,\n        columnName: tableColumns[columnIndex].column.name\n      }]\n    });\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n      index: 0\n    };\n  }\n  if (!isDefined(focusedElement.index) && innerElements.length && isSpanInput(innerElements)) {\n    if (innerElements[0].tagName === 'SPAN') {\n      innerElements[0].click();\n    }\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n      index: 0\n    };\n  }\n  if (focusedElement.index === 0 && hasCellInput(innerElements)) {\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey\n    };\n  }\n  return;\n};\nvar applyEscapeAction = function applyEscapeAction(elements, _a, tableColumns, tableBodyRows, focusedElement) {\n  var cancelChangedRows = _a.cancelChangedRows,\n    stopEditCells = _a.stopEditCells;\n  if (!focusedElement) {\n    return;\n  }\n  var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (focusedElement.index === 0 && hasCellInput(innerElements)) {\n    if (focusedElement.part === DATA_TYPE && cancelChangedRows) {\n      cancelChangedRows({\n        rowIds: [tableBodyRows[rowIndex].rowId]\n      });\n      stopEditCells({\n        editingCells: [{\n          rowId: tableBodyRows[rowIndex].rowId,\n          columnName: tableColumns[columnIndex].column.name\n        }]\n      });\n    }\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey\n    };\n  }\n  return;\n};\nvar actionOnCheckbox = function actionOnCheckbox(elements, focusedElement) {\n  if (!focusedElement || isDefined(focusedElement.index)) {\n    return;\n  }\n  var el = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey, 'input').filter(function (element) {\n    return element.type === 'checkbox';\n  });\n  if (el[0]) {\n    el[0].click();\n  }\n};\nvar actionOnTreeMode = function actionOnTreeMode(elements, expandedRowIds, direction, focusedElement) {\n  if (!focusedElement || isDefined(focusedElement.index) || !expandedRowIds) {\n    return;\n  }\n  var el = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey, 'button, i');\n  var index = getIndexFromKey(focusedElement.rowKey);\n  if (direction > 0 && expandedRowIds.indexOf(index) === -1 || direction < 0 && expandedRowIds.indexOf(index) > -1) {\n    if (el[0]) {\n      el[0].click();\n    }\n  }\n};\nvar getInnerElements = function getInnerElements(elements, key1, key2, query) {\n  if (query === void 0) {\n    query = '[tabIndex], input, button, a';\n  }\n  return Array.from(elements[key1][key2][0].current.querySelectorAll(query)).filter(function (el) {\n    return !el.hasAttribute('disabled') && el.getAttribute('tabindex') !== '-1';\n  });\n};\nvar getCellTopBottom = function getCellTopBottom(direction, focusedElement, tableBodyRows, tableColumns, elements) {\n  if (focusedElement.part !== DATA_TYPE) {\n    return;\n  }\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (tableBodyRows[rowIndex + direction]) {\n    var columnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex, tableBodyRows[rowIndex + direction].key, elements, -1);\n    if (columnKey) {\n      return {\n        rowKey: tableBodyRows[rowIndex + direction].key,\n        columnKey: columnKey,\n        part: focusedElement.part\n      };\n    }\n  }\n  return;\n};\nvar isCtrlMetaKey = function isCtrlMetaKey(event) {\n  return event.ctrlKey || event.metaKey;\n};\nvar getIndexFromKey = function getIndexFromKey(key) {\n  var array = key.split('_');\n  return Number(array[array.length - 1]);\n};\nvar getCellNextPrevPart = function getCellNextPrevPart(focusedElement, elements, tableBodyRows, tableColumns, direction, scrollToColumn) {\n  var part = direction > 0 ? getNextPart(focusedElement, elements, tableBodyRows) : getPrevPart(focusedElement, elements, tableBodyRows);\n  if (part) {\n    var rowKey = getRowKey(part, tableBodyRows[0].key);\n    var columnKey = tableColumns[0].key;\n    return {\n      element: {\n        part: part,\n        rowKey: rowKey,\n        columnKey: columnKey\n      },\n      scrolling: shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn) ? 'left' : undefined\n    };\n  }\n  return {};\n};\nvar applyFocusOnToolbarPaging = function applyFocusOnToolbarPaging(elements, direction) {\n  if (direction > 0 && elements.paging) {\n    getInnerElements(elements, 'paging', 'none')[0].focus();\n  }\n  if (direction < 0 && elements.toolbar) {\n    getInnerElements(elements, 'toolbar', 'none')[0].focus();\n  }\n};\nvar getClosestCellByRow = function getClosestCellByRow(tableBodyRows, focusedElement, elements) {\n  var currentIndex = getIndexFromKey(focusedElement.rowKey);\n  var bodyRow = tableBodyRows.find(function (row) {\n    return getIndexFromKey(row.key) > currentIndex;\n  });\n  var rowKey = bodyRow ? bodyRow.key : tableBodyRows[tableBodyRows.length - 1].key;\n  var columnKey = focusedElement.columnKey;\n  return {\n    rowKey: rowKey,\n    columnKey: columnKey,\n    part: focusedElement.part,\n    index: getIndexInnerElement(elements, rowKey, columnKey, 1)\n  };\n};\nvar getNextFocusedCell = function getNextFocusedCell(tableColumns, tableBodyRows, tableHeaderRows, expandedRowIds, elements, event, inlineEditing, focusedElement, scrollToColumn) {\n  if (!focusedElement) {\n    var _a = getToolbarPagingElements(elements),\n      toolbarElements = _a.toolbarElements,\n      pagingElements = _a.pagingElements;\n    var hasFocus = function hasFocus(innerElements) {\n      return innerElements.some(function (el) {\n        return event.target === el;\n      });\n    };\n    if (isCtrlMetaKey(event)) {\n      if (event.key === 'ArrowDown' && (toolbarElements && hasFocus(toolbarElements) || !toolbarElements)) {\n        return getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows, scrollToColumn);\n      }\n      if (event.key === 'ArrowUp' && (pagingElements && hasFocus(pagingElements) || !pagingElements)) {\n        return getFirstCellInLastPart(elements, tableBodyRows, tableColumns, scrollToColumn);\n      }\n    } else if (event.key === 'Tab') {\n      if (toolbarElements && event.target === toolbarElements[toolbarElements.length - 1] && !event.shiftKey) {\n        return getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows, scrollToColumn, true);\n      }\n      if (pagingElements && event.target === pagingElements[0] && event.shiftKey) {\n        if (scrollToColumn) {\n          return getFirstCellInLastPart(elements, tableBodyRows, tableColumns, scrollToColumn, true);\n        }\n        return getLastCell(elements, tableBodyRows, tableColumns);\n      }\n      var element = (!event.shiftKey ? getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows, undefined, true) : getLastCell(elements, tableBodyRows, tableColumns)).element;\n      if (element && event.target === elements[element.rowKey][element.columnKey][0].current) {\n        return {\n          element: element\n        };\n      }\n    }\n    return {};\n  }\n  var cell;\n  switch (event.key) {\n    case 'Enter':\n      cell = {\n        element: applyEnterAction(elements, inlineEditing, tableColumns, tableBodyRows, focusedElement)\n      };\n      break;\n    case 'Escape':\n      cell = {\n        element: applyEscapeAction(elements, inlineEditing, tableColumns, tableBodyRows, focusedElement)\n      };\n      break;\n    case ' ':\n      actionOnCheckbox(elements, focusedElement);\n      break;\n    case 'Tab':\n      if (event.shiftKey) {\n        cell = getPrevElement(focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn);\n      } else {\n        cell = getNextElement(focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn);\n      }\n      break;\n    case 'ArrowUp':\n      if (isCtrlMetaKey(event)) {\n        cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows, tableColumns, -1, scrollToColumn);\n        if (!cell.element) {\n          applyFocusOnToolbarPaging(elements, -1);\n        }\n      } else {\n        cell = {\n          element: getCellTopBottom(-1, focusedElement, tableBodyRows, tableColumns, elements)\n        };\n      }\n      break;\n    case 'ArrowDown':\n      if (isCtrlMetaKey(event)) {\n        cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows, tableColumns, 1, scrollToColumn);\n        if (!cell.element) {\n          applyFocusOnToolbarPaging(elements, 1);\n        }\n      } else {\n        cell = {\n          element: getCellTopBottom(1, focusedElement, tableBodyRows, tableColumns, elements)\n        };\n      }\n      break;\n    case 'ArrowLeft':\n      if (isCtrlMetaKey(event)) {\n        actionOnTreeMode(elements, expandedRowIds, -1, focusedElement);\n      } else {\n        cell = {\n          element: getCellRightLeft(-1, focusedElement, tableColumns, elements)\n        };\n      }\n      break;\n    case 'ArrowRight':\n      if (isCtrlMetaKey(event)) {\n        actionOnTreeMode(elements, expandedRowIds, 1, focusedElement);\n      } else {\n        cell = {\n          element: getCellRightLeft(1, focusedElement, tableColumns, elements)\n        };\n      }\n      break;\n  }\n  return cell || {};\n};\nvar getPart = function getPart(key) {\n  if (tableParts.find(function (t) {\n    return t === key;\n  })) {\n    return key;\n  }\n  if (key.includes(BAND_TYPE)) {\n    return HEADING_TYPE;\n  }\n  return DATA_TYPE;\n};\nvar getIndexToFocus = function getIndexToFocus(key1, key2, elements, event, _a, part) {\n  var startEditCells = _a.startEditCells;\n  if (startEditCells && part === DATA_TYPE) {\n    return 0;\n  }\n  var innerElements = getInnerElements(elements, key1, key2);\n  var index = innerElements.findIndex(function (el) {\n    return event.target === el;\n  });\n  return index !== -1 ? index : undefined;\n};\nvar filterHeaderRows = function filterHeaderRows(tableHeaderRows) {\n  return tableHeaderRows.filter(function (row) {\n    return row.key.includes(BAND_TYPE) || row.key.includes(HEADING_TYPE);\n  });\n};\nvar isRowFocused = function isRowFocused(tableRow, focusedRowKey) {\n  if (focusedRowKey) {\n    return tableRow.key === focusedRowKey;\n  }\n  return false;\n};\nvar isCellExist = function isCellExist(elements, focusedElement) {\n  return !!(elements[focusedElement.rowKey] && elements[focusedElement.rowKey][focusedElement.columnKey]);\n};\nvar isTabArrowUpDown = function isTabArrowUpDown(event) {\n  return event.key === 'Tab' || isCtrlMetaKey(event) && (event.key === 'ArrowDown' || event.key === 'ArrowUp');\n};\nvar focus = function focus(elements, focusedElement, prevFocusedElement, onFocusedCellChange) {\n  if (!focusedElement || !elements[focusedElement.rowKey] || !elements[focusedElement.rowKey][focusedElement.columnKey]) {\n    return;\n  }\n  var el = focusedElement.index === undefined ? elements[focusedElement.rowKey][focusedElement.columnKey][0] : getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey)[focusedElement.index];\n  if (el) {\n    el.focus ? el.focus() : el.current.focus();\n    if (onFocusedCellChange && ((prevFocusedElement === null || prevFocusedElement === void 0 ? void 0 : prevFocusedElement.rowKey) !== focusedElement.rowKey || (prevFocusedElement === null || prevFocusedElement === void 0 ? void 0 : prevFocusedElement.columnKey) !== focusedElement.columnKey)) {\n      onFocusedCellChange({\n        rowKey: focusedElement.rowKey,\n        columnKey: focusedElement.columnKey\n      });\n    }\n  }\n};\nvar isCellFocused = function isCellFocused(row, column, focusedElement) {\n  if (!focusedElement || isDefined(focusedElement.index)) {\n    return false;\n  }\n  return focusedElement.rowKey === row.key && focusedElement.columnKey === column.key;\n};\nvar getFocusing = function getFocusing(tableBodyRows, focusedElement) {\n  if (!focusedElement) {\n    return [];\n  }\n  var focusedRow = tableBodyRows.find(function (row) {\n    return row.key === focusedElement.rowKey;\n  });\n  return focusedRow ? [focusedRow.rowId] : [];\n};\nvar getTargetColumnGeometries = function getTargetColumnGeometries(columnGeometries, sourceIndex) {\n  var sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;\n  var getWidthDifference = function getWidthDifference(index) {\n    return columnGeometries[index].right - columnGeometries[index].left - sourceWidth;\n  };\n  return columnGeometries.map(function (_a, targetIndex) {\n    var top = _a.top,\n      right = _a.right,\n      bottom = _a.bottom,\n      left = _a.left;\n    var leftBorder = left;\n    if (targetIndex > 0 && targetIndex <= sourceIndex) {\n      leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));\n    }\n    if (targetIndex > sourceIndex) {\n      leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));\n    }\n    var rightBorder = right;\n    if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {\n      rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));\n    }\n    if (targetIndex < sourceIndex) {\n      rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));\n    }\n    return {\n      top: top,\n      bottom: bottom,\n      right: rightBorder,\n      left: leftBorder\n    };\n  });\n};\nvar getCellGeometries = function getCellGeometries(node) {\n  var _a, _b;\n  var _c = node.getBoundingClientRect(),\n    left = _c.left,\n    right = _c.right,\n    width = _c.width;\n  var styleLeft = parseInt((_a = node.style.left) === null || _a === void 0 ? void 0 : _a.toString().replace('px', ''), 10);\n  var styleRight = parseInt((_b = node.style.right) === null || _b === void 0 ? void 0 : _b.toString().replace('px', ''), 10);\n  if (!isNaN(styleLeft)) {\n    var calculatedLeft = Math.max(styleLeft, left);\n    return {\n      left: calculatedLeft,\n      right: calculatedLeft + width,\n      isFixed: true\n    };\n  }\n  if (!isNaN(styleRight)) {\n    // NOTE: get tableContainer (parent of first DIV element) to calculate 'right' value\n    var tableContainer = node;\n    while (tableContainer && tableContainer.nodeName !== 'DIV') {\n      tableContainer = tableContainer.parentNode;\n    }\n    tableContainer = tableContainer === null || tableContainer === void 0 ? void 0 : tableContainer.parentNode;\n    if (tableContainer) {\n      var tableWidth = tableContainer.getBoundingClientRect().width;\n      var calculatedRight = Math.min(tableWidth - styleRight, right);\n      return {\n        left: calculatedRight - width,\n        right: calculatedRight,\n        isFixed: true\n      };\n    }\n  }\n  return {\n    left: left,\n    right: right\n  };\n};\nvar getTableColumnGeometries = function getTableColumnGeometries(columns, tableWidth) {\n  var columnWidths = columns.map(function (column) {\n    return column.width;\n  });\n  var freeSpace = tableWidth;\n  var restrictedSpace = columnWidths.reduce(function (accum, width) {\n    return accum + (typeof width === 'number' ? width : 0);\n  }, 0);\n  var freeSpacePortions = columnWidths.reduce(function (accum, width) {\n    return accum + (typeof width !== 'number' ? 1 : 0);\n  }, 0);\n  var freeSpacePortion = (freeSpace - restrictedSpace) / freeSpacePortions;\n  var lastRightPosition = 0;\n  return columnWidths.map(function (width) {\n    return typeof width !== 'number' ? freeSpacePortion : width;\n  }).map(function (width) {\n    lastRightPosition += width;\n    return {\n      left: lastRightPosition - width,\n      right: lastRightPosition\n    };\n  });\n};\nvar getTableTargetColumnIndex = function getTableTargetColumnIndex(columnGeometries, offset) {\n  var indexes = columnGeometries.reduce(function (acc, _a, index) {\n    var left = _a.left,\n      right = _a.right;\n    if (offset >= left && offset < right) {\n      acc.push(index);\n    }\n    return acc;\n  }, []);\n  if (columnGeometries.some(function (_a) {\n    var left = _a.left,\n      right = _a.right;\n    return left <= 0 && right <= 0;\n  })) {\n    if (indexes.some(function (index) {\n      return columnGeometries[index].isFixed || columnGeometries[index].left <= 0 && columnGeometries[index].right <= 0;\n    })) {\n      return -1;\n    }\n  }\n  if (indexes.length === 2) {\n    return indexes.find(function (index) {\n      return columnGeometries[index].isFixed;\n    });\n  }\n  if (indexes.length === 1) {\n    return indexes[0];\n  }\n  return -1;\n};\nvar ANIMATION_DURATION = 200;\nvar getAnimationProgress = function getAnimationProgress(animation) {\n  return (new Date().getTime() - animation.startTime) / ANIMATION_DURATION;\n};\nvar getAnimations = function getAnimations(prevColumns, nextColumns, tableWidth, prevAnimations) {\n  var resizing = prevColumns.map(function (column) {\n    return column.key;\n  }).join() === nextColumns.map(function (column) {\n    return column.key;\n  }).join();\n  var prevColumnGeometries = new Map(getTableColumnGeometries(prevColumns, tableWidth).map(function (geometry, index) {\n    return [prevColumns[index].key, geometry];\n  }).map(function (_a) {\n    var _b = __read(_a, 2),\n      key = _b[0],\n      geometry = _b[1];\n    var animation = prevAnimations.get(key);\n    if (!animation) return [key, geometry];\n    var progress = easeOutCubic(getAnimationProgress(animation));\n    var _c = animation.left,\n      to = _c.to,\n      from = _c.from;\n    var left = (to - from) * progress + from;\n    return [key, {\n      left: left,\n      right: geometry.right - (geometry.left - left)\n    }];\n    // tslint:disable-next-line:array-type\n  }));\n\n  var nextColumnGeometries = new Map(getTableColumnGeometries(nextColumns, tableWidth)\n  // tslint:disable-next-line:array-type\n  .map(function (geometry, index) {\n    return [nextColumns[index].key, geometry];\n  }));\n  return new Map(__spread(nextColumnGeometries.keys()).map(function (key) {\n    var prev = prevColumnGeometries.get(key);\n    var next = nextColumnGeometries.get(key);\n    var result = {\n      startTime: new Date().getTime(),\n      style: {}\n    };\n    var takePrevColumnIntoAccount = !!prevAnimations.get(key) || prev && !resizing;\n    if (Math.abs((takePrevColumnIntoAccount ? prev.left : next.left) - next.left) > 1) {\n      result.left = {\n        from: prev.left,\n        to: next.left\n      };\n    }\n    return [key, result];\n  }).filter(function (animation) {\n    return animation[1].left;\n  }));\n};\nvar filterActiveAnimations = function filterActiveAnimations(animations) {\n  return new Map(__spread(animations.entries()).filter(function (_a) {\n    var _b = __read(_a, 2),\n      animation = _b[1];\n    return getAnimationProgress(animation) < 1;\n  }));\n};\nvar evalAnimations = function evalAnimations(animations) {\n  return new Map(__spread(animations.entries()).map(function (_a) {\n    var _b = __read(_a, 2),\n      key = _b[0],\n      animation = _b[1];\n    var progress = easeOutCubic(getAnimationProgress(animation));\n    var result = _assign({}, animation.style);\n    if (animation.left) {\n      var offset = (animation.left.to - animation.left.from) * (progress - 1);\n      result.transform = \"translateX(\" + offset + \"px)\";\n    }\n    return [key, result];\n  }));\n};\nvar isOnTheSameLine = function isOnTheSameLine(geometry, y) {\n  return y >= geometry.top && y <= geometry.bottom;\n};\nvar rectToObject = function rectToObject(_a) {\n  var top = _a.top,\n    right = _a.right,\n    bottom = _a.bottom,\n    left = _a.left;\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left\n  };\n};\nvar collapseGapsBetweenItems = function collapseGapsBetweenItems(geometries) {\n  return geometries.map(function (geometry, index) {\n    if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {\n      return _assign(_assign({}, geometry), {\n        right: geometries[index + 1].left\n      });\n    }\n    return geometry;\n  });\n};\nvar getGroupCellTargetIndex = function getGroupCellTargetIndex(geometries, sourceIndex, _a) {\n  var x = _a.x,\n    y = _a.y;\n  if (geometries.length === 0) return 0;\n  var targetGeometries = sourceIndex !== -1 ? getTargetColumnGeometries(geometries, sourceIndex) : geometries.map(rectToObject);\n  var targetIndex = collapseGapsBetweenItems(targetGeometries).findIndex(function (geometry, index) {\n    var inVerticalBounds = isOnTheSameLine(geometry, y);\n    var inHorizontalBounds = x >= geometry.left && x <= geometry.right;\n    var shouldGoFirst = index === 0 && x < geometry.left;\n    var shouldGoOnLineBreak = !inVerticalBounds && !!geometries[index - 1] && isOnTheSameLine(geometries[index - 1], y);\n    return inVerticalBounds && inHorizontalBounds || shouldGoFirst || shouldGoOnLineBreak;\n  });\n  return targetIndex === -1 ? geometries.length : targetIndex;\n};\n\n/** @internal */\nvar arraysEqual = function arraysEqual(arrA, arrB, comparator) {\n  if (comparator === void 0) {\n    comparator = function comparator(a, b) {\n      return a === b;\n    };\n  }\n  if (arrA.length !== arrB.length) {\n    return false;\n  }\n  for (var i = 0; i < arrA.length; i += 1) {\n    if (!comparator(arrA[i], arrB[i])) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/** @internal */\nvar emptyViewport = {\n  columns: [[0, 0]],\n  rows: [0, 0],\n  headerRows: [0, 0],\n  footerRows: [0, 0],\n  top: 0,\n  left: 0,\n  width: 800,\n  height: 600\n};\nvar TOP_POSITION = Symbol('top');\nvar BOTTOM_POSITION = Symbol('bottom');\nvar LEFT_POSITION = Symbol('left');\nvar RIGHT_POSITION = Symbol('right');\nvar VALID_UNITS$2 = ['px', ''];\n/* tslint:disable max-line-length */\nvar VIRTUAL_TABLE_ERROR = 'The columnExtension property of the VirtualTable plugin is given an invalid value.';\nvar getViewport = function getViewport(state, getters, getRowHeight, getColumnWidth) {\n  var viewportTop = state.viewportTop,\n    skipItems = state.skipItems,\n    viewportLeft = state.viewportLeft,\n    containerWidth = state.containerWidth,\n    containerHeight = state.containerHeight;\n  var loadedRowsStart = getters.loadedRowsStart,\n    tableBodyRows = getters.bodyRows,\n    tableColumns = getters.columns,\n    _a = getters.headerRows,\n    tableHeaderRows = _a === void 0 ? [] : _a,\n    _b = getters.footerRows,\n    tableFooterRows = _b === void 0 ? [] : _b,\n    isDataRemote = getters.isDataRemote,\n    viewport = getters.viewport;\n  var rows = getRowsVisibleBoundary(tableBodyRows, viewportTop, containerHeight, getRowHeight, skipItems, loadedRowsStart, isDataRemote);\n  var headerRows = getRowsVisibleBoundary(tableHeaderRows, 0, 0, getRowHeight, [0, 0], 0, false);\n  var footerRows = getRowsVisibleBoundary(tableFooterRows, 0, 0, getRowHeight, [0, 0], 0, false);\n  var columns = getColumnBoundaries(tableColumns, viewportLeft, containerWidth, getColumnWidth);\n  // NOTE: prevent unnecessary updates\n  // e.g. when rows changed but bounds remain the same.\n  var result = viewport;\n  if (viewportTop !== viewport.top) {\n    result = _assign(_assign({}, result), {\n      top: viewportTop\n    });\n  }\n  if (viewportLeft !== viewport.left) {\n    result = _assign(_assign({}, result), {\n      left: viewportLeft\n    });\n  }\n  if (containerWidth !== viewport.width) {\n    result = _assign(_assign({}, result), {\n      width: containerWidth\n    });\n  }\n  if (containerHeight !== viewport.height) {\n    result = _assign(_assign({}, result), {\n      height: containerHeight\n    });\n  }\n  if (!arraysEqual(rows, viewport.rows)) {\n    result = _assign(_assign({}, result), {\n      rows: rows\n    });\n  }\n  if (!arraysEqual(headerRows, viewport.headerRows)) {\n    result = _assign(_assign({}, result), {\n      headerRows: headerRows\n    });\n  }\n  if (!arraysEqual(footerRows, viewport.footerRows)) {\n    result = _assign(_assign({}, result), {\n      footerRows: footerRows\n    });\n  }\n  if (!arraysEqual(columns, viewport.columns, arraysEqual)) {\n    result = _assign(_assign({}, result), {\n      columns: columns\n    });\n  }\n  return result;\n};\nvar checkColumnWidths = function checkColumnWidths(tableColumns) {\n  return tableColumns.reduce(function (acc, tableColumn) {\n    var width = tableColumn.width;\n    if (typeof width === 'string') {\n      var numb = parseInt(width, 10);\n      var unit_1 = numb ? width.substr(numb.toString().length) : width;\n      var isValidUnit = VALID_UNITS$2.some(function (validUnit) {\n        return validUnit === unit_1;\n      });\n      if (!isValidUnit) {\n        throw new Error(VIRTUAL_TABLE_ERROR);\n      }\n      acc.push(_assign(_assign({}, tableColumn), {\n        width: numb\n      }));\n    } else {\n      acc.push(tableColumn);\n    }\n    return acc;\n  }, []);\n};\nvar calculateScrollHeight = function calculateScrollHeight(rowHeight, index) {\n  return index > -1 ? rowHeight * index : undefined;\n};\nvar getScrollTop = function getScrollTop(rows, rowsCount, rowId, rowHeight, isDataRemote) {\n  if (rowId === TOP_POSITION) {\n    return 0;\n  }\n  if (rowId === BOTTOM_POSITION) {\n    return rowsCount * rowHeight;\n  }\n  var searchIndexRequired = !isDataRemote && rowId !== undefined;\n  var indexById = searchIndexRequired ? rows.findIndex(function (row) {\n    return row.rowId === rowId;\n  }) : undefined;\n  return calculateScrollHeight(rowHeight, indexById);\n};\nvar getScrollLeft = function getScrollLeft(columnCount, columnWidth, columnId) {\n  if (!columnId) {\n    return;\n  }\n  if (columnId === LEFT_POSITION) {\n    return 0;\n  }\n  return columnCount * columnWidth;\n};\nvar getTopRowId = function getTopRowId(viewport, tableBodyRows, isDataRemote) {\n  var hasViewportRows = viewport && viewport.rows;\n  var hasBodyRows = tableBodyRows && tableBodyRows.length;\n  if (hasViewportRows && hasBodyRows && !isDataRemote) {\n    var index = viewport.rows[0];\n    return index < tableBodyRows.length ? tableBodyRows[index].rowId : undefined;\n  }\n  return undefined;\n};\nvar isColumnsWidthDifferent = function isColumnsWidthDifferent(prevColumns, columns) {\n  return prevColumns.some(function (column) {\n    var currentColumn = columns.find(function (c) {\n      return c.key === column.key;\n    });\n    return currentColumn ? currentColumn.width !== column.width : true;\n  });\n};\nvar virtualRowsWithCache = function virtualRowsWithCache(skip, rows, cache) {\n  var rowsInterval = intervalUtil.getRowsInterval({\n    skip: skip,\n    rows: rows\n  });\n  var cacheInterval = intervalUtil.getRowsInterval(cache);\n  return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);\n};\nvar plainRows = function plainRows(virtualRows, availableRowCount) {\n  return virtualRows.rows.length > availableRowCount ? virtualRows.rows.slice(0, availableRowCount) : virtualRows.rows;\n};\nvar loadedRowsStart = function loadedRowsStart(virtualRows) {\n  return virtualRows.skip;\n};\nvar ROOT_GROUP = '__root__';\nvar DEFAULT_COLUMN_WIDTH = 150;\nvar exportHeader = function exportHeader(worksheet, columns) {\n  var cols = columns.map(function (_a) {\n    var column = _a.column,\n      width = _a.width;\n    return {\n      width: (width || DEFAULT_COLUMN_WIDTH) / 8,\n      key: column === null || column === void 0 ? void 0 : column.name\n    };\n  });\n  worksheet.columns = cols;\n  var headerRow = columns.reduce(function (acc, _a) {\n    var _b;\n    var _c = _a.column,\n      _d = _c === void 0 ? {} : _c,\n      name = _d.name,\n      title = _d.title;\n    return _assign(_assign({}, acc), (_b = {}, _b[name] = title, _b));\n  }, {});\n  worksheet.addRow(headerRow);\n  worksheet.views.push({\n    state: 'frozen',\n    ySplit: worksheet.lastRow.number\n  });\n};\nvar findRanges = function findRanges(groupTree, compoundKey, level, maxLevel, result) {\n  if (result === void 0) {\n    result = [];\n  }\n  if (level !== maxLevel) {\n    var ranges = groupTree[compoundKey].reduce(function (acc, groupKey) {\n      return __spread(acc, findRanges(groupTree, groupKey, level + 1, maxLevel, result));\n    }, []);\n    return __spread(result, ranges);\n  }\n  return __spread(result, [groupTree[compoundKey]]);\n};\nvar exportRows = function exportRows(worksheet, allRows, dataColumns, columns, isGroupRow, outlineLevels, rowsOffset, getCellValue, getCloseGroup, customizeCell) {\n  var currentLevel = 0;\n  var openGroups = [];\n  var closeGroup = getCloseGroup(rowsOffset);\n  allRows.forEach(function (row) {\n    var _a;\n    var _b;\n    var excelRow;\n    if (isGroupRow && isGroupRow(row)) {\n      currentLevel = outlineLevels[row.groupedBy];\n      // close nested groups first\n      openGroups.slice(currentLevel).reverse().forEach(closeGroup);\n      openGroups = openGroups.slice(0, currentLevel);\n      openGroups[currentLevel] = {\n        groupedBy: row.groupedBy,\n        compoundKey: row.compoundKey\n      };\n      // add group row\n      var title = (_b = dataColumns.find(function (_a) {\n        var name = _a.name;\n        return name === row.groupedBy;\n      })) === null || _b === void 0 ? void 0 : _b.title;\n      excelRow = (_a = {}, _a[columns[0].column.name] = title + \": \" + row.value, _a);\n      worksheet.addRow(excelRow);\n      var lastIndex = worksheet.lastRow.number;\n      // merge into single cell\n      worksheet.mergeCells(lastIndex, 1, lastIndex, columns.length);\n      worksheet.lastRow.getCell(1).font = {\n        bold: true\n      };\n      if (currentLevel > 0) {\n        worksheet.lastRow.outlineLevel = currentLevel;\n      }\n      currentLevel += 1;\n    } else {\n      excelRow = columns.reduce(function (acc, _a) {\n        var _b;\n        var column = _a.column;\n        return _assign(_assign({}, acc), column ? (_b = {}, _b[column.name] = getCellValue(row, column.name), _b) : null);\n      }, {});\n      worksheet.addRow(excelRow);\n      worksheet.lastRow.outlineLevel = currentLevel;\n    }\n    worksheet.lastRow.eachCell(function (cell, colNumber) {\n      customizeCell(cell, row, columns[colNumber - 1].column);\n    });\n  });\n  openGroups.reverse().forEach(closeGroup);\n};\nvar closeSheet = function closeSheet(worksheet, groupTree, maxGroupLevel, rowsOffset, totalSummaryItems, exportSummary) {\n  exportSummaryItems(worksheet, groupTree, totalSummaryItems, ROOT_GROUP, -1, rowsOffset, maxGroupLevel, exportSummary);\n};\nvar normalizeRanges = function normalizeRanges(ranges, offset) {\n  return ranges.map(function (range) {\n    return range.map(function (index) {\n      return +index + offset;\n    });\n  });\n};\nvar exportSummaryItems = function exportSummaryItems(worksheet, groupTree, summaryItems, groupKey, groupLevel, rowsOffset, maxGroupLevel, exportSummary) {\n  if (!summaryItems) return;\n  worksheet.addRow({});\n  var ranges = normalizeRanges(findRanges(groupTree, groupKey, groupLevel, maxGroupLevel), rowsOffset);\n  summaryItems.forEach(function (s) {\n    exportSummary(s, ranges);\n  });\n};\nvar removeEmptyGroups = function removeEmptyGroups(rows, grouping, isGroupRow) {\n  if (!grouping) return rows;\n  var groupingColumns = grouping.map(function (_a) {\n    var columnName = _a.columnName;\n    return columnName;\n  });\n  var result = [];\n  var groupChain = [];\n  rows.forEach(function (row) {\n    if (isGroupRow(row)) {\n      var level = groupingColumns.indexOf(row.groupedBy);\n      if (level === groupChain.length) {\n        groupChain.push(row);\n      } else {\n        groupChain = __spread(groupChain.slice(0, level), [row]);\n      }\n    } else {\n      if (groupChain.length > 0) {\n        result.push.apply(result, __spread(groupChain));\n        groupChain = Array.from({\n          length: groupChain.length\n        });\n      }\n      result.push(row);\n    }\n  });\n  return result.filter(function (row) {\n    return !!row;\n  });\n};\nvar groupOutlineLevels = function groupOutlineLevels(grouping) {\n  return (grouping === null || grouping === void 0 ? void 0 : grouping.reduce(function (acc, _a, index) {\n    var _b;\n    var columnName = _a.columnName;\n    return _assign(_assign({}, acc), (_b = {}, _b[columnName] = index, _b));\n  }, {})) || {};\n};\nvar filterSelectedRows = function filterSelectedRows(rows, selection, getRowId, isGroupRow) {\n  var selectionSet = new Set(selection);\n  return rows.filter(function (row) {\n    return isGroupRow && isGroupRow(row) || selectionSet.has(getRowId(row));\n  });\n};\nvar rowsToExport = function rowsToExport(rows, selection, grouping, getCollapsedRows, getRowId, isGroupRow) {\n  var expandRows = function expandRows(collapsedRows) {\n    return collapsedRows.reduce(function (acc, row) {\n      return __spread(acc, [row], expandRows(getCollapsedRows(row) || []));\n    }, []);\n  };\n  var expandedRows = getCollapsedRows ? expandRows(rows) : rows;\n  if (!selection) {\n    return expandedRows;\n  }\n  var filteredRows = filterSelectedRows(expandedRows, selection, getRowId, isGroupRow);\n  return removeEmptyGroups(filteredRows, grouping, isGroupRow);\n};\nvar buildGroupTree = function buildGroupTree(rows, outlineLevels, grouping, isGroupRow, groupSummaryItems) {\n  var _a;\n  var groupTree = (_a = {}, _a[ROOT_GROUP] = [], _a);\n  if (!(grouping === null || grouping === void 0 ? void 0 : grouping.length)) {\n    groupTree[ROOT_GROUP] = [0, rows.length - 1];\n    return groupTree;\n  }\n  var maxLevel = Object.keys(outlineLevels).length - 1;\n  var groupSummaryExists = !!groupSummaryItems;\n  var parentChain = {\n    '-1': ROOT_GROUP\n  };\n  var lastDataIndex = 0;\n  var openGroup = '';\n  var index = 0;\n  var level = 0;\n  var prevLevel = 0;\n  rows.forEach(function (row) {\n    var groupedBy = row.groupedBy,\n      compoundKey = row.compoundKey;\n    if (isGroupRow(row)) {\n      level = outlineLevels[groupedBy];\n      groupTree[compoundKey] = [];\n      parentChain[level] = compoundKey;\n      if (level <= maxLevel) {\n        groupTree[parentChain[level - 1]].push(compoundKey);\n      }\n      if (level === maxLevel) {\n        if (openGroup) {\n          // close previous group\n          groupTree[openGroup].push(lastDataIndex);\n        }\n        openGroup = compoundKey;\n        if (groupSummaryExists && lastDataIndex > 0) {\n          index += 1;\n        }\n        groupTree[compoundKey].push(index + 1); // first row index\n      } else if (groupSummaryExists && level < prevLevel) {\n        // jump over summary rows\n        index += maxLevel - level;\n      }\n      prevLevel = level;\n    } else {\n      lastDataIndex = index;\n    }\n    index += 1;\n  });\n  if (openGroup) {\n    groupTree[openGroup].push(lastDataIndex);\n  }\n  return groupTree;\n};\nvar operations = {\n  count: 'COUNTA'\n};\nvar exportSummaryGetter = function exportSummaryGetter(worksheet, tableColumns, customizeSummaryCell, defaultSummaryMessages) {\n  return function (_a, ranges) {\n    var columnName = _a.columnName,\n      type = _a.type;\n    var column = (tableColumns.find(function (_a) {\n      var dataColumn = _a.column,\n        columnType = _a.type;\n      return columnType === TABLE_DATA_TYPE && dataColumn && dataColumn.name === columnName;\n    }) || {}).column;\n    // NOTE: column is hidden or the grid grouped by this column\n    if (!column) {\n      return;\n    }\n    var row = worksheet.lastRow;\n    var letter = worksheet.getColumn(columnName).letter;\n    var operation = operations[type] || type.toUpperCase();\n    var rangesStr = ranges.map(function (range) {\n      return range.map(function (r) {\n        return \"\" + letter + r;\n      }).filter(function (val, index, arr) {\n        return arr.indexOf(val) === index;\n      }).join(':');\n    }).join(',');\n    var cell = row.getCell(columnName);\n    cell.value = {\n      formula: operation + \"(\" + rangesStr + \")\",\n      date1904: false\n    };\n    cell.numFmt = \"\\\"\" + defaultSummaryMessages[type] + \":\\\" 0\";\n    var summary = {\n      type: type,\n      ranges: ranges\n    };\n    customizeSummaryCell(cell, column, summary);\n  };\n};\nvar closeGroupGetter = function closeGroupGetter(worksheet, groupTree, outlineLevels, maxGroupLevel, groupSummaryItems, exportSummary) {\n  return function (rowsOffset) {\n    return function (group) {\n      var groupedBy = group.groupedBy,\n        compoundKey = group.compoundKey;\n      exportSummaryItems(worksheet, groupTree, groupSummaryItems, compoundKey, outlineLevels[groupedBy], rowsOffset, maxGroupLevel, exportSummary);\n    };\n  };\n};\nvar maximumGroupLevel = function maximumGroupLevel(grouping) {\n  return (grouping || []).length - 1;\n};\nexport { BAND_DUPLICATE_RENDER, BAND_EMPTY_CELL, BAND_FILL_LEVEL_CELL, BAND_GROUP_CELL, BAND_HEADER_CELL, BOTTOM_POSITION, DEFAULT_COLUMN_WIDTH, DEFAULT_FILTER_OPERATIONS, FIXED_COLUMN_LEFT_SIDE, FIXED_COLUMN_RIGHT_SIDE, GROUP_KEY_SEPARATOR, LEFT_POSITION, RIGHT_POSITION, ROOT_GROUP, TABLE_ADDED_TYPE, TABLE_BAND_TYPE, TABLE_DATA_TYPE, TABLE_DETAIL_TYPE, TABLE_EDIT_COMMAND_TYPE, TABLE_EDIT_TYPE, TABLE_FILTER_TYPE, TABLE_FIXED_TYPE, TABLE_FLEX_TYPE, TABLE_GROUP_SUMMARY_TYPE, TABLE_GROUP_TYPE, TABLE_HEADING_TYPE, TABLE_NODATA_TYPE, TABLE_REORDERING_TYPE, TABLE_SELECT_TYPE, TABLE_STUB_TYPE, TABLE_TOTAL_SUMMARY_TYPE, TABLE_TREE_SUMMARY_TYPE, TOP_POSITION, addRow, addedRowsByIds, adjustSortIndex, allSelected, bandLevelsVisibility, buildGroupTree, calculateBand, calculateFixedColumnProps, calculateGroupCellIndent, calculateKeepOther, calculateRequestedRange, calculateScrollHeight, calculateStartPage, cancelAddedRows, cancelChanges, cancelColumnGroupingDraft, cancelDeletedRows, cancelTableColumnWidthDraft, cellValueGetter, changeAddedRow, changeColumnFilter, changeColumnGrouping, changeColumnOrder, changeColumnSorting, changeRow, changeSearchValue, changeTableColumnWidth, changedRowsByIds, checkColumnWidths, checkTableColumnExtensions, clamp, closeGroupGetter, closeSheet, collapsedTreeRowsGetter, columnBandLevels, columnChooserItems, columnVisibleIntervals, columnsWithEditingCells, convertWidth, createRowChangeGetter, currentPage, customGroupedRows, customGroupingRowIdGetter, customTreeRowIdGetter, customTreeRowLevelKeyGetter, customTreeRowsWithMeta, defaultFilterPredicate, defaultFormatlessSummaries, defaultSummaryCalculator, deleteRows, draftColumnGrouping, draftOrder, draftTableColumnWidth, emptyViewport, emptyVirtualRows, evalAnimations, expandedGroupRows, expandedTreeRows, exportHeader, exportRows, exportSummaryGetter, exportSummaryItems, filterActiveAnimations, filterExpression, filterHeaderRows, filteredCollapsedRowsGetter, filteredRows, findChainByColumnIndex, findRanges, firstRowOnPage, focus, generateSimpleChains, getAnimations, getAvailableFilterOperationsGetter, getAvailableRowCount, getBandComponent, getCellGeometries, getClosestCellByRow, getCollapsedGrid, getCollapsedGrids, getColumnBoundaries, getColumnExtension, getColumnExtensionValueGetter, getColumnFilterConfig, getColumnFilterOperations, getColumnMeta, getColumnSizes, getColumnSortingDirection, getColumnSummaries, getColumnWidthGetter, getColumnsRenderBoundary, getFixedColumnKeys, getFocusing, getForceReloadInterval, getGroupCellTargetIndex, getGroupInlineSummaries, getIndexToFocus, getInnerElements, getNextColumnName, getNextFocusedCell, getPart, getPersistentSortedColumns, getReferenceIndex, getRequestMeta, getRowChange, getRowsRenderBoundary, getRowsVisibleBoundary, getScrollLeft, getScrollTop, getSelectedFilterOperation, getTableColumnGeometries, getTableTargetColumnIndex, getTopRowId, getTreeRowLevelGetter, getViewport, groupCollapsedRowsGetter, groupFooterSummaryExists, groupOutlineLevels, groupRowChecker, groupRowLevelKeyGetter, groupSummaryValues, groupedRows, groupingPanelItems, intervalUtil, isAddedTableRow, isBandedOrHeaderRow, isBandedTableRow, isCellExist, isCellFocused, isColumnsWidthDifferent, isDataTableCell, isDataTableRow, isDetailRowExpanded, isDetailTableCell, isDetailTableRow, isDetailToggleTableCell, isEditCommandsTableCell, isEditTableCell, isEditTableRow, isFilterTableCell, isFilterTableRow, isFilterValueEmpty, isFixedTableRow, isFooterSummary, isGroupIndentStubTableCell, isGroupIndentTableCell, isGroupRowOrdinaryCell, isGroupSummaryTableCell, isGroupSummaryTableRow, isGroupTableCell, isGroupTableRow, isHeaderStubTableCell, isHeadingEditCommandsTableCell, isHeadingTableCell, isHeadingTableRow, isInlineGroupCaptionSummary, isNoDataColumn, isNoDataTableCell, isNoDataTableRow, isPreviousCellContainSummary, isRowFocused, isRowHighlighted, isRowSummaryCell, isSelectAllTableCell, isSelectTableCell, isStubTableCell, isTabArrowUpDown, isTotalSummaryTableCell, isTotalSummaryTableRow, isTreeRowLeafGetter, isTreeSummaryTableCell, isTreeSummaryTableRow, isTreeTableCell, isValidValue, lastRowOnPage, loadedRowsStart, maximumGroupLevel, mergeRows, needFetchMorePages, normalizeRanges, orderedColumns, pageCount, paginatedRows, plainRows, prepareGroupSummaryItems, recalculateBounds, removeEmptyGroups, rowCount, rowIdGetter, rowToPageIndex, rowsToExport, rowsWithAvailableToSelect, rowsWithEditingCells, rowsWithPageHeaders, searchFilterExpression, setCurrentPage, setPageSize, shouldSendRequest, someSelected, sortAndSpliceColumns, sortedRows, splitHeaderColumnChains, startEditCells, startEditRows, stopEditCells, stopEditRows, tableCellColSpanGetter, tableColumnsWithDataRows, tableColumnsWithDetail, tableColumnsWithDraftWidths, tableColumnsWithEditing, tableColumnsWithFixed, tableColumnsWithGrouping, tableColumnsWithSelection, tableColumnsWithWidths, tableDataColumnsExist, tableDetailCellColSpanGetter, tableGroupCellColSpanGetter, tableHeaderColumnChainsWithBands, tableHeaderColumnChainsWithFixed, tableHeaderRowsWithFilter, tableHeaderRowsWithFixed, tableHeaderRowsWithReordering, tableRowsWithBands, tableRowsWithDataRows, tableRowsWithEditing, tableRowsWithExpandedDetail, tableRowsWithGrouping, tableRowsWithHeading, tableRowsWithSummaries, tableRowsWithTotalSummaries, toggleColumn, toggleDetailRowExpanded, toggleExpandedGroups, toggleRowExpanded, toggleSelection, totalSummaryValues, treeSummaryValues, trimRowsToInterval, unwrapSelectedRows, unwrappedCustomTreeRows, unwrappedFilteredRows, virtualRowsWithCache, visibleTableColumns };","map":{"version":3,"names":["GRID_GROUP_TYPE","Symbol","GRID_GROUP_CHECK","toString","GRID_GROUP_LEVEL_KEY","GRID_GROUP_COLLAPSED_ROWS","warnIfRowIdUndefined","getRowId","row","result","undefined","console","warn","rowIdGetter","rows","map_1","Map","map","rowIndex","get","defaultGetCellValue","columnName","cellValueGetter","getCellValue","columns","useFastAccessor","reduce","acc","column","name","changeColumnSorting","state","_a","direction","keepOther","sortIndex","sorting","nextSorting","Array","isArray","slice","filter","s","indexOf","columnSortingIndex","findIndex","columnSorting","newColumnSorting","splice","newIndexFallback","length","newIndex","unique","arr","__spread","from","Set","getColumnSortingDirection","getPersistentSortedColumns","columnExtensions","sortingEnabled","sortItem","push","calculateKeepOther","persistentSortedColumns","item","merge","array","auxiliary","lo","mid","hi","compare","i","j","k","cmp","sortArrayToAuxiliary","Math","floor","sortAuxiliaryToArray","mergeSort","a","b","NODE_CHECK","rowsToTree","getRowLevelKey","levels","children","forEach","levelKey","levelIndex","level","root","node","treeToRows","tree","defaultCompare","createCompare","getColumnCompare","getComparableValue","reduceRight","prevCompare","inverse","columnCompare","aRow","bRow","args","_i","arguments","sortTree","sortedTree","__assign","sortHierarchicalRows","sortedRows","isGroupRow","groupedBy","value","changeColumnFilter","filters","config","filterIndex","f","nextState","getColumnFilterConfig","filterExpression","expression","selfFilterExpr","operator","operators","or","predicates","predicate","and","toLowerCase","String","operationPredicates","contains","notContains","startsWith","endsWith","equal","notEqual","greaterThan","greaterThanOrEqual","lessThan","lessThanOrEqual","defaultFilterPredicate","operation","filterTree","filteredChildren","filterHierarchicalRows","getCollapsedRows","collapsedRowsMeta","filteredTree","isNode","collapsedRows","filteredCollapsedRows","buildPredicate","initialFilterExpression","getColumnPredicate","getSimplePredicate","customPredicate","getOperatorPredicate","build","getPredicate","filteredRows","Object","keys","filteredCollapsedRowsGetter","unwrappedFilteredRows","GROUP_KEY_SEPARATOR","applyColumnGrouping","grouping","groupIndex","nextGrouping","groupingIndex","g","targetIndex","changeColumnGrouping","_b","expandedGroups","ungroupedColumnIndex","group","index","filteredExpandedGroups","split","toggleExpandedGroups","groupKey","groupKeyIndex","draftColumnGrouping","draftGrouping","cancelColumnGroupingDraft","adjustSortIndex","max","columnGrouping","defaultColumnCriteria","key","getGroupRows","groupsGetter","keyPrefixes","prefix","resultRows","compoundKeys","pop","keyPrefix","currentRows","currentCompoundKey","groupRows","childRows","params","__rest","compoundKey","apply","getIntegratedGroups","getColumnCriteria","groupCriteria","groups","rawValue","sameKeyItems","groupingValue","set","values","_c","__read","groupRowChecker","groupRowLevelKeyGetter","groupedRows","currentGrouping","expandedGroupRows","isExporting","groupingColumnNames","expandedGroupsSet","currentGroupExpanded","currentGroupLevel","groupLevel","has","groupCollapsedRowsGetter","getCustomGroups","getChildGroups","rootRows","customGroupedRows","customGroupingRowIdGetter","firstRow","find","groupingPanelItems","items","c","draft","some","setCurrentPage","prevPage","page","setPageSize","prevPageSize","size","clamp","min","PAGE_HEADERS_OVERFLOW_ERROR","paginatedRows","pageSize","rowsWithPageHeaders","headerRows","currentIndex","headerIndex","headerRow","Error","indexInPage","rowCount","pageCount","count","ceil","currentPage","totalCount","totalPages","adjustedCurrentPage","setTimeout","firstRowOnPage","lastRowOnPage","totalRowCount","calculateStartPage","maxButtonCount","totalPageCount","toggle","source","itemsSet","sourceState","availableSelection","sourceSet_1","toggleSelection","selection","rowIds","rowsWithAvailableToSelect","dataRows","availableToSelect","someSelected","selectionSet","elem","allSelected","unwrapSelectedRows","startEditRows","prevEditingRowIds","stopEditRows","rowIdSet","id","startEditCells","prevEditingCells","editingCells","stopEditCells","rowId","currentRowId","currentColumnName","addRow","addedRows","changeAddedRow","change","cancelAddedRows","indexSet","changeRow","prevRowChanges","prevChange","cancelChanges","deleteRows","deletedRowIds","cancelDeletedRows","changedRowsByIds","changes","addedRowsByIds","defaultCreateRowChange","createRowChangeGetter","createRowChange","columnExtension","getRowChange","rowChanges","TABLE_REORDERING_TYPE","changeColumnOrder","order","sourceColumnName","targetColumnName","sourceColumnIndex","targetColumnIndex","newOrder","TABLE_DATA_TYPE","TABLE_NODATA_TYPE","TABLE_FLEX_TYPE","orderedColumns","tableColumns","type","aPos","bPos","tableHeaderRowsWithReordering","tableHeaderRows","height","draftOrder","sourceColumn","getColumnWidth","columnWidths","cachedWidths","shift","minColumnWidth","maxColumnWidth","extension","width","minWidth","maxWidth","getColumnSizes","payload","nextColumnName","resizingMode","nextWidth","nextSize","moreThanLimit","columnExpand","isValidValue","validUnits","numb","parseInt","unit","substr","sizeIsAuto","isNaN","sizeIsValid","validUnit","convertWidth","VALID_UNITS","NOT_FOR_WIDGET_UNITS","COLUMN_RESIZING_ERROR","specifyWidths","widths","onError","tableColumn","columnName_1","el","tableColumnsWithWidths","throwError","tableColumnsWithDraftWidths","draftColumnWidths","changeTableColumnWidth","nextColumnWidth","nextIndex","draftTableColumnWidth","cancelTableColumnWidthDraft","TABLE_EDIT_COMMAND_TYPE","TABLE_ADDED_TYPE","TABLE_EDIT_TYPE","TABLE_HEADING_TYPE","isHeadingEditCommandsTableCell","tableRow","isEditCommandsTableCell","tableColumnsWithEditing","isEditTableCell","isAddedTableRow","isEditTableRow","tableRowsWithEditing","tableRows","editingRowIds","rowHeight","editedTableRows","addedTableRows","reverse","rowsWithEditingCells","tableBodyRows","hasEditCell","columnsWithEditingCells","TABLE_FILTER_TYPE","DEFAULT_FILTER_OPERATIONS","isFilterTableCell","isFilterTableRow","getColumnFilterOperations","getAvailableFilterOperations","isFilterValueEmpty","getSelectedFilterOperation","filterOperations","columnFilter","columnFilterOperations","tableHeaderRowsWithFilter","TABLE_GROUP_TYPE","TABLE_STUB_TYPE","getVisibleBoundaryWithFixed","visibleBoundary","fixed","getVisibleBoundary","viewportStart","viewportSize","getItemSize","skipItems","offset","start","end","itemSize","beforePosition","viewportEnd","afterPosition","isVisible","getRenderBoundary","itemsCount","overscan","getColumnBoundaries","left","getColumnsRenderBoundary","getRowsVisibleBoundary","top","getRowHeight","isDataRemote","noVisibleRowsLoaded","boundaries","topIndex","round","columnCount","getRowsRenderBoundary","rowsCount","getSpanBoundary","visibleBoundaries","getItemSpan","endIndex","span","collapseBoundaries","spanBoundaries","breakpoints","rowBoundaries","boundary","add","every","bound","point","bp","sort","bounds","getItemsSize","startIndex","getCollapsedColumns","collapsedColumns","getCells","cells","calculateRowHeight","bound1","bound2","getCollapsedCells","getColSpan","collapsedCells","isSpan","spanBoundary","realColSpan","realColSpanEnd_1","colSpanEnd","colSpanBoundary","colSpan","getVisibleColumnBoundaries","columnsVisibleBoundary","rowSpanBoundaries","getSpanBoundaryByRow","getCollapsedGrid","rowsVisibleBoundary","columnBoundaries","getColumnWidthGetter","tableWidth","colsHavingWidth","col","columnsWidth","autoWidth","autoColWidth","visibleColumns","getCollapsedGrids","bodyRows","footerRows","loadedRowsStart","getCellColSpan","viewport","headerGrid","bodyGrid","footerGrid","getCollapsedGridRows","rowsBoundary","columnsBoundary","adjustedRenderRowBounds","commonColumns","visibleBounds","renderRowBoundaries","adjustedInterval","intervalUtil","intersect","getGroupIndexByColumn","isIndentCell","rowGroupIndex","columnGroupIndex","isGroupTableCell","isGroupIndentTableCell","isGroupIndentStubTableCell","isGroupTableRow","isGroupRowOrdinaryCell","columnHasGroupRowSummary","groupSummaryItems","showInGroupFooter","alignByColumn","isRowSummaryCell","isPreviousCellContainSummary","columnIndex","calculateGroupCellIndent","indentWidth","sortAndSpliceColumns","firstVisibleColumnIndex","groupColumns","dataColumns","otherColumns","firstGroupIndex","tableColumnsWithDraftGrouping","showColumnWhenGrouped","columnGroupingExists","columnDraftGroupingExists","tableColumnsWithGrouping","indentColumnWidth","groupedColumn","tableRowsWithGrouping","isRowLevelSummary","colName","groupSummaryChains","captionStarted","colKey","isStartOfGroupCaption","isIndentColumn","tableGroupCellColSpanGetter","getTableCellColSpan","colKey_1","chains","chain","ch","isHeadingTableCell","isHeadingTableRow","findChainByColumnIndex","splitHeaderColumnChains","tableColumnChains","shouldSplitChain","extendChainProps","currentChain","isNewGroup","generateSimpleChains","isNextColumnHasName","getNextColumnName","tableRowsWithHeading","TABLE_BAND_TYPE","BAND_GROUP_CELL","BAND_HEADER_CELL","BAND_EMPTY_CELL","BAND_DUPLICATE_RENDER","BAND_FILL_LEVEL_CELL","isBandedTableRow","isBandedOrHeaderRow","isNoDataColumn","columnType","getColumnMeta","bands","tableRowLevel","title","band","rowLevelPassed","bandTitle","bandKey","calculateBand","visibleBound","headerChain","bandStart","bandEnd","getBandComponent","columnBands","tableHeaderColumnChains","columnVisibleIntervals","bandLevelsVisibility","currentTableColumn","rowSpan","maxLevel","currentRowLevel","currentColumnMeta","currentColumnIndex","levelsCount","visibleLevelsCount","Boolean","shouldFillLevel","previousTableColumn","beforeBorder","isStubColumn","isColumnVisible","cellRowSpan","currentColumnChain","columnVisibleBoundary","emptyVirtualRows","skip","Number","POSITIVE_INFINITY","pluckSubarray","sourceStart","right","mergeRows","rowsInterval","cacheInterval","cacheRows","rowsStart","cacheStart","chunk","concat","correctRequestedRange","calculatedRange","referenceIndex","calculateRequestedRange","virtualRows","newRange","isInfiniteScroll","loadedInterval","getRowsInterval","isAdjacentPage","abs","difference","empty","rowToPageIndex","recalculateBounds","middleIndex","currentPageIndex","prevPageIndex","nextPageIndex","trimRowsToInterval","targetInterval","intersection","getAvailableRowCount","newRowCount","lastRowCount","getForceReloadInterval","intervalEnd","getRequestMeta","forceReload","actualBounds","requestedRange","needFetchMorePages","loadCount","topTriggerIndex","bottomTriggerIndex","getReferenceIndex","bottom","shouldSendRequest","requestedPageIndex","requestedEndIndex","NEGATIVE_INFINITY","r","getLength","tableRowsWithBands","tableDataColumns","getMaxNestedLevel","isDataColumn","dataColumn","tableBandHeaders","tableHeaderColumnChainsWithBands","maxBandRowIndex","rawBandChains","currentBand","bandChains","getBandLevels","columnsBands","columnBandLevels","columnIntervals","bandLevels","rowsWithBands","visibleIntervals","isBandChainVisible","interval","getVisibleBandsByLevel","_","rowBands","toggleDetailRowExpanded","prevExpanded","TABLE_DETAIL_TYPE","isDetailRowExpanded","expandedDetailRowIds","isDetailToggleTableCell","isDetailTableRow","isDetailTableCell","tableRowsWithExpandedDetail","expandedRowId","insertIndex","tableColumnsWithDetail","toggleColumnWidth","tableDetailCellColSpanGetter","TABLE_SELECT_TYPE","isSelectTableCell","isSelectAllTableCell","isRowHighlighted","highlightRow","focused","highlightion","includes","tableColumnsWithSelection","selectionColumnWidth","showSelectionColumn","VALID_UNITS$1","TABLE_ERROR","isDataTableCell","isHeaderStubTableCell","isDataTableRow","isNoDataTableRow","isNoDataTableCell","isStubTableCell","checkTableColumnExtensions","getColumnExtension","getColumnExtensionValueGetter","extensionName","defaultValue","extensionValue","tableColumnsWithDataRows","align","wordWrapEnabled","tableRowsWithDataRows","isRemoteRowsLoading","dataIndex","tableCellColSpanGetter","visibleTableColumns","hiddenColumnNames","tableDataColumnsExist","columnChooserItems","hidden","toggleColumn","hiddenColumn","toggleRowExpanded","GRID_TREE_NODE_TYPE","customTreeRowsWithMeta","getChildRows","rowsToProcess","treeRows","currentRow","nestedRows","childRow","leaf","treeMeta","customTreeRowIdGetter","firstNestedRowIndex","customTreeRowLevelKeyGetter","rowMeta","expandedTreeRows","expandedRowIds","expandedRowIdsSet","currentExpanded","currentLevel","lastRow","collapsedItems","collapsedTreeRowsGetter","isTreeRowLeafGetter","getTreeRowLevelGetter","unwrappedCustomTreeRows","isTreeTableCell","forColumnName","changeSearchValue","prevSearchValue","searchValue","searchFilterExpression","selfFilterExpression","getAvailableFilterOperationsGetter","availableFilterOperations","columnNames","FIXED_COLUMN_LEFT_SIDE","FIXED_COLUMN_RIGHT_SIDE","TABLE_FIXED_TYPE","getFixedColumnKeys","fixedNames","isFixedTableRow","calculatePosition","tableColumnDimensions","target","calculateFixedColumnProps","leftColumns","rightColumns","side","targetArray","fixedIndex","columnChain","showLeftDivider","showRightDivider","position","tableColumnsWithFixed","tableHeaderRowsWithFixed","tableHeaderColumnChainsWithFixed","currentGroup","defaultSummaryCalculators","sum","getValue","Infinity","avg","defaultSummaryCalculator","summaryCalculator","rowsSummary","summaryItems","calculator","expandRows","includeGroupRow","shouldIncludeRow","totalSummaryValues","plainRows","groupSummaryValues","getLevelIndex","summaries","anyRowLevelSummaryExist","expandedRows","isCollapsedNestedGroupRow","rowsToAppend","treeSummaryValues","TABLE_TOTAL_SUMMARY_TYPE","TABLE_GROUP_SUMMARY_TYPE","TABLE_TREE_SUMMARY_TYPE","defaultFormatlessSummaries","isTotalSummaryTableCell","isGroupSummaryTableCell","isTreeSummaryTableCell","isTotalSummaryTableRow","isGroupSummaryTableRow","isTreeSummaryTableRow","getColumnSummaries","summaryValues","isFooterSummary","summaryItem","isInlineGroupCaptionSummary","groupFooterSummaryExists","getGroupInlineSummaries","tableRowsWithTotalSummaries","tableRowsWithSummaries","treeSummaryItems","hasGroupFooterSummary","closeLevel","opened","prepareGroupSummaryItems","HEADING_TYPE","FILTER_TYPE","DATA_TYPE","BAND_TYPE","TOTAL_SUMMARY_TYPE","STUB_TYPE","GROUP_TYPE","tableParts","getIndex","isSpanInput","innerElements","tagName","isDefined","hasInsideElements","focusedElementIndex","getIndexInnerElement","elements","rowKey","columnKey","getInnerElements","cellEmptyOrHasSpanAndInput","getNextPrevClosestColumnKey","shouldBeScrolled","key1","key2","scrollToColumn","convertPart","part","getLastPart","partIndex","getRowKey","headerRowKey","getPrevPart","focusedElement","p","getNextPart","getCellNextPart","element","scrolling","getCellPrevPart","columnKeyIndex","nextColumnKey","getPrevCellFromBody","prevRowKey","prevColumnKey","getPrevCellFromHeading","headIndex","abort","getPrevElement","cell","getNextCellFromBody","nextRowKey","getNextCellFromHeading","getNextElement","hasCellInput","getCellRightLeft","getFirstCell","withInnerElements","getLastCell","getToolbarPagingElements","toolbarElements","toolbar","pagingElements","paging","hasAttribute","getAttribute","getFirstCellInLastPart","lastPart","applyEnterAction","commitChangedRows","click","applyEscapeAction","cancelChangedRows","actionOnCheckbox","actionOnTreeMode","getIndexFromKey","query","current","querySelectorAll","getCellTopBottom","isCtrlMetaKey","event","ctrlKey","metaKey","getCellNextPrevPart","applyFocusOnToolbarPaging","focus","getClosestCellByRow","bodyRow","getNextFocusedCell","inlineEditing","hasFocus","shiftKey","getPart","t","getIndexToFocus","filterHeaderRows","isRowFocused","focusedRowKey","isCellExist","isTabArrowUpDown","prevFocusedElement","onFocusedCellChange","isCellFocused","getFocusing","focusedRow","getTargetColumnGeometries","columnGeometries","sourceIndex","sourceWidth","getWidthDifference","leftBorder","rightBorder","getCellGeometries","getBoundingClientRect","styleLeft","style","replace","styleRight","calculatedLeft","isFixed","tableContainer","nodeName","parentNode","calculatedRight","getTableColumnGeometries","freeSpace","restrictedSpace","accum","freeSpacePortions","freeSpacePortion","lastRightPosition","getTableTargetColumnIndex","indexes","ANIMATION_DURATION","getAnimationProgress","animation","Date","getTime","startTime","getAnimations","prevColumns","nextColumns","prevAnimations","resizing","join","prevColumnGeometries","geometry","progress","easeOutCubic","to","nextColumnGeometries","prev","next","takePrevColumnIntoAccount","filterActiveAnimations","animations","entries","evalAnimations","transform","isOnTheSameLine","y","rectToObject","collapseGapsBetweenItems","geometries","getGroupCellTargetIndex","x","targetGeometries","inVerticalBounds","inHorizontalBounds","shouldGoFirst","shouldGoOnLineBreak","arraysEqual","arrA","arrB","comparator","emptyViewport","TOP_POSITION","BOTTOM_POSITION","LEFT_POSITION","RIGHT_POSITION","VALID_UNITS$2","VIRTUAL_TABLE_ERROR","getViewport","getters","viewportTop","viewportLeft","containerWidth","containerHeight","tableFooterRows","checkColumnWidths","unit_1","isValidUnit","calculateScrollHeight","getScrollTop","searchIndexRequired","indexById","getScrollLeft","columnWidth","columnId","getTopRowId","hasViewportRows","hasBodyRows","isColumnsWidthDifferent","currentColumn","virtualRowsWithCache","cache","availableRowCount","ROOT_GROUP","DEFAULT_COLUMN_WIDTH","exportHeader","worksheet","cols","_d","views","ySplit","number","findRanges","groupTree","ranges","exportRows","allRows","outlineLevels","rowsOffset","getCloseGroup","customizeCell","openGroups","closeGroup","excelRow","lastIndex","mergeCells","getCell","font","bold","outlineLevel","eachCell","colNumber","closeSheet","maxGroupLevel","totalSummaryItems","exportSummary","exportSummaryItems","normalizeRanges","range","removeEmptyGroups","groupingColumns","groupChain","groupOutlineLevels","filterSelectedRows","rowsToExport","buildGroupTree","groupSummaryExists","parentChain","lastDataIndex","openGroup","prevLevel","operations","exportSummaryGetter","customizeSummaryCell","defaultSummaryMessages","letter","getColumn","toUpperCase","rangesStr","val","formula","date1904","numFmt","summary","closeGroupGetter","maximumGroupLevel"],"sources":["C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\integrated-grouping\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\grid-core\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\sorting-state\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\sorting-state\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\utils\\merge-sort.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\utils\\hierarchical-data.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\integrated-sorting\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\filtering-state\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\filtering-state\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\filtering-state\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\integrated-filtering\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\grouping-state\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\grouping-state\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\grouping-state\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\integrated-grouping\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\integrated-grouping\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\custom-grouping\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\custom-grouping\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\grouping-panel\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\paging-state\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\integrated-paging\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\integrated-paging\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\paging-panel\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\utils\\common-reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\selection-state\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\integrated-selection\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\editing-state\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\editing-state\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\editing-state\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-column-reordering\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-column-reordering\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-column-reordering\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-column-resizing\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-column-resizing\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-column-resizing\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-edit-column\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-edit-row\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-header-row\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-edit-column\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-edit-column\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-edit-row\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-edit-row\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-inline-cell-editing\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-filter-row\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-filter-row\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-filter-row\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-group-row\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\utils\\virtual-table.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-group-row\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-group-row\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-header-row\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-header-row\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-band-header\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-band-header\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\virtual-table-state\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\virtual-table-state\\utils.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-band-header\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\row-detail-state\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-row-detail\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-row-detail\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-row-detail\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-selection\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-selection\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-selection\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\utils\\column-extension.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-column-visibility\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-column-visibility\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\column-chooser\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\column-chooser\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\tree-data-state\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\custom-tree-data\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\custom-tree-data\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-tree-column\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\search-state\\reducers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\search-state\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\data-type-provider\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-fixed-columns\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-fixed-columns\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-fixed-columns\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\integrated-summary\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-summary-row\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-summary-row\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-summary-row\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\summary-state\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-keyboard-navigation\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\table-keyboard-navigation\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\utils\\column-geometries.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\utils\\table.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\utils\\group-panel.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\virtual-table\\utils.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\virtual-table\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\virtual-table\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\virtual-table-state\\computeds.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\grid-exporter\\constants.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\grid-exporter\\helpers.ts","C:\\Users\\family\\Desktop\\gridtable-main\\node_modules\\@devexpress\\dx-grid-core\\src\\plugins\\grid-exporter\\computeds.ts"],"sourcesContent":["export const GRID_GROUP_TYPE = Symbol('group');\nexport const GRID_GROUP_CHECK = Symbol(`${GRID_GROUP_TYPE.toString()}_check`);\nexport const GRID_GROUP_LEVEL_KEY = Symbol(`${GRID_GROUP_TYPE.toString()}_levelKey`);\nexport const GRID_GROUP_COLLAPSED_ROWS = Symbol(`${GRID_GROUP_TYPE.toString()}_collapsedRows`);\n","import { GRID_GROUP_CHECK } from '../integrated-grouping/constants';\nimport { GetRowIdFn, Row, RowId, GetCellValueFn, Column } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nconst warnIfRowIdUndefined: PureComputed<[GetRowIdFn]> = getRowId => (row) => {\n  const result = getRowId(row);\n  if (!row[GRID_GROUP_CHECK] && result === undefined) {\n    // tslint:disable-next-line: no-console\n    console.warn('The row id is undefined. Check the getRowId function. The row is', row);\n  }\n  return result;\n};\n\nexport const rowIdGetter: PureComputed<[GetRowIdFn, Row[]]> = (getRowId, rows) => {\n  if (!getRowId) {\n    const map = new Map(rows.map((row, rowIndex) => [row, rowIndex]) as [any, number]);\n    return (row: Row) => map.get(row) as RowId;\n  }\n  return warnIfRowIdUndefined(getRowId);\n};\n\nconst defaultGetCellValue: GetCellValueFn = (row, columnName) => row[columnName];\n\nexport const cellValueGetter: PureComputed<[GetCellValueFn, Column[]]> = (\n  getCellValue = defaultGetCellValue, columns,\n) => {\n  let useFastAccessor = true;\n  const map = columns.reduce((acc, column) => {\n    if (column.getCellValue) {\n      useFastAccessor = false;\n      acc[column.name] = column.getCellValue;\n    }\n    return acc;\n  }, {});\n\n  if (useFastAccessor) {\n    return getCellValue;\n  }\n\n  return (row, columnName) => (map[columnName]\n    ? map[columnName](row, columnName)\n    : getCellValue(row, columnName));\n};\n","import { ColumnSortingState, ChangeSortingPayload, Sorting } from '../../types';\nimport { PureReducer, slice } from '@devexpress/dx-core';\n\nexport const changeColumnSorting: PureReducer<ColumnSortingState, ChangeSortingPayload> = (\n  state, {\n  columnName, direction, keepOther, sortIndex,\n}) => {\n  const { sorting } = state;\n\n  let nextSorting: any[] = [];\n  if (keepOther === true) {\n    nextSorting = sorting as Sorting[];\n  }\n  if (Array.isArray(keepOther)) {\n    nextSorting = slice(sorting)\n      .filter(s =>\n        keepOther.indexOf(s.columnName) > -1);\n  }\n\n  const columnSortingIndex = sorting.findIndex(s => s.columnName === columnName);\n  const columnSorting = sorting[columnSortingIndex];\n  const newColumnSorting = {\n    columnName,\n    direction: direction\n      || (!columnSorting || columnSorting.direction === 'desc' ? 'asc' : 'desc'),\n  };\n\n  if (columnSortingIndex > -1) {\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(columnSortingIndex, 1);\n  }\n\n  if (direction !== null) {\n    const newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;\n    const newIndex = sortIndex !== undefined ? sortIndex : newIndexFallback;\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(newIndex, 0, newColumnSorting);\n  }\n\n  return {\n    sorting: nextSorting,\n  };\n};\n","import {\n  KeepOtherSorting, GetColumnSortingDirectionFn, GetPersistentSortedColumnsFn,\n  CalculateKeepOtherFn,\n} from '../../types';\n\nconst unique = (arr: any[]) => [...Array.from(new Set(arr))];\n\nexport const getColumnSortingDirection: GetColumnSortingDirectionFn = (\n  sorting, columnName,\n) => {\n  const columnSorting = sorting.filter(s => s.columnName === columnName)[0];\n  return columnSorting ? columnSorting.direction : null;\n};\n\nexport const getPersistentSortedColumns: GetPersistentSortedColumnsFn = (\n  sorting, columnExtensions = [],\n) => columnExtensions.reduce((acc, { columnName, sortingEnabled }) => {\n  if (!sortingEnabled) {\n    if (sorting.findIndex(sortItem => sortItem.columnName === columnName) > -1) {\n      acc.push(columnName);\n    }\n  }\n  return acc;\n}, [] as string[]);\n\nexport const calculateKeepOther: CalculateKeepOtherFn = (\n  sorting, keepOther, persistentSortedColumns = [],\n) => {\n  if (!persistentSortedColumns.length) return keepOther as KeepOtherSorting;\n  if (!keepOther) return persistentSortedColumns as KeepOtherSorting;\n\n  return Array.isArray(keepOther)\n    ? unique([...keepOther, ...persistentSortedColumns])\n    : unique([...sorting.map(item => item.columnName), ...persistentSortedColumns]);\n};\n","import { slice } from '@devexpress/dx-core';\nimport { MergeFn, SortArrayToAuxiliaryFn, CompareFn } from '../types';\n\n/* eslint-disable no-plusplus, no-param-reassign, no-use-before-define, no-constant-condition */\n/* tslint:disable no-increment-decrement */\n\nconst merge: MergeFn = (array, auxiliary, lo, mid, hi, compare) => {\n  let i = lo;\n  let j = mid + 1;\n  let k = lo;\n  while (true) {\n    const cmp = compare(array[i], array[j]);\n    if (cmp <= 0) {\n      auxiliary[k++] = array[i++];\n      if (i > mid) {\n        do {\n          auxiliary[k++] = array[j++];\n        } while (j <= hi);\n        break;\n      }\n    } else {\n      auxiliary[k++] = array[j++];\n      if (j > hi) {\n        do {\n          auxiliary[k++] = array[i++];\n        } while (i <= mid);\n        break;\n      }\n    }\n  }\n};\n\nconst sortArrayToAuxiliary: SortArrayToAuxiliaryFn = (array, auxiliary, lo, hi, compare) => {\n  if (hi < lo) return;\n  if (hi === lo) {\n    auxiliary[lo] = array[lo];\n    return;\n  }\n  const mid = Math.floor(lo + ((hi - lo) / 2));\n  sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);\n  sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);\n  merge(array, auxiliary, lo, mid, hi, compare);\n};\n\nconst sortAuxiliaryToArray: SortArrayToAuxiliaryFn = (array, auxiliary, lo, hi, compare) => {\n  if (hi <= lo) return;\n  const mid = Math.floor(lo + ((hi - lo) / 2));\n  sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);\n  sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);\n  merge(auxiliary, array, lo, mid, hi, compare);\n};\n\nexport default (\n  array: any[] | ReadonlyArray<any>,\n  compare: CompareFn = (a, b): number => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  },\n) => {\n  const result = slice(array);\n  const auxiliary = slice(array);\n  sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);\n  return result;\n};\n","import { RowsToTreeFn, TreeToRowsFn, TreeNode } from '../types';\n\nexport const NODE_CHECK = Symbol('node');\n\nexport const rowsToTree: RowsToTreeFn = (rows, getRowLevelKey) => {\n  if (!rows.length) return rows;\n\n  const levels: any[] = [{ children: [] }];\n\n  rows.forEach((row) => {\n    const levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      const levelIndex = levels.slice(1)\n        .findIndex(level => getRowLevelKey(level.root) === levelKey) + 1;\n      if (levelIndex > 0) {\n        levels.splice(levelIndex, levels.length - levelIndex);\n      }\n      const node = { [NODE_CHECK]: true, root: row, children: [] };\n      levels[levels.length - 1].children.push(node);\n      levels.push(node);\n    } else {\n      levels[levels.length - 1].children.push(row);\n    }\n  });\n\n  return levels[0].children;\n};\n\nexport const treeToRows: TreeToRowsFn = (tree, rows = []) => {\n  if (!tree.length) return tree;\n  return tree.reduce(\n    (acc, node) => {\n      if (node[NODE_CHECK]) {\n        acc.push(node.root);\n        treeToRows(node.children, rows);\n      } else {\n        acc.push(node);\n      }\n      return acc;\n    },\n    rows as TreeNode[],\n  );\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport mergeSort from '../../utils/merge-sort';\nimport { NODE_CHECK, rowsToTree, treeToRows } from '../../utils/hierarchical-data';\nimport {\n  Row, GetRowLevelKeyFn, CompareFn, CreateCompareFn, SortedRowsFn, TreeNode,\n} from '../../types';\n\nconst defaultCompare = (a: any, b: any) => {\n  if (a === b) return 0;\n\n  if (a === null) {\n    return b === undefined ? -1 : 1;\n  }\n  if (a === undefined) {\n    return 1;\n  }\n  if (b === null || b === undefined) {\n    return -1;\n  }\n  return a < b ? -1 : 1;\n};\n\nconst createCompare: CreateCompareFn = (\n  sorting, getColumnCompare, getComparableValue,\n) => sorting.reduceRight((prevCompare, columnSorting) => {\n  const { columnName } = columnSorting;\n  const inverse = columnSorting.direction === 'desc';\n  const columnCompare = (getColumnCompare && getColumnCompare(columnName)) || defaultCompare;\n\n  return (aRow: Row, bRow: Row) => {\n    const a = getComparableValue(aRow, columnName);\n    const b = getComparableValue(bRow, columnName);\n    const result = columnCompare(a, b);\n\n    if (result !== 0) {\n      return inverse ? -result : result;\n    }\n    return prevCompare(aRow, bRow);\n  };\n}, (...args: any[]) => 0);\n\nconst sortTree: PureComputed<[TreeNode[], CompareFn]> = (tree, compare) => {\n  const sortedTree = tree.map((node) => {\n    if (node[NODE_CHECK]) {\n      return {\n        ...node,\n        children: sortTree(node.children, compare),\n      };\n    }\n    return node;\n  });\n\n  return mergeSort(\n    sortedTree, (a, b) => compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b),\n  );\n};\n\nconst sortHierarchicalRows: PureComputed<[Row[], CompareFn, GetRowLevelKeyFn]> = (\n  rows, compare, getRowLevelKey,\n) => {\n  const tree = rowsToTree(rows, getRowLevelKey);\n\n  const sortedTree = sortTree(tree, compare);\n\n  return treeToRows(sortedTree);\n};\n\nexport const sortedRows: SortedRowsFn = (\n  rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey,\n) => {\n  if (!sorting.length || !rows.length) return rows;\n\n  let compare;\n  if (!getRowLevelKey) {\n    compare = createCompare(sorting, getColumnCompare, getCellValue);\n    return mergeSort(rows.slice(), compare);\n  }\n\n  compare = createCompare(sorting, getColumnCompare, (row, columnName) => {\n    if (isGroupRow && isGroupRow(row)) {\n      if (row.groupedBy === columnName) {\n        return row.value;\n      }\n      return undefined;\n    }\n    return getCellValue(row, columnName);\n  });\n  return sortHierarchicalRows(\n    rows,\n    compare,\n    getRowLevelKey,\n  );\n};\n","import { Filter, ChangeFilterPayload } from '../../types';\nimport { PureReducer, slice } from '@devexpress/dx-core';\n\nexport const changeColumnFilter: PureReducer<Filter[], ChangeFilterPayload> = (\n  filters, { columnName, config },\n) => {\n  const filterIndex = filters.findIndex(f => f.columnName === columnName);\n  const nextState = slice(filters);\n\n  if (config) {\n    const filter = { columnName, ...config };\n    if (filterIndex > -1) {\n      nextState.splice(filterIndex, 1, filter);\n    } else {\n      nextState.push(filter);\n    }\n  } else if (filterIndex > -1) {\n    nextState.splice(filterIndex, 1);\n  }\n\n  return nextState;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { Filter } from '../../types';\n\nexport const getColumnFilterConfig: PureComputed<\n  [Filter[], string], Filter | null\n> = (filters, columnName) => (\n  filters.length && filters.filter(s => s.columnName === columnName)[0] || null\n);\n","import { FilterExpression, Filter } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nexport const filterExpression: PureComputed<\n  [Filter[], FilterExpression?], FilterExpression\n> = (filters, expression) => {\n  // tslint:disable-next-line: no-object-literal-type-assertion\n  const selfFilterExpr = { filters, operator: 'and' as 'and' } as FilterExpression;\n  if (!expression) {\n    return selfFilterExpr;\n  }\n  return {\n    operator: 'and' as 'and',\n    filters: [expression, selfFilterExpr] as FilterExpression[],\n  };\n};\n","import { NODE_CHECK, rowsToTree, treeToRows } from '../../utils/hierarchical-data';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  Row, Filter, FilterPredicate,\n  FilterExpression, GetCellValueFn, RowsWithCollapsedRowsMetaMap,\n  UnwrapRowsComputed, FilteredRowsFn, FilterHierarchicalRowsFn,\n  CompiledPredicate, GetColumnPredicateFn, FilteredCollapsedRowsGetterFn, TreeNode,\n} from '../../types';\n\nconst operators = {\n  or: (predicates: CompiledPredicate[]) => (row: Row) => (\n    predicates.reduce((acc, predicate) => acc || predicate(row), false)\n  ),\n  and: (predicates: CompiledPredicate[]) => (row: Row) => (\n    predicates.reduce((acc, predicate) => acc && predicate(row), true)\n  ),\n};\n\nconst toLowerCase = (value: any) => String(value).toLowerCase();\n\nconst operationPredicates: { [key: string]: FilterPredicate } = {\n  contains: (value, filter) => toLowerCase(value)\n    .indexOf(toLowerCase(filter.value)) > -1,\n\n  notContains: (value, filter) => toLowerCase(value)\n    .indexOf(toLowerCase(filter.value)) === -1,\n\n  startsWith: (value, filter) => toLowerCase(value)\n    .startsWith(toLowerCase(filter.value)),\n\n  endsWith: (value, filter) => toLowerCase(value)\n    .endsWith(toLowerCase(filter.value)),\n\n  equal: (value, filter) => String(value) === String(filter.value),\n  notEqual: (value, filter) => String(value) !== String(filter.value),\n\n  greaterThan: (value, filter) => value > filter.value!,\n  greaterThanOrEqual: (value, filter) => value >= filter.value!,\n  lessThan: (value, filter) => value < filter.value!,\n  lessThanOrEqual: (value, filter) => value <= filter.value!,\n};\n\nexport const defaultFilterPredicate: FilterPredicate = (value, filter) => {\n  const operation = filter.operation || 'contains';\n  return operationPredicates[operation](value, filter);\n};\n\nconst filterTree: PureComputed<[TreeNode[], CompiledPredicate]> = (tree, predicate) => tree.reduce(\n  (acc, node) => {\n    if (node[NODE_CHECK]) {\n      const filteredChildren = filterTree(node.children, predicate) as TreeNode[];\n      if (filteredChildren.length > 0) {\n        acc.push({\n          ...node,\n          children: filteredChildren,\n        });\n        return acc;\n      }\n      if (predicate(node.root, true)) {\n        acc.push(node.root);\n        return acc;\n      }\n      return acc;\n    }\n\n    if (predicate(node)) {\n      acc.push(node);\n      return acc;\n    }\n\n    return acc;\n  },\n  [] as TreeNode[],\n);\n\nconst filterHierarchicalRows: FilterHierarchicalRowsFn = (\n  rows, predicate, getRowLevelKey, getCollapsedRows,\n) => {\n  const tree = rowsToTree(rows, getRowLevelKey);\n  const collapsedRowsMeta: any[] = [];\n\n  const filteredTree = filterTree(tree, (row, isNode) => {\n    if (isNode) {\n      const collapsedRows = getCollapsedRows && getCollapsedRows(row);\n      if (collapsedRows && collapsedRows.length) {\n        const filteredCollapsedRows = collapsedRows.filter(predicate);\n        collapsedRowsMeta.push([row, filteredCollapsedRows]);\n        return !!filteredCollapsedRows.length || predicate(row);\n      }\n      if (predicate(row)) {\n        collapsedRowsMeta.push([row, []]);\n        return true;\n      }\n      return false;\n    }\n    return predicate(row);\n  });\n\n  return { rows: treeToRows(filteredTree), collapsedRowsMeta: new Map(collapsedRowsMeta) };\n};\n\nconst buildPredicate: PureComputed<\n  [FilterExpression, GetCellValueFn, GetColumnPredicateFn],\n  CompiledPredicate\n> = (\n  initialFilterExpression, getCellValue, getColumnPredicate,\n) => {\n  const getSimplePredicate = (filter: Filter) => {\n    const { columnName } = filter;\n    const customPredicate = getColumnPredicate && getColumnPredicate(columnName);\n    const predicate = customPredicate || defaultFilterPredicate;\n    return (row: Row) => predicate(getCellValue(row, columnName), filter, row);\n  };\n\n  const getOperatorPredicate: any = (filterExpression: FilterExpression) => {\n    const build = operators[toLowerCase(filterExpression.operator)];\n    return build && build(filterExpression.filters.map(getPredicate));\n  };\n\n  const getPredicate = (filterExpression: any) => (\n    getOperatorPredicate(filterExpression)\n    || getSimplePredicate(filterExpression)\n  );\n\n  return getPredicate(initialFilterExpression);\n};\n\nexport const filteredRows: FilteredRowsFn = (\n  rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows,\n) => {\n  if (!(filterExpression && Object.keys(filterExpression).length && rows.length)) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return { rows } as Partial<RowsWithCollapsedRowsMetaMap>;\n  }\n\n  const predicate = buildPredicate(\n    filterExpression,\n    getCellValue,\n    getColumnPredicate,\n  );\n\n  return getRowLevelKey\n    ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows)\n    : { rows: rows.filter(predicate) };\n};\n\nexport const filteredCollapsedRowsGetter: FilteredCollapsedRowsGetterFn = (\n  { collapsedRowsMeta },\n) => row => collapsedRowsMeta && collapsedRowsMeta.get(row);\n\nexport const unwrappedFilteredRows: UnwrapRowsComputed = ({ rows }) => rows;\n","export const GROUP_KEY_SEPARATOR = '|';\n","import { PureReducer, slice } from '@devexpress/dx-core';\nimport { Getters } from '@devexpress/dx-react-core';\nimport { GROUP_KEY_SEPARATOR } from './constants';\nimport {\n  Grouping, ColumnGroupingState, ChangeGroupingPayload, ToggleGroupPayload, DraftGroupingState,\n} from '../../types';\n\nconst applyColumnGrouping: PureReducer<Grouping[], ChangeGroupingPayload> = (\n  grouping, { columnName, groupIndex },\n) => {\n  let nextGrouping = grouping;\n  const groupingIndex = nextGrouping.findIndex(g => g.columnName === columnName);\n  let targetIndex = groupIndex;\n\n  if (groupingIndex > -1) {\n    nextGrouping = slice(grouping);\n    (nextGrouping as Grouping[]).splice(groupingIndex, 1);\n  } else if (groupIndex === undefined) {\n    targetIndex = nextGrouping.length;\n  }\n\n  if (targetIndex > -1) {\n    nextGrouping = slice(nextGrouping);\n    (nextGrouping as Grouping[]).splice(targetIndex, 0, {\n      columnName,\n    });\n  }\n\n  return nextGrouping;\n};\n\nexport const changeColumnGrouping: PureReducer<ColumnGroupingState, ChangeGroupingPayload> = (\n  { grouping, expandedGroups }, { columnName, groupIndex },\n) => {\n  const nextGrouping = applyColumnGrouping(grouping!, { columnName, groupIndex });\n\n  const ungroupedColumnIndex = grouping!.findIndex(\n    (group, index) => !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName,\n  );\n  if (ungroupedColumnIndex === -1) {\n    return {\n      grouping: nextGrouping,\n    };\n  }\n\n  const filteredExpandedGroups = expandedGroups!.filter(\n    group => group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex,\n  );\n  if (filteredExpandedGroups.length === expandedGroups!.length) {\n    return {\n      grouping: nextGrouping,\n    };\n  }\n\n  return {\n    grouping: nextGrouping,\n    expandedGroups: filteredExpandedGroups,\n  };\n};\n\nexport const toggleExpandedGroups: PureReducer<ColumnGroupingState, ToggleGroupPayload> = (\n  state, { groupKey },\n) => {\n  const expandedGroups = slice(state.expandedGroups);\n  const groupKeyIndex = expandedGroups.indexOf(groupKey);\n\n  if (groupKeyIndex > -1) {\n    expandedGroups.splice(groupKeyIndex, 1);\n  } else {\n    expandedGroups.push(groupKey);\n  }\n\n  return {\n    expandedGroups,\n  };\n};\n\nexport const draftColumnGrouping: PureReducer<\n  Getters, ChangeGroupingPayload, DraftGroupingState\n> = (\n  { grouping, draftGrouping },\n  { columnName, groupIndex },\n) => ({\n  draftGrouping: applyColumnGrouping(draftGrouping || grouping, { columnName, groupIndex }),\n});\n\nexport const cancelColumnGroupingDraft = () => ({\n  draftGrouping: null,\n});\n","import { PureComputed } from '@devexpress/dx-core';\nimport { Grouping, Sorting, GroupIndex } from '../../types';\n\nexport const adjustSortIndex: PureComputed<[GroupIndex, Grouping[], Sorting[]]> = (\n  groupingIndex, grouping, sorting,\n) => Math.max(\n  grouping.slice(0, groupingIndex).reduce(\n    (acc, columnGrouping) => {\n      const columnSortingIndex = sorting.findIndex(\n        columnSorting => columnSorting.columnName === columnGrouping.columnName,\n      );\n      return (columnSortingIndex === -1 ? acc - 1 : acc);\n    },\n    groupingIndex,\n  ),\n  0,\n);\n","import { GetIntegratedGroupsFn, GetGroupRowsFn, Row } from '../../types';\nimport { GROUP_KEY_SEPARATOR } from '../grouping-state/constants';\nimport { GRID_GROUP_CHECK, GRID_GROUP_LEVEL_KEY, GRID_GROUP_TYPE } from './constants';\n\nconst defaultColumnCriteria = (value: any) => ({\n  value,\n  key: String(value),\n});\n\nexport const getGroupRows: GetGroupRowsFn = (\n  rows, grouping, groupsGetter,\n) => {\n  if (grouping.length === 0) {\n    return rows;\n  }\n\n  const keyPrefixes = [{ prefix: '', level: 0, rows }];\n  const resultRows = [] as Row[];\n  const compoundKeys = {};\n\n  while (keyPrefixes.length) {\n    const { prefix: keyPrefix, level, rows: currentRows } = keyPrefixes.pop()!;\n\n    const currentCompoundKey = keyPrefix.slice(0, keyPrefix.length - 1);\n    const groupIndex = compoundKeys[currentCompoundKey] ?? -1;\n\n    const groupRows: readonly Row[] = grouping[level] && currentRows.length\n      ? groupsGetter(currentRows, grouping[level], keyPrefix)\n          .map(({ childRows, ...params }: any, rowIndex) => {\n            const { compoundKey } = params;\n\n            compoundKeys[compoundKey] = groupIndex + rowIndex + 1;\n            keyPrefixes.push({\n              prefix: `${compoundKey}${GROUP_KEY_SEPARATOR}`,\n              level: level + 1,\n              rows: childRows || [],\n            });\n\n            return params;\n          })\n      : currentRows;\n\n    if (groupIndex > -1) {\n      resultRows.splice(groupIndex + 1, 0, ...groupRows);\n    } else {\n      groupRows.forEach(row => resultRows.push(row));\n    }\n  }\n\n  return resultRows;\n};\n\nexport const getIntegratedGroups: GetIntegratedGroupsFn = (\n  rows,\n  grouping,\n  keyPrefix,\n  getCellValue,\n  getColumnCriteria,\n) => {\n  const { columnName } = grouping;\n  const groupCriteria = (getColumnCriteria && getColumnCriteria(columnName))\n        || defaultColumnCriteria;\n\n  const groups = new Map();\n  rows.forEach((row) => {\n    const rawValue = getCellValue(row, columnName);\n    const { key, value } = groupCriteria(rawValue, row);\n    const sameKeyItems = groups.get(key);\n\n    if (!sameKeyItems) {\n      const groupingValue = value === rawValue ? value : value || key;\n      groups.set(key, [groupingValue, key, [row]]);\n    } else {\n      sameKeyItems[2].push(row);\n    }\n  });\n\n  const groupedBy = columnName;\n  return [...groups.values()]\n    .map(([value, key, childRows]) => ({\n      groupedBy,\n      compoundKey: `${keyPrefix}${key}`,\n      key,\n      value,\n      [GRID_GROUP_CHECK]: true,\n      [GRID_GROUP_LEVEL_KEY]: `${GRID_GROUP_TYPE.toString()}_${groupedBy}`,\n      childRows,\n    }));\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  GRID_GROUP_CHECK,\n  GRID_GROUP_LEVEL_KEY,\n  GRID_GROUP_COLLAPSED_ROWS,\n} from './constants';\nimport {\n  Grouping,\n  GroupKey,\n  Row,\n  GetCollapsedRowsFn,\n  IsSpecificRowFn,\n  GroupedRowsFn,\n  GroupsGetterFn,\n} from '../../types';\nimport { getGroupRows, getIntegratedGroups } from './helpers';\n\nexport const groupRowChecker: IsSpecificRowFn = row => row[GRID_GROUP_CHECK];\n\nexport const groupRowLevelKeyGetter = (row: Row) => (row ? row[GRID_GROUP_LEVEL_KEY] : undefined);\n\nexport const groupedRows: GroupedRowsFn = (\n  rows, grouping, getCellValue, getColumnCriteria,\n) => {\n  const groupsGetter: GroupsGetterFn = (currentRows, currentGrouping, prefix) =>\n    getIntegratedGroups(\n      currentRows,\n      currentGrouping,\n      prefix,\n      getCellValue,\n      getColumnCriteria,\n    );\n  return getGroupRows(rows, grouping, groupsGetter);\n};\n\nexport const expandedGroupRows: PureComputed<[Row[], Grouping[], GroupKey[], boolean]> = (\n  rows,\n  grouping,\n  expandedGroups,\n  isExporting,\n) => {\n  if (!grouping.length) return rows;\n\n  const groupingColumnNames = grouping.map(columnGrouping => columnGrouping.columnName);\n  const expandedGroupsSet = new Set(expandedGroups);\n  let currentGroupExpanded = true;\n  let currentGroupLevel = 0;\n\n  return rows.reduce((acc, row) => {\n    if (!row[GRID_GROUP_CHECK]) {\n      if (currentGroupExpanded) {\n        acc.push(row);\n      } else {\n        acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);\n      }\n      return acc;\n    }\n\n    const groupLevel = groupingColumnNames.indexOf(row.groupedBy);\n    if (groupLevel > currentGroupLevel && !currentGroupExpanded) {\n      return acc;\n    }\n\n    currentGroupExpanded = expandedGroupsSet.has(row.compoundKey) || isExporting;\n    currentGroupLevel = groupLevel;\n\n    if (currentGroupExpanded) {\n      acc.push(row);\n    } else {\n      acc.push({\n        ...row,\n        [GRID_GROUP_COLLAPSED_ROWS]: [],\n      });\n    }\n\n    return acc;\n  }, []);\n};\n\nexport const groupCollapsedRowsGetter: PureComputed<[GetCollapsedRowsFn]> =\n  getCollapsedRows => row => (\n  row[GRID_GROUP_COLLAPSED_ROWS] || (getCollapsedRows && getCollapsedRows(row))\n);\n","import { GetCustomGroupsFn } from '../../types';\nimport {\n  GRID_GROUP_CHECK,\n  GRID_GROUP_LEVEL_KEY,\n  GRID_GROUP_TYPE,\n} from '../integrated-grouping/constants';\n\nexport const getCustomGroups: GetCustomGroupsFn = (\n  rows,\n  grouping,\n  keyPrefix,\n  getChildGroups,\n  rootRows,\n) => {\n  const groupedBy = grouping.columnName;\n  return getChildGroups(rows as any[], grouping, rootRows as any[])\n    .map(({ key, value = key, childRows }) => ({\n      groupedBy,\n      compoundKey: `${keyPrefix}${key}`,\n      key,\n      value,\n      [GRID_GROUP_CHECK]: true,\n      [GRID_GROUP_LEVEL_KEY]: `${GRID_GROUP_TYPE.toString()}_${groupedBy}`,\n      childRows,\n    }));\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { GRID_GROUP_CHECK } from '../integrated-grouping/constants';\nimport { GetRowIdFn, Row, RowId, CustomGroupedRowsFn, GroupsGetterFn } from '../../types';\nimport { getCustomGroups } from './helpers';\nimport { getGroupRows } from '../integrated-grouping/helpers';\n\nexport const customGroupedRows: CustomGroupedRowsFn = (\n  rows, grouping, getChildGroups, rootRows = rows,\n) => {\n  const groupsGetter: GroupsGetterFn = (currentRows, currentGrouping, prefix) =>\n    getCustomGroups(\n      currentRows,\n      currentGrouping,\n      prefix,\n      getChildGroups,\n      rootRows,\n    );\n  return getGroupRows(rows, grouping, groupsGetter);\n};\n\nexport const customGroupingRowIdGetter: PureComputed<[GetRowIdFn, Row[]]> = (getRowId, rows) => {\n  const firstRow = rows.find(row => !row[GRID_GROUP_CHECK]);\n  if (!firstRow || getRowId(firstRow) !== undefined) {\n    return getRowId;\n  }\n\n  const map = new Map<Row, RowId>(rows\n    .filter(row => !row[GRID_GROUP_CHECK])\n    .map((row, rowIndex) => [row, rowIndex]) as [Row, RowId]);\n\n  return row => map.get(row)!;\n};\n","import { GroupingPanelItemsFn } from '../../types/';\n\nexport const groupingPanelItems: GroupingPanelItemsFn = (\n  columns, grouping, draftGrouping,\n) => {\n  const items = draftGrouping.map(({ columnName }) => ({\n    column: columns.find(c => c.name === columnName)!,\n    draft: !grouping.some(columnGrouping => columnGrouping.columnName === columnName),\n  }));\n\n  grouping.forEach(({ columnName }, index) => {\n    if (draftGrouping.some(columnGrouping => columnGrouping.columnName === columnName)) return;\n    items.splice(index, 0, {\n      column: columns.find(c => c.name === columnName)!,\n      draft: true,\n    });\n  });\n\n  return items;\n};\n","export const setCurrentPage = (prevPage: number, page: number) => page;\nexport const setPageSize = (prevPageSize: number, size: number) => size;\n","import { PureComputed } from '@devexpress/dx-core';\n\nexport const clamp: PureComputed<[number, number]> = (value, max) => (\n  Math.max(Math.min(value, max), 0)\n);\n","import { clamp } from './helpers';\nimport { Row, GetRowLevelKeyFn, CurrentPageFn } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\n// tslint:disable-next-line:max-line-length\nconst PAGE_HEADERS_OVERFLOW_ERROR = 'Max row level exceeds the page size. Consider increasing the page size.';\n\nexport const paginatedRows: PureComputed<[Row[], number, number]> = (rows, pageSize, page) => (\n  pageSize\n    ? rows.slice(pageSize * page, pageSize * (page + 1))\n    : rows as Row[]\n);\n\nexport const rowsWithPageHeaders: PureComputed<[Row[], number, GetRowLevelKeyFn]> = (\n  rows, pageSize, getRowLevelKey,\n) => {\n  if (!pageSize || !getRowLevelKey) return rows as Row[];\n\n  let result = rows.slice();\n\n  let headerRows: any[] = [];\n  let currentIndex = 0;\n  while (result.length > currentIndex) {\n    const row = result[currentIndex];\n    const levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      const headerIndex = headerRows.findIndex(headerRow => getRowLevelKey(headerRow) === levelKey);\n      // tslint:disable-next-line:prefer-conditional-expression\n      if (headerIndex === -1) {\n        headerRows = [...headerRows, row];\n      } else {\n        headerRows = [...headerRows.slice(0, headerIndex), row];\n      }\n      if (headerRows.length >= pageSize) {\n        throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);\n      }\n    }\n    const indexInPage = currentIndex % pageSize;\n    if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {\n      result = [\n        ...result.slice(0, currentIndex),\n        headerRows[indexInPage],\n        ...result.slice(currentIndex),\n      ];\n    }\n    currentIndex += 1;\n  }\n\n  return result;\n};\n\nexport const rowCount = (rows: Row[]) => rows.length;\n\nexport const pageCount: PureComputed<[number, number]> = (count, pageSize) => (\n  pageSize ? Math.ceil(count / pageSize) : 1\n);\n\nexport const currentPage: CurrentPageFn = (\n  page, totalCount, pageSize, setCurrentPage,\n) => {\n  const totalPages = pageCount(totalCount, pageSize);\n  const adjustedCurrentPage = clamp(page, totalPages - 1);\n  if (page !== adjustedCurrentPage) {\n    setTimeout(() => setCurrentPage(adjustedCurrentPage));\n  }\n  return adjustedCurrentPage;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { NthRowOnPageFn } from '../../types';\n\nexport const firstRowOnPage: NthRowOnPageFn = (currentPage, pageSize, totalCount) => {\n  if (totalCount === 0) {\n    return 0;\n  }\n  return pageSize ? (currentPage * pageSize) + 1 : 1;\n};\n\nexport const lastRowOnPage: NthRowOnPageFn = (currentPage, pageSize, totalRowCount) => {\n  let result = totalRowCount;\n  if (pageSize) {\n    const index = (currentPage + 1) * pageSize;\n    result = index > totalRowCount ? totalRowCount : index;\n  }\n\n  return result;\n};\n\nexport const calculateStartPage: PureComputed<[number, number, number]> = (\n  currentPage, maxButtonCount, totalPageCount,\n) => (\n  Math.max(\n    Math.min(\n    currentPage - Math.floor(maxButtonCount / 2),\n      (totalPageCount - maxButtonCount) + 1,\n    ),\n    1,\n  )\n);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { RowId } from '../types';\n\nexport const toggle: PureComputed<[RowId[], RowId[], boolean?]> = (\n  source, items, state?,\n) => {\n  const itemsSet = new Set(items);\n\n  let sourceState: any = state;\n  if (sourceState === undefined) {\n    const availableSelection = source.filter(item => itemsSet.has(item));\n    sourceState = availableSelection.length !== itemsSet.size;\n  }\n\n  if (sourceState) {\n    const sourceSet = new Set(source);\n    return [\n      ...source,\n      ...items.filter(item => !sourceSet.has(item)),\n    ];\n  }\n\n  return source.filter(item => !itemsSet.has(item));\n};\n","import { toggle } from '../../utils/common-reducers';\nimport { ToggleRowsFieldReducer } from '../../types';\n\nexport const toggleSelection: ToggleRowsFieldReducer = (\n  selection, { rowIds, state },\n) => toggle(selection, rowIds, state);\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  RowsWithSelection, UnwrapRowsComputed, RowId, RowsWithAvailableToSelectFn,\n} from '../../types';\n\ntype RowsSelectedFn = PureComputed<[RowsWithSelection, RowId[]], boolean>;\n\nexport const rowsWithAvailableToSelect: RowsWithAvailableToSelectFn = (\n  rows, getRowId, isGroupRow,\n) => {\n  let dataRows = rows;\n  if (isGroupRow) {\n    dataRows = dataRows.filter(row => !isGroupRow(row));\n  }\n  return { rows, availableToSelect: dataRows.map(row => getRowId(row)) };\n};\n\nexport const someSelected: RowsSelectedFn = ({ availableToSelect }, selection) => {\n  const selectionSet = new Set(selection);\n\n  return availableToSelect.length !== 0 && selectionSet.size !== 0\n    && availableToSelect.some(elem => selectionSet.has(elem))\n    && availableToSelect.some(elem => !selectionSet.has(elem));\n};\n\nexport const allSelected: RowsSelectedFn = ({ availableToSelect }, selection) => {\n  const selectionSet = new Set(selection);\n\n  return selectionSet.size !== 0 && availableToSelect.length !== 0\n    && !availableToSelect.some(elem => !selectionSet.has(elem));\n};\n\nexport const unwrapSelectedRows: UnwrapRowsComputed = ({ rows }) => rows;\n","import { PureReducer } from '@devexpress/dx-core';\nimport { RowId, Row, RowIdsPayload, RowPayload, RowChangePayload,\n  RowChanges, EditingCell, EditingCellsPayload,\n} from '../../types';\n\nexport const startEditRows: PureReducer<RowId[], RowIdsPayload> = (\n  prevEditingRowIds, { rowIds },\n) => [...prevEditingRowIds, ...rowIds];\n\nexport const stopEditRows: PureReducer<RowId[], RowIdsPayload> = (\n  prevEditingRowIds, { rowIds },\n) => {\n  const rowIdSet = new Set(rowIds);\n  return prevEditingRowIds.filter(id => !rowIdSet.has(id));\n};\n\nexport const startEditCells: PureReducer<EditingCell[], EditingCellsPayload> = (\n  prevEditingCells, { editingCells },\n) => [...prevEditingCells, ...editingCells];\n\nexport const stopEditCells: PureReducer<EditingCell[], EditingCellsPayload> = (\n  prevEditingCells, { editingCells },\n) => {\n  return prevEditingCells.filter(({ rowId, columnName }) => (\n    !editingCells.some(({ rowId: currentRowId, columnName: currentColumnName }) => (\n      currentRowId === rowId && currentColumnName === columnName\n    ))\n  ));\n};\n\nexport const addRow: PureReducer<Row[], RowPayload> = (\n  addedRows, { row } = { row: {} },\n) => [...addedRows, row];\n\nexport const changeAddedRow: PureReducer<Row[], RowChangePayload> = (\n  addedRows, { rowId, change },\n) => {\n  const result = addedRows.slice();\n  result[rowId] = { ...result[rowId], ...change };\n  return result;\n};\n\nexport const cancelAddedRows: PureReducer<Row[], RowIdsPayload> = (addedRows, { rowIds }) => {\n  const result: Row[] = [];\n  const indexSet = new Set(rowIds);\n  addedRows.forEach((row, index) => {\n    if (!indexSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\n\nexport const changeRow: PureReducer<RowChanges, RowChangePayload> = (\n  prevRowChanges, { rowId, change },\n) => {\n  const prevChange = prevRowChanges[rowId] || {};\n  return {\n    ...prevRowChanges,\n    [rowId]: {\n      ...prevChange,\n      ...change,\n    },\n  };\n};\n\nexport const cancelChanges: PureReducer<RowChanges, RowIdsPayload> = (\n  prevRowChanges, { rowIds },\n) => {\n  const result = { ...prevRowChanges };\n  rowIds.forEach((rowId) => {\n    delete result[rowId];\n  });\n  return result;\n};\n\nexport const deleteRows: PureReducer<RowId[], RowIdsPayload> = (deletedRowIds, { rowIds }) => [\n  ...deletedRowIds, ...rowIds,\n];\n\nexport const cancelDeletedRows: PureReducer<RowId[], RowIdsPayload> = (\n  deletedRowIds, { rowIds },\n) => {\n  const rowIdSet = new Set(rowIds);\n  return deletedRowIds.filter(rowId => !rowIdSet.has(rowId));\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  EditingColumnExtension, CreateRowChangeFn, Row, RowId, RowChanges,\n} from '../../types';\n\nexport const changedRowsByIds: PureComputed<\n  [any, RowId[]], RowChanges\n> = (changes, rowIds) => {\n  const result = {};\n  rowIds.forEach((rowId) => {\n    result[rowId] = changes[rowId];\n  });\n  return result;\n};\n\nexport const addedRowsByIds: PureComputed<[Row[], RowId[]]> = (addedRows, rowIds) => {\n  const rowIdSet = new Set(rowIds);\n  const result: Row[] = [];\n  addedRows.forEach((row, index) => {\n    if (rowIdSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\n\nconst defaultCreateRowChange: CreateRowChangeFn = (row, value, columnName) => (\n  { [columnName]: value }\n);\nexport const createRowChangeGetter: PureComputed<\n  [CreateRowChangeFn?, EditingColumnExtension[]?], CreateRowChangeFn\n> = (\n  createRowChange = defaultCreateRowChange,\n  columnExtensions = [],\n) => {\n  const map = columnExtensions.reduce((acc, columnExtension) => {\n    if (columnExtension.createRowChange) {\n      acc[columnExtension.columnName] = columnExtension.createRowChange;\n    }\n    return acc;\n  }, {});\n\n  return (row, value, columnName) => {\n    if (map[columnName]) {\n      return map[columnName](row, value, columnName);\n    }\n    return createRowChange(row, value, columnName);\n  };\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { RowId, RowChanges } from '../../types';\n\nexport const getRowChange: PureComputed<[RowChanges, RowId], any> = (\n  rowChanges, rowId,\n) => rowChanges[rowId] || {};\n","export const TABLE_REORDERING_TYPE = Symbol('reordering');\n","import { PureReducer, slice } from '@devexpress/dx-core';\nimport { ColumnOrder, ChangeColumnOrderPayload } from '../../types';\n\nexport const changeColumnOrder: PureReducer<ColumnOrder, ChangeColumnOrderPayload> = (\n  order, { sourceColumnName, targetColumnName },\n) => {\n  const sourceColumnIndex = order.indexOf(sourceColumnName);\n  const targetColumnIndex = order.indexOf(targetColumnName);\n  const newOrder = slice(order);\n\n  newOrder.splice(sourceColumnIndex, 1);\n  newOrder.splice(targetColumnIndex, 0, sourceColumnName);\n  return newOrder;\n};\n","export const TABLE_DATA_TYPE = Symbol('data');\nexport const TABLE_NODATA_TYPE = Symbol('nodata');\nexport const TABLE_FLEX_TYPE = Symbol('flex');\n","import { PureComputed, slice } from '@devexpress/dx-core';\nimport mergeSort from '../../utils/merge-sort';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_REORDERING_TYPE } from './constants';\nimport { OrderedColumnsComputed, DraftOrderComputed, TableRow } from '../../types';\n\nexport const orderedColumns: OrderedColumnsComputed = (\n  tableColumns = [], order,\n) => mergeSort(tableColumns, (a, b) => {\n  if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE) return 0;\n\n  const aPos = order.indexOf(a.column.name);\n  const bPos = order.indexOf(b.column.name);\n  return aPos - bPos;\n});\n\nexport const tableHeaderRowsWithReordering: PureComputed<[TableRow[]]> = tableHeaderRows => [\n  ...tableHeaderRows,\n  {\n    key: TABLE_REORDERING_TYPE.toString(),\n    type: TABLE_REORDERING_TYPE,\n    height: 0,\n  },\n];\n\nexport const draftOrder: DraftOrderComputed = (order, sourceColumnIndex, targetColumnIndex) => {\n  if (sourceColumnIndex === -1\n    || targetColumnIndex === -1\n    || sourceColumnIndex === targetColumnIndex) {\n    return order;\n  }\n\n  const result = slice(order);\n  const sourceColumn = order[sourceColumnIndex];\n  result.splice(sourceColumnIndex, 1);\n  result.splice(targetColumnIndex, 0, sourceColumn);\n\n  return result;\n};\n","import { ColumnSizesFn, ValidValueFn, ConvertWidthFn, ColumnWidthFn } from '../../types';\n\nconst getColumnWidth: ColumnWidthFn = (\n  columnWidths, name, {\n    columnName, cachedWidths, shift, minColumnWidth, maxColumnWidth, columnExtensions = [],\n}) => {\n  const change = name === columnName ? shift : -shift;\n  const column  = columnWidths.find(elem => elem.columnName === name)!;\n  const extension = columnExtensions.find(elem => elem.columnName === name);\n  const width = typeof column.width === 'number'\n    ? column.width\n    : cachedWidths[name];\n  const minWidth = extension && extension.minWidth! >= 0\n    ? extension.minWidth\n    : minColumnWidth;\n  const maxWidth = extension && extension.maxWidth! >= 0\n    ? extension.maxWidth\n    : maxColumnWidth;\n  const size = Math.max(\n    minWidth!,\n    Math.min(width + change, maxWidth!),\n  );\n\n  return ({ width, size });\n};\n\nexport const getColumnSizes: ColumnSizesFn = (\n  columnWidths, payload) => {\n  const { columnName, nextColumnName, resizingMode, shift } = payload;\n  const { width, size } = getColumnWidth(columnWidths, columnName, payload);\n\n  if (resizingMode === 'nextColumn') {\n    const { width: nextWidth, size: nextSize } = getColumnWidth(\n      columnWidths, nextColumnName, payload,\n    );\n\n    if (size + nextSize !== width + nextWidth) {\n      const moreThanLimit = size + nextSize > width + nextWidth;\n      const columnExpand = shift > 0;\n      if (moreThanLimit !== columnExpand) {\n        return { size, nextSize: width + nextWidth - size };\n      }\n      return { size: width + nextWidth - nextSize, nextSize };\n    }\n    return { size, nextSize };\n  }\n\n  return { size };\n};\n\nexport const isValidValue: ValidValueFn = (value, validUnits) => {\n  const numb = parseInt(value, 10);\n  const unit = numb ? value.substr(numb.toString().length) : value;\n  const sizeIsAuto = isNaN(numb) && unit === 'auto';\n  const sizeIsValid = numb >= 0 && validUnits.some(validUnit => validUnit === unit);\n  return sizeIsAuto || sizeIsValid;\n};\n\nexport const convertWidth: ConvertWidthFn = (value) => {\n  if (typeof value === 'string') {\n    const numb = parseInt(value, 10);\n    if (value.substr(numb.toString().length).length > 0) {\n      return value;\n    }\n    return numb;\n  }\n  return value;\n};\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableColumn, SpecifyWidthsFn, TableColumnsWithWidthFn, ErrorFn } from '../../types';\nimport { isValidValue, convertWidth } from './helpers';\n\nconst VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nconst NOT_FOR_WIDGET_UNITS = ['%'];\n/* tslint:disable max-line-length */\nconst COLUMN_RESIZING_ERROR = 'The columnWidths property of the TableColumnResizing plugin is given an invalid value.';\n\nconst specifyWidths: SpecifyWidthsFn = (tableColumns, widths, resizingMode, onError) => {\n  if (resizingMode !== 'widget' && resizingMode !== 'nextColumn') {\n    onError();\n  }\n  if (!widths.length) return tableColumns;\n  return tableColumns\n    .reduce((acc, tableColumn) => {\n      if (tableColumn.type === TABLE_DATA_TYPE) {\n        const columnName = tableColumn.column!.name;\n        const column = widths.find(el => el.columnName === columnName);\n        const width = column && column.width;\n        if (typeof width !== 'number') {\n          if (width === undefined) {\n            onError();\n          } else if (!isValidValue(width, VALID_UNITS)) {\n            onError();\n          } else if (resizingMode === 'widget' && isValidValue(width, NOT_FOR_WIDGET_UNITS)) {\n            onError();\n          }\n        } else if (width < 0) {\n          onError();\n        }\n        if (width === undefined) {\n          acc.push(tableColumn);\n        } else {\n          acc.push({ ...tableColumn, width: convertWidth(width) });\n        }\n      } else {\n        acc.push(tableColumn);\n      }\n      return acc;\n    }, [] as TableColumn[]);\n};\n\nexport const tableColumnsWithWidths: TableColumnsWithWidthFn = (\n  tableColumns, columnWidths, resizingMode,\n) => specifyWidths(tableColumns, columnWidths, resizingMode, throwError);\n\nexport const tableColumnsWithDraftWidths: TableColumnsWithWidthFn = (\n  tableColumns, draftColumnWidths, resizingMode,\n) => specifyWidths(tableColumns, draftColumnWidths, resizingMode, () => {});\n\nconst throwError: ErrorFn = () => {\n  throw new Error(COLUMN_RESIZING_ERROR);\n};\n","import { slice } from '@devexpress/dx-core';\nimport { ColumnWidthReducer } from '../../types';\nimport { getColumnSizes } from './helpers';\n\nexport const changeTableColumnWidth: ColumnWidthReducer = (state, payload) => {\n  const { columnWidths } = state;\n  const { columnName, nextColumnName, resizingMode } = payload;\n  const nextColumnWidth = slice(columnWidths);\n  const index = nextColumnWidth.findIndex(elem => elem.columnName === columnName);\n  const nextIndex = nextColumnWidth.findIndex(elem => elem.columnName === nextColumnName);\n  const { size, nextSize } = getColumnSizes(columnWidths, payload);\n\n  nextColumnWidth.splice(index, 1, { columnName, width: size });\n  if (resizingMode === 'nextColumn') {\n    nextColumnWidth.splice(nextIndex, 1, { columnName: nextColumnName, width: nextSize });\n  }\n  return {\n    columnWidths: nextColumnWidth,\n  };\n};\n\nexport const draftTableColumnWidth: ColumnWidthReducer = (state, payload) => {\n  const { columnWidths } = state;\n  const { columnName, nextColumnName, resizingMode } = payload;\n  const { size, nextSize } = getColumnSizes(columnWidths, payload);\n\n  if (resizingMode === 'nextColumn') {\n    return { draftColumnWidths: [\n      { columnName, width: size }, { columnName: nextColumnName, width: nextSize! },\n    ] };\n  }\n  return { draftColumnWidths: [{ columnName, width: size }] };\n};\n\nexport const cancelTableColumnWidthDraft = () => ({\n  draftColumnWidths: [],\n});\n","export const TABLE_EDIT_COMMAND_TYPE = Symbol('editCommand');\n","export const TABLE_ADDED_TYPE = Symbol('added');\nexport const TABLE_EDIT_TYPE = Symbol('edit');\n","export const TABLE_HEADING_TYPE = Symbol('heading');\n","import { TABLE_ADDED_TYPE, TABLE_EDIT_TYPE } from '../table-edit-row/constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_HEADING_TYPE } from '../table-header-row/constants';\nimport { TABLE_EDIT_COMMAND_TYPE } from './constants';\nimport { IsSpecificCellFn } from '../../types';\n\nexport const isHeadingEditCommandsTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\nexport const isEditCommandsTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE\n  || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_EDIT_COMMAND_TYPE } from './constants';\nimport { TableColumn } from '../../types';\nimport { convertWidth } from '../table-column-resizing/helpers';\n\nexport const tableColumnsWithEditing: PureComputed<[TableColumn[], number | string]> = (\n  tableColumns, width,\n) => [\n  { width: convertWidth(width),\n    key: TABLE_EDIT_COMMAND_TYPE.toString(), type: TABLE_EDIT_COMMAND_TYPE },\n  ...tableColumns];\n","import { TABLE_ADDED_TYPE, TABLE_EDIT_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { IsSpecificRowFn, IsSpecificCellFn } from '../../types';\n\nexport const isEditTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE)\n  && tableColumn.type === TABLE_DATA_TYPE;\nexport const isAddedTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_ADDED_TYPE;\nexport const isEditTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_EDIT_TYPE;\n","import { slice } from '@devexpress/dx-core';\nimport { TABLE_ADDED_TYPE, TABLE_EDIT_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableRowsWithEditingFn } from '../../types';\n\nexport const tableRowsWithEditing: TableRowsWithEditingFn = (\n  tableRows, editingRowIds, addedRows, rowHeight,\n) => {\n  const rowIds = new Set(editingRowIds);\n  const editedTableRows = tableRows\n    .map(tableRow => (\n      tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId!)\n        ? {\n          ...tableRow,\n          type: TABLE_EDIT_TYPE,\n          height: rowHeight,\n        }\n        : tableRow\n    ));\n\n  const addedTableRows = addedRows\n    .map((row, rowIndex) => ({\n      row,\n      key: `${TABLE_ADDED_TYPE.toString()}_${rowIndex}`,\n      type: TABLE_ADDED_TYPE,\n      rowId: rowIndex,\n      height: rowHeight,\n    }));\n\n  return [\n    ...slice(addedTableRows).reverse(),\n    ...editedTableRows,\n  ];\n};\n","import { TableRowsWithEditingCellsFn, TableColumnsWithEditingCellsFn } from '../../types';\nimport { TABLE_DATA_TYPE } from '../table/constants';\n\nexport const rowsWithEditingCells: TableRowsWithEditingCellsFn = (\n  tableBodyRows, editingCells,\n) => tableBodyRows.map((row) => {\n  const { rowId, type } = row;\n  if (\n    rowId !== undefined &&\n    type === TABLE_DATA_TYPE &&\n    editingCells.some(elem => elem.rowId === rowId)\n  ) {\n    return {\n      ...row,\n      hasEditCell: true,\n    };\n  }\n  return row;\n});\n\nexport const columnsWithEditingCells: TableColumnsWithEditingCellsFn = (\n  tableColumns, editingCells,\n) => tableColumns.map((tableColumn) => {\n  const columnName = tableColumn.column ? tableColumn.column.name : undefined;\n  if (columnName !== undefined && editingCells.some(elem => elem.columnName === columnName)) {\n    return {\n      ...tableColumn,\n      hasEditCell: true,\n    };\n  }\n  return tableColumn;\n});\n","export const TABLE_FILTER_TYPE = Symbol('filter');\nexport const DEFAULT_FILTER_OPERATIONS = [\n  'contains',\n  'notContains',\n  'startsWith',\n  'endsWith',\n  'equal',\n  'notEqual',\n];\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_FILTER_TYPE, DEFAULT_FILTER_OPERATIONS } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  IsSpecificCellFn, IsSpecificRowFn, FilterOperation, GetAvailableFilterOperationsFn,\n  GetSelectedFilterOperationFn,\n} from '../../types';\n\nexport const isFilterTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n\nexport const isFilterTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_FILTER_TYPE;\n\nexport const getColumnFilterOperations: PureComputed<\n  [GetAvailableFilterOperationsFn, string],\n  FilterOperation[]\n> = (\n  getAvailableFilterOperations, columnName,\n) => (getAvailableFilterOperations && getAvailableFilterOperations(columnName))\n  || DEFAULT_FILTER_OPERATIONS;\n\nexport const isFilterValueEmpty = (value: any) => value === undefined || !String(value).length;\n\nexport const getSelectedFilterOperation: GetSelectedFilterOperationFn = (\n  filterOperations, columnName, columnFilter, columnFilterOperations,\n) => {\n  if (columnFilter && columnFilter.operation) {\n    return columnFilter.operation;\n  }\n  if (filterOperations[columnName]) {\n    return filterOperations[columnName];\n  }\n  return columnFilterOperations[0];\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_FILTER_TYPE } from './constants';\nimport { TableRow } from '../../types';\n\nexport const tableHeaderRowsWithFilter: PureComputed<[TableRow[], number]> = (\n  headerRows, rowHeight,\n) => [\n  ...headerRows,\n  { key: TABLE_FILTER_TYPE.toString(), type: TABLE_FILTER_TYPE, height: rowHeight }];\n","export const TABLE_GROUP_TYPE = Symbol('group');\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  GetVisibleBoundaryWithFixedFn, VisibleBoundary, GetVisibleBoundaryFn, GetSpanBoundaryFn,\n  CollapseBoundariesFn, GetItemSizeFn, GetCollapsedColumnsFn, CollapsedColumn,\n  GetCollapsedAndStubRowsFn, GetCollapsedCellsFn, GetCollapsedGridFn, GetColumnWidthFn,\n  CalculateRowHeightFn,\n  TableColumn,\n  CollapsedCell,\n  GetColumnWidthGetterFn,\n  GetCollapsedGridsFn,\n  CollapsedRow,\n  GetColSpanFn,\n  GetSpecificRenderBoundaryFn,\n  GetRenderBoundaryFn,\n  GetRowsVisibleBoundaryFn,\n  TableRow,\n} from '../types';\nimport { TABLE_FLEX_TYPE, intervalUtil } from '..';\n\nexport const TABLE_STUB_TYPE = Symbol('stub');\n\nexport const getVisibleBoundaryWithFixed: GetVisibleBoundaryWithFixedFn = (\n  visibleBoundary, items,\n) => items.reduce((acc, item, index) => {\n  if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {\n    acc.push([index, index]);\n  }\n  return acc;\n}, [visibleBoundary] as [VisibleBoundary]);\n\nexport const getVisibleBoundary: GetVisibleBoundaryFn = (\n  items, viewportStart, viewportSize, getItemSize, skipItems, offset = 0,\n) => {\n  let start: number | undefined;\n  let end: number | undefined;\n  let index = items[0] && items[0].rowId >= skipItems[0] ? 0 : skipItems[0];\n  const itemSize = getItemSize();\n  let beforePosition = offset !== 0 ? (offset - skipItems[0]) * itemSize : 0;\n\n  const viewportEnd = viewportStart + viewportSize;\n\n  while (end === undefined && index < items.length) {\n    const item = items[index];\n    const afterPosition = beforePosition + getItemSize(item);\n    const isVisible = (beforePosition >= viewportStart && beforePosition < viewportEnd)\n      || (afterPosition > viewportStart && afterPosition <= viewportEnd)\n      || (beforePosition < viewportStart && afterPosition > viewportEnd);\n    if (isVisible && start === undefined) {\n      start = index;\n    }\n    if (!isVisible && start !== undefined) {\n      end = index - 1;\n      break;\n    }\n    index += 1;\n    beforePosition = afterPosition;\n  }\n  if (start !== undefined && end === undefined) {\n    end = index - 1;\n  }\n  end = end === undefined ? 0 : end;\n  start = start === undefined ? 0 : start;\n\n  return [start + offset, end + offset];\n};\n\nexport const getRenderBoundary: GetRenderBoundaryFn = (itemsCount, visibleBoundary, overscan) => {\n  let [start, end] = visibleBoundary;\n  start = Math.max(0, start - overscan);\n  end = Math.min(itemsCount - 1, end + overscan);\n\n  return [start, end];\n};\n\nexport const getColumnBoundaries: PureComputed<\n  [TableColumn[], number, number, GetColumnWidthFn], VisibleBoundary[]\n> = (columns, left, width, getColumnWidth) => (\n  getVisibleBoundaryWithFixed(\n    getColumnsRenderBoundary(\n      columns.length,\n      getVisibleBoundary(columns, left, width, getColumnWidth, [0, 0], 0),\n    ),\n    columns,\n  )\n);\nexport const getRowsVisibleBoundary: GetRowsVisibleBoundaryFn = (\n  rows, top, height, getRowHeight, skipItems, offset, isDataRemote,\n) => {\n  const rowHeight = getRowHeight();\n  const beforePosition = offset !== 0 ? (offset - skipItems[0]) * rowHeight : 0;\n  const noVisibleRowsLoaded = rowHeight > 0 &&\n    beforePosition + rows.length * rowHeight < top ||\n    top < beforePosition;\n\n  let boundaries;\n  if (isDataRemote && noVisibleRowsLoaded) {\n    const topIndex = Math.round(top / rowHeight) + skipItems[0];\n    boundaries = [topIndex, topIndex];\n  } else {\n    boundaries = getVisibleBoundary(rows, top, height, getRowHeight, skipItems, offset);\n  }\n\n  return boundaries;\n};\n\nexport const getColumnsRenderBoundary: GetSpecificRenderBoundaryFn = (\n  columnCount, visibleBoundary,\n) => getRenderBoundary(columnCount, visibleBoundary, 1);\n\nexport const getRowsRenderBoundary: GetSpecificRenderBoundaryFn = (\n  rowsCount, visibleBoundary,\n) => getRenderBoundary(rowsCount, visibleBoundary, 3);\n\nexport const getSpanBoundary: GetSpanBoundaryFn = (\n  items, visibleBoundaries, getItemSpan,\n) => visibleBoundaries\n  .map((visibleBoundary) => {\n    const endIndex = Math.min(visibleBoundary[1], items.length - 1);\n    let end = endIndex;\n    let start = visibleBoundary[0] <= end ? visibleBoundary[0] : 0;\n\n    for (let index = 0; index <= endIndex; index += 1) {\n      const span = getItemSpan(items[index]);\n      if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {\n        start = index;\n      }\n      if (index + (span - 1) > visibleBoundary[1]) {\n        end = index + (span - 1);\n      }\n    }\n    return [start, end] as VisibleBoundary;\n  });\n\nexport const collapseBoundaries: CollapseBoundariesFn = (\n  itemsCount, visibleBoundaries, spanBoundaries,\n) => {\n  const breakpoints = new Set([0, itemsCount]);\n  spanBoundaries.forEach(rowBoundaries => rowBoundaries\n    .forEach((boundary) => {\n      breakpoints.add(boundary[0]);\n      // next interval starts after span end point\n      breakpoints.add(Math.min(boundary[1] + 1, itemsCount));\n    }));\n\n  visibleBoundaries\n    .filter(boundary => boundary.every(bound => 0 <= bound && bound < itemsCount))\n    .forEach((boundary) => {\n      for (let point = boundary[0]; point <= boundary[1]; point += 1) {\n        breakpoints.add(point);\n      }\n      if (boundary[1] + 1 < itemsCount) {\n        // close last visible point\n        breakpoints.add(boundary[1] + 1);\n      }\n    });\n\n  const bp = [...breakpoints].sort((a, b) => a - b);\n  const bounds: any[] = [];\n  for (let i = 0; i < bp.length - 1; i += 1) {\n    bounds.push([\n      bp[i],\n      bp[i + 1] - 1,\n    ]);\n  }\n\n  return bounds;\n};\n\nconst getItemsSize: GetItemSizeFn = (items, startIndex, endIndex, getItemSize) => {\n  let size = 0;\n  for (let i = startIndex; i <= endIndex; i += 1) {\n    size += getItemSize(items[i]);\n  }\n  return size;\n};\n\nexport const getCollapsedColumns: GetCollapsedColumnsFn = (\n  columns, visibleBoundaries, boundaries, getColumnWidth,\n) => {\n  const collapsedColumns: CollapsedColumn[] = [];\n  boundaries.forEach((boundary) => {\n    const isVisible = visibleBoundaries.reduce((acc, visibleBoundary) => (\n      acc || (visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1])\n    ), false);\n\n    if (isVisible) {\n      const column = columns[boundary[0]];\n      collapsedColumns.push({\n        ...column,\n        width: getColumnWidth(column),\n      });\n    } else {\n      collapsedColumns.push({\n        key: `${TABLE_STUB_TYPE.toString()}_${boundary[0]}_${boundary[1]}`,\n        type: TABLE_STUB_TYPE,\n        width: getItemsSize(columns, boundary[0], boundary[1], getColumnWidth),\n      });\n    }\n  });\n  return collapsedColumns;\n};\n\nexport const getCollapsedRows: GetCollapsedAndStubRowsFn = (\n  rows, visibleBoundary, boundaries, skipItems, getRowHeight, getCells, offset,\n) => {\n  const collapsedRows: any[] = [];\n  boundaries.forEach((boundary) => {\n    const isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];\n    if (isVisible) {\n      const row = rows[boundary[0] - offset];\n      collapsedRows.push({\n        row,\n        cells: getCells(row),\n      });\n    } else {\n      const row = {} as any;\n      collapsedRows.push({\n        row: {\n          key: `${TABLE_STUB_TYPE.toString()}_${boundary[0]}_${boundary[1]}`,\n          type: TABLE_STUB_TYPE,\n          height: calculateRowHeight(rows, skipItems, getRowHeight, boundary[0], boundary[1]),\n        },\n        cells: getCells(row),\n      });\n    }\n  });\n  return collapsedRows;\n};\n\nconst calculateRowHeight: CalculateRowHeightFn = (\n  rows, skipItems, getRowHeight, bound1, bound2,\n) => {\n  if (bound1 === 0) {\n    let end = bound2;\n    if (rows.length && bound2 > rows[rows.length - 1].rowId!) {\n      end = bound2 - skipItems[1];\n    }\n    return getItemsSize(rows, skipItems[0], end, getRowHeight);\n  }\n  return getItemsSize(rows, bound1, bound2 - skipItems[1], getRowHeight);\n};\n\nexport const getCollapsedCells: GetCollapsedCellsFn = (\n  row, columns, spanBoundaries, boundaries, getColSpan,\n) => {\n  const collapsedCells: CollapsedCell[] = [];\n  let index = 0;\n  while (index < boundaries.length) {\n    const boundary = boundaries[index];\n    const isSpan = spanBoundaries.reduce((acc, spanBoundary) => (\n      acc || (spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1])), false);\n    if (isSpan) {\n      const column = columns[boundary[0]];\n      const realColSpan = getColSpan(row, column);\n      if (realColSpan + index - 1 !== columns.length) {\n        const realColSpanEnd = (realColSpan + boundary[0]) - 1;\n        const colSpanEnd = boundaries.findIndex(\n          colSpanBoundary => colSpanBoundary[0]\n          <= realColSpanEnd && realColSpanEnd\n          <= colSpanBoundary[1],\n        );\n        collapsedCells.push({\n          column,\n          colSpan: (colSpanEnd - index) + 1,\n        });\n      } else {\n        collapsedCells.push({\n          column,\n          colSpan: realColSpan,\n        });\n      }\n      index += 1;\n    } else {\n      collapsedCells.push({\n        column: {\n          key: `${TABLE_STUB_TYPE.toString()}_${boundary[0]}_${boundary[1]}`,\n          type: TABLE_STUB_TYPE,\n        },\n        colSpan: 1,\n      });\n      index += 1;\n    }\n  }\n  return collapsedCells;\n};\n\nconst getVisibleColumnBoundaries: PureComputed<\n  [TableRow[], VisibleBoundary, TableColumn[], VisibleBoundary[], GetColSpanFn], VisibleBoundary[]\n> = (rows, boundaries, columns, columnsVisibleBoundary, getColSpan) => {\n  const rowSpanBoundaries = rows\n    .slice(boundaries[0], boundaries[1] + 1)\n    .map(row => getSpanBoundaryByRow(row, columns, columnsVisibleBoundary, getColSpan));\n  return collapseBoundaries(\n    columns.length,\n    columnsVisibleBoundary,\n    rowSpanBoundaries,\n  );\n};\n\nexport const getCollapsedGrid: GetCollapsedGridFn = ({\n  rows,\n  columns,\n  rowsVisibleBoundary,\n  columnsVisibleBoundary,\n  getColumnWidth,\n  getRowHeight,\n  getColSpan,\n  totalRowCount,\n  offset,\n}) => {\n  if (!columns.length) {\n    return {\n      columns: [],\n      rows: [],\n    };\n  }\n\n  const boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];\n  const columnBoundaries = getVisibleColumnBoundaries(rows, boundaries, columns,\n    columnsVisibleBoundary, getColSpan);\n  const rowBoundaries = collapseBoundaries(totalRowCount!, [boundaries], []);\n\n  return {\n    columns: getCollapsedColumns(\n      columns,\n      columnsVisibleBoundary,\n      columnBoundaries,\n      getColumnWidth,\n    ),\n    rows: getCollapsedRows(\n      rows,\n      boundaries,\n      rowBoundaries,\n      [0, 0],\n      getRowHeight,\n      row => getCollapsedCells(\n        row,\n        columns,\n        getSpanBoundaryByRow(row, columns, columnsVisibleBoundary, getColSpan),\n        columnBoundaries,\n        getColSpan,\n      ),\n      offset,\n    ),\n  };\n};\n\nexport const getColumnWidthGetter: GetColumnWidthGetterFn = (\n  tableColumns, tableWidth, minColumnWidth,\n) => {\n  const colsHavingWidth = tableColumns.filter(col => typeof col.width === 'number');\n  const columnsWidth = colsHavingWidth.reduce((acc, col) => (acc + (col.width as number)!), 0);\n  const autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);\n  const autoColWidth = Math.max(autoWidth, minColumnWidth!);\n\n  return (column) => {\n    if (column) {\n      return column.type === TABLE_FLEX_TYPE ? 0 :\n        (typeof column.width === 'number' ? column.width : autoColWidth);\n    }\n    return autoColWidth;\n  };\n};\n\nconst getSpanBoundaryByRow: PureComputed<\n  [TableRow, TableColumn[], VisibleBoundary[], GetColSpanFn], VisibleBoundary[]\n> = (row, columns, visibleColumns, getColSpan) =>\n  getSpanBoundary(columns, visibleColumns, column => getColSpan(row, column));\n\nexport const getCollapsedGrids: GetCollapsedGridsFn = ({\n  headerRows,\n  bodyRows,\n  footerRows,\n  columns,\n  loadedRowsStart,\n  totalRowCount,\n  getCellColSpan,\n  viewport,\n  skipItems,\n  getRowHeight,\n  getColumnWidth,\n}) => {\n  if (!columns.length) {\n    return {\n      headerGrid: { columns: [], rows: [] },\n      bodyGrid: { columns: [], rows: [] },\n      footerGrid: { columns: [], rows: [] },\n    };\n  }\n  const getColSpan: GetColSpanFn =\n    (tableRow, tableColumn) => getCellColSpan!({ tableRow, tableColumn, tableColumns: columns });\n\n  const getCollapsedGridRows: PureComputed<\n    [TableRow[], number[], VisibleBoundary[], number?, number?], CollapsedRow[]\n  > = (rows, rowsBoundary, columnsBoundary, rowCount = rows.length, offset = 0) => {\n    return getCollapsedRows(rows, rowsBoundary,\n      collapseBoundaries(rowCount, [rowsBoundary], []),\n      skipItems,\n      getRowHeight,\n      row => getCollapsedCells(\n        row,\n        columns,\n        getSpanBoundaryByRow(row, columns, viewport.columns, getColSpan),\n        columnsBoundary,\n        getColSpan,\n      ),\n      offset,\n    );\n  };\n\n  const rowsVisibleBoundary = adjustedRenderRowBounds(viewport.rows, bodyRows.length,\n    loadedRowsStart);\n  const columnBoundaries = getVisibleColumnBoundaries(bodyRows, rowsVisibleBoundary,\n    columns, viewport.columns, getColSpan);\n  const commonColumns = getCollapsedColumns(\n    columns,\n    viewport.columns,\n    columnBoundaries,\n    getColumnWidth,\n  );\n\n  return {\n    headerGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(\n        headerRows, getRowsRenderBoundary(headerRows.length, viewport.headerRows), columnBoundaries,\n      ),\n    },\n    bodyGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(\n        bodyRows,\n        rowsVisibleBoundary,\n        columnBoundaries,\n        totalRowCount || 1,\n        loadedRowsStart,\n      ),\n    },\n    footerGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(\n        footerRows, getRowsRenderBoundary(footerRows.length, viewport.footerRows), columnBoundaries,\n      ),\n    },\n  };\n};\n\nconst adjustedRenderRowBounds: PureComputed<[VisibleBoundary, number, number], number[]> = (\n  visibleBounds, rowCount, loadedRowsStart,\n) => {\n  const renderRowBoundaries = getRowsRenderBoundary(\n    loadedRowsStart + rowCount, visibleBounds,\n  );\n  const adjustedInterval = intervalUtil.intersect(\n    { start: renderRowBoundaries[0], end: renderRowBoundaries[1] },\n    { start: loadedRowsStart, end: loadedRowsStart + rowCount },\n  );\n  return [adjustedInterval.start, adjustedInterval.end];\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_GROUP_TYPE } from './constants';\nimport { TableRow, TableColumn, IsSpecificCellFn, Grouping, GroupSummaryItem } from '../../types';\nimport { TABLE_STUB_TYPE } from '../../utils/virtual-table';\nimport { TABLE_DATA_TYPE, TABLE_FLEX_TYPE } from '../table/constants';\n\ntype IsGroupIndentCellFn = PureComputed<[TableRow, TableColumn, Grouping[]], boolean>;\n\nconst getGroupIndexByColumn: PureComputed<[Grouping[], TableColumn], number> = (\n  grouping, tableColumn,\n) => grouping.findIndex(\n  columnGrouping => !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name,\n);\n\nconst isIndentCell: IsGroupIndentCellFn = (\n    tableRow,\n    tableColumn,\n    grouping,\n  ) => {\n  if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name) return false;\n  const rowGroupIndex = grouping.findIndex(\n    columnGrouping => columnGrouping.columnName === tableRow.row.groupedBy,\n  );\n  const columnGroupIndex = getGroupIndexByColumn(grouping, tableColumn);\n\n  return columnGroupIndex < rowGroupIndex;\n};\n\nexport const isGroupTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE\n  && tableColumn.column\n  && tableColumn.column.name === tableRow.row.groupedBy);\n\nexport const isGroupIndentTableCell: IsGroupIndentCellFn = (\n  tableRow, tableColumn, grouping,\n) => (\n  tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE &&\n  isIndentCell(tableRow, tableColumn, grouping)\n);\n\nexport const isGroupIndentStubTableCell: IsGroupIndentCellFn = (\n  tableRow, tableColumn, grouping,\n) => (\n  (tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_STUB_TYPE &&\n    isIndentCell(tableRow, tableColumn, grouping))\n);\n\nexport const isGroupTableRow = (tableRow: TableRow) => tableRow.type === TABLE_GROUP_TYPE;\n\nexport const isGroupRowOrdinaryCell: IsSpecificCellFn = (tableRow, tableColumn) => (\n  isGroupTableRow(tableRow) && !isGroupTableCell(tableRow, tableColumn)\n);\n\nconst columnHasGroupRowSummary: PureComputed<[TableColumn, GroupSummaryItem[]], boolean> = (\n  tableColumn, groupSummaryItems,\n) => (\n  !!(groupSummaryItems && groupSummaryItems\n    .some(item => (\n      (!item.showInGroupFooter && item.alignByColumn)\n        && item.columnName === (tableColumn.column && tableColumn.column.name)\n    )))\n);\n\nexport const isRowSummaryCell: PureComputed<\n  [TableRow, TableColumn, Grouping[], GroupSummaryItem[]], boolean\n> = (\n  tableRow, tableColumn, grouping, groupSummaryItems,\n) => (\n  columnHasGroupRowSummary(tableColumn, groupSummaryItems)\n  && !isGroupIndentTableCell(tableRow, tableColumn, grouping)\n);\n\nexport const isPreviousCellContainSummary: PureComputed<\n  [TableRow, TableColumn, TableColumn[], Grouping[], GroupSummaryItem[]], boolean\n> = (\n  tableRow, tableColumn, tableColumns, grouping, groupSummaryItems,\n) => {\n  const columnIndex = tableColumns.indexOf(tableColumn);\n  return columnIndex > 0 && isRowSummaryCell(\n    tableRow, tableColumns[columnIndex - 1], grouping, groupSummaryItems,\n  );\n};\n\nexport const calculateGroupCellIndent: PureComputed<[TableColumn, Grouping[], number], number> = (\n  tableColumn, grouping, indentWidth,\n) => (\n  indentWidth * getGroupIndexByColumn(grouping, tableColumn)\n);\n\nexport const sortAndSpliceColumns: PureComputed<[TableColumn[], number]> = (\n  tableColumns, firstVisibleColumnIndex,\n) => {\n  const groupColumns = tableColumns.filter(col => col.type === TABLE_GROUP_TYPE);\n  const dataColumns = tableColumns.filter(col => col.type === TABLE_DATA_TYPE);\n  const otherColumns = tableColumns.filter(\n    col =>\n      col.type !== TABLE_DATA_TYPE &&\n      col.type !== TABLE_GROUP_TYPE &&\n      col.type !== TABLE_FLEX_TYPE,\n  );\n\n  if (firstVisibleColumnIndex) {\n    const firstGroupIndex = tableColumns.indexOf(groupColumns[0]);\n    otherColumns.splice(0, Math.min(firstVisibleColumnIndex, firstGroupIndex));\n  }\n\n  return [...groupColumns, ...otherColumns, ...dataColumns];\n};\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_GROUP_TYPE } from './constants';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  TableColumn, TableRow, IsSpecificRowFn,\n  TableColumnsWithDraftGroupingFn,\n  TableColumnsWithGroupingFn,\n  GroupCellColSpanGetter,\n  GroupSummaryChainsFn,\n  SummaryItem,\n} from '../../types';\nimport { sortAndSpliceColumns } from './helpers';\n\nconst tableColumnsWithDraftGrouping: TableColumnsWithDraftGroupingFn = (\n  tableColumns, grouping, draftGrouping, showColumnWhenGrouped,\n) => tableColumns\n  .reduce((acc, tableColumn) => {\n    if (tableColumn.type !== TABLE_DATA_TYPE) {\n      acc.push(tableColumn);\n      return acc;\n    }\n\n    const columnName = tableColumn.column && tableColumn.column.name || '';\n    const columnGroupingExists = grouping\n      .some(columnGrouping => columnGrouping.columnName === columnName);\n    const columnDraftGroupingExists = draftGrouping\n      .some(columnGrouping => columnGrouping.columnName === columnName);\n\n    if ((!columnGroupingExists && !columnDraftGroupingExists)\n        || showColumnWhenGrouped(columnName)) {\n      acc.push(tableColumn);\n    } else if ((!columnGroupingExists && columnDraftGroupingExists)\n        || (columnGroupingExists && !columnDraftGroupingExists)) {\n      acc.push({\n        ...tableColumn,\n        draft: true,\n      });\n    }\n    return acc;\n  // tslint:disable-next-line: prefer-array-literal\n  }, [] as Array<TableColumn & { draft?: boolean }>);\n\nexport const tableColumnsWithGrouping: TableColumnsWithGroupingFn = (\n  columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped,\n) => [\n  ...grouping.map((columnGrouping) => {\n    const groupedColumn = columns.find(column => column.name === columnGrouping.columnName);\n    return {\n      key: `${TABLE_GROUP_TYPE.toString()}_${groupedColumn!.name}`,\n      type: TABLE_GROUP_TYPE,\n      column: groupedColumn,\n      width: indentColumnWidth,\n    };\n  }),\n  ...tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped),\n];\n\nexport const tableRowsWithGrouping: PureComputed<[TableRow[], IsSpecificRowFn]> = (\n  tableRows, isGroupRow,\n) => tableRows.map((tableRow) => {\n  if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {\n    return tableRow;\n  }\n  return {\n    ...tableRow,\n    key: `${TABLE_GROUP_TYPE.toString()}_${tableRow.row.compoundKey}`,\n    type: TABLE_GROUP_TYPE,\n  };\n});\n\nconst isRowLevelSummary: PureComputed<[SummaryItem[], string], boolean> = (\n  groupSummaryItems, colName,\n) => (\n  groupSummaryItems.some((item: any) => (\n    !item.showInGroupFooter && item.alignByColumn && item.columnName === colName),\n  )\n);\n\nconst groupSummaryChains: GroupSummaryChainsFn = (\n  tableRow,\n  tableColumns,\n  groupSummaryItems,\n  firstVisibleColumnIndex,\n) => {\n  let captionStarted = false;\n  return sortAndSpliceColumns(tableColumns, firstVisibleColumnIndex)\n    .reduce((acc, col) => {\n      const colName = (col.column && col.column.name) as string;\n      const colKey = col.key;\n      const isStartOfGroupCaption = col.type === TABLE_GROUP_TYPE\n        && tableRow.row.groupedBy === colName;\n      const isIndentColumn = col.type === TABLE_GROUP_TYPE\n        && tableRow.row.groupedBy !== colName && !captionStarted;\n\n      if (isStartOfGroupCaption) {\n        captionStarted = true;\n      }\n\n      if (isStartOfGroupCaption || isIndentColumn) {\n        acc.push([colKey]);\n      } else if (groupSummaryItems && isRowLevelSummary(groupSummaryItems, colName)) {\n        acc.push([colKey]);\n        acc.push([]);\n      } else {\n        acc[acc.length - 1].push(colKey);\n      }\n      return acc;\n    }, [[]] as string[][]);\n};\n\nexport const tableGroupCellColSpanGetter: GroupCellColSpanGetter = (\n  getTableCellColSpan, groupSummaryItems, firstVisibleColumnIndex,\n) => (params) => {\n  const { tableRow, tableColumns, tableColumn } = params;\n\n  if (tableRow.type === TABLE_GROUP_TYPE) {\n    const colKey = tableColumn.key;\n    const chains = groupSummaryChains(\n      tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex,\n    );\n    const chain = chains.find(ch => ch[0] === colKey);\n\n    if (chain) {\n      return chain.length;\n    }\n  }\n  return getTableCellColSpan(params);\n};\n","import { TABLE_HEADING_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  IsSpecificCellFn, IsSpecificRowFn, HeaderColumnChain,\n  SplitHeaderColumnChainsFn, FindChainByColumnIndexFn,\n  GenerateChainsFn,\n  NextColumnNameFn,\n  GetNextColumnNameFn,\n} from '../../types';\n\nexport const isHeadingTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n\nexport const isHeadingTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_HEADING_TYPE\n);\n\nexport const findChainByColumnIndex: FindChainByColumnIndexFn = (chains, columnIndex) => (\n  chains.find(chain => (\n    chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length\n  ))!\n);\n\nexport const splitHeaderColumnChains: SplitHeaderColumnChainsFn = (\n  tableColumnChains, tableColumns, shouldSplitChain, extendChainProps,\n) => (\n  tableColumnChains.map((row, rowIndex) => row\n    .reduce((acc, chain) => {\n      let currentChain: any = null;\n      chain.columns.forEach((col) => {\n        const column = tableColumns.find(c => c.key === col.key);\n        const isNewGroup = shouldSplitChain(currentChain, column!, rowIndex);\n\n        if (isNewGroup) {\n          const start = currentChain\n            ? (currentChain.start + currentChain.columns.length)\n            : chain.start;\n\n          acc.push({\n            ...chain,\n            ...extendChainProps(column!),\n            start,\n            columns: [],\n          });\n          currentChain = acc[acc.length - 1];\n        }\n\n        currentChain.columns.push(column);\n      });\n\n      return acc;\n    }, [] as HeaderColumnChain[]))\n);\n\nexport const generateSimpleChains: GenerateChainsFn = (rows, columns) => (\n  rows.map(() => ([{\n    columns,\n    start: 0,\n  }]))\n);\n\nconst nextColumnName: NextColumnNameFn = (tableColumns , index) => {\n  const isNextColumnHasName = index < tableColumns.length - 1 && tableColumns[index + 1].column;\n  return isNextColumnHasName\n    ? tableColumns[index + 1].column!.name\n    : undefined;\n};\n\nexport const getNextColumnName: GetNextColumnNameFn = (tableColumns, columnName) => {\n  const index = tableColumns.findIndex(elem =>\n    elem.column && elem.column.name === columnName,\n  );\n  return index >= 0\n    ? nextColumnName(tableColumns, index)\n    : undefined;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_HEADING_TYPE } from './constants';\nimport { TableRow } from '../../types';\n\nexport const tableRowsWithHeading: PureComputed<[TableRow[]]> = headerRows => [\n  { key: TABLE_HEADING_TYPE.toString(), type: TABLE_HEADING_TYPE },\n  ...headerRows];\n","export const TABLE_BAND_TYPE = Symbol('band');\nexport const BAND_GROUP_CELL = 'bandGroupCell';\nexport const BAND_HEADER_CELL = 'bandHeaderCell';\nexport const BAND_EMPTY_CELL = 'bandEmptyCell';\nexport const BAND_DUPLICATE_RENDER = 'bandDuplicateRender';\nexport const BAND_FILL_LEVEL_CELL = 'bandFillLevelCell';\n","import {\n  TABLE_BAND_TYPE, BAND_GROUP_CELL, BAND_HEADER_CELL, BAND_EMPTY_CELL,\n  BAND_DUPLICATE_RENDER, BAND_FILL_LEVEL_CELL,\n} from './constants';\nimport { TABLE_HEADING_TYPE } from '../table-header-row/constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { findChainByColumnIndex } from '../table-header-row/helpers';\nimport {\n  GetColumnBandMetaFn, GetBandComponentFn, CalculateBandFn, Row,\n} from '../../types';\nimport { TABLE_STUB_TYPE } from '../../utils/virtual-table';\n\nexport const isBandedTableRow = (tableRow: Row) => (tableRow.type === TABLE_BAND_TYPE);\nexport const isBandedOrHeaderRow = (tableRow: Row) => isBandedTableRow(tableRow)\n  || tableRow.type === TABLE_HEADING_TYPE;\nexport const isNoDataColumn = (columnType: symbol) => columnType !== TABLE_DATA_TYPE;\n\nexport const getColumnMeta: GetColumnBandMetaFn = (\n  columnName, bands, tableRowLevel, key = '',\n  level = 0, title = null, result = null,\n) => bands.reduce((acc, band) => {\n  if (band.columnName === columnName) {\n    return { ...acc, title, level, key };\n  }\n  if (band.children !== undefined) {\n    const rowLevelPassed = level > tableRowLevel;\n    const bandTitle = rowLevelPassed ? title : band.title;\n    const bandKey = rowLevelPassed ? key : `${key}_${bandTitle}`;\n\n    return getColumnMeta(\n      columnName,\n      band.children,\n      tableRowLevel,\n      bandKey,\n      level + 1,\n      bandTitle,\n      acc,\n    );\n  }\n  return acc;\n}, result || { level, title, key: title });\n\nexport const calculateBand: CalculateBandFn = (visibleBound, headerChain) => {\n  if (visibleBound) {\n    const bandStart = Math.max(visibleBound[0], headerChain.start);\n\n    const bandEnd = Math.min(\n      visibleBound[1] + 1,\n      headerChain.start + headerChain.columns.length,\n    );\n\n    return [bandStart, bandEnd];\n  }\n\n  return [headerChain.start, headerChain.start + headerChain.columns.length];\n};\n\nexport const getBandComponent: GetBandComponentFn = (\n  { tableColumn: currentTableColumn, tableRow, rowSpan },\n  tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains,\n  columnVisibleIntervals, bandLevelsVisibility,\n) => {\n  if (rowSpan) return { type: BAND_DUPLICATE_RENDER, payload: null };\n\n  const maxLevel = tableHeaderRows.filter(column => column.type === TABLE_BAND_TYPE).length + 1;\n  const { level } = tableRow;\n  const currentRowLevel = level === undefined\n    ? maxLevel - 1 : level;\n  const currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE\n    ? getColumnMeta(currentTableColumn.column!.name, columnBands, currentRowLevel)\n    : { level: 0, title: '' };\n\n  const currentColumnIndex = tableColumns\n    .findIndex(column => column.key === currentTableColumn.key);\n\n  const levelsCount = bandLevelsVisibility.length;\n  const visibleLevelsCount = bandLevelsVisibility.filter(Boolean).length;\n\n  if (currentColumnMeta.level < currentRowLevel) {\n    const shouldFillLevel = currentRowLevel > 0 && visibleLevelsCount < levelsCount\n      && !bandLevelsVisibility[currentRowLevel] && currentTableColumn.type === TABLE_STUB_TYPE;\n\n    if (shouldFillLevel) {\n      return { type: BAND_FILL_LEVEL_CELL, payload: null };\n    }\n    return { type: BAND_EMPTY_CELL, payload: null };\n  }\n\n  const previousTableColumn = tableColumns[currentColumnIndex - 1];\n  let beforeBorder = false;\n  if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE\n    && isNoDataColumn(previousTableColumn.type)) {\n    beforeBorder = true;\n  }\n\n  const isStubColumn = currentTableColumn.type === TABLE_STUB_TYPE;\n  const isColumnVisible = currentColumnIndex >= 0;\n\n  if (currentColumnMeta.level === currentRowLevel) {\n    if (isStubColumn) {\n      const cellRowSpan = visibleLevelsCount < levelsCount\n        ? visibleLevelsCount || 1\n        : maxLevel;\n\n      return {\n        type: BAND_FILL_LEVEL_CELL,\n        payload: {\n          rowSpan: cellRowSpan,\n        },\n      };\n    }\n\n    if (isColumnVisible) {\n      return {\n        type: BAND_HEADER_CELL,\n        payload: {\n          tableRow: tableHeaderRows.find(row => row.type === TABLE_HEADING_TYPE),\n          rowSpan: maxLevel - currentRowLevel,\n          ...beforeBorder && { beforeBorder },\n        },\n      };\n    }\n  }\n\n  if (!isColumnVisible) return { type: BAND_EMPTY_CELL, payload: null };\n\n  const currentColumnChain = findChainByColumnIndex(\n    tableHeaderColumnChains[currentRowLevel],\n    currentColumnIndex,\n  );\n  const columnVisibleBoundary = columnVisibleIntervals.find(([start, end]) => (\n    start <= currentColumnIndex && currentColumnIndex <= end\n  ));\n\n  const [bandStart, bandEnd] = calculateBand(columnVisibleBoundary, currentColumnChain);\n\n  if (bandStart < currentColumnIndex) {\n    return { type: null, payload: null };\n  }\n\n  return {\n    type: BAND_GROUP_CELL,\n    payload: {\n      colSpan: bandEnd - bandStart,\n      value: currentColumnMeta.title!,\n      column: currentColumnMeta,\n      ...beforeBorder && { beforeBorder },\n    },\n  };\n};\n","import { intervalUtil } from './utils';\nimport {\n  VirtualRows, Row, MergeRowsFn, CalculateRequestedRangeFn,\n  Interval, GridViewport, GetRequestMeta, CorrectRangeFn,\n} from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nexport const emptyVirtualRows: VirtualRows = {\n  skip: Number.POSITIVE_INFINITY,\n  rows: [],\n};\n\nconst pluckSubarray: PureComputed<[Row[], ...number[]]> = (source, sourceStart, left, right) => (\n  source.slice(left - sourceStart, right - sourceStart)\n);\n\nexport const mergeRows: MergeRowsFn = (\n  rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart,\n) => {\n  const breakpoints = [\n    rowsInterval.start, rowsInterval.end,\n    cacheInterval.start, cacheInterval.end,\n  ]\n    .filter(i => 0 <= i && i < Number.POSITIVE_INFINITY)\n    .sort((a, b) => a - b);\n\n  let result: Row[] = [];\n  if (breakpoints.length > 1) {\n    for (let i = 0; i < breakpoints.length - 1; i += 1) {\n      const left = breakpoints[i];\n      const right = breakpoints[i + 1];\n      const chunk = rowsInterval.start <= left && right <= rowsInterval.end\n        ? pluckSubarray(rows, rowsStart, left, right) // rows have higher priority\n        : pluckSubarray(cacheRows, cacheStart, left, right);\n\n      result = result.concat(chunk);\n    }\n  }\n\n  return {\n    skip: breakpoints[0],\n    rows: result,\n  };\n};\n\nconst correctRequestedRange: CorrectRangeFn = (calculatedRange, referenceIndex, pageSize) => {\n  const { start, end } = calculatedRange;\n\n  if (start - referenceIndex > pageSize / 2) {\n    return { start: start - pageSize, end: start };\n  }\n  return { start, end };\n};\n\nexport const calculateRequestedRange: CalculateRequestedRangeFn = (\n  virtualRows, newRange, pageSize, referenceIndex, isInfiniteScroll,\n) => {\n  const loadedInterval = intervalUtil.getRowsInterval(virtualRows);\n  const isAdjacentPage = Math.abs(loadedInterval.start - newRange.start) < 2 * pageSize;\n  if (isAdjacentPage) {\n    const calculatedRange = intervalUtil.difference(newRange, loadedInterval);\n    if (isInfiniteScroll && calculatedRange !== intervalUtil.empty) {\n      return correctRequestedRange(calculatedRange, referenceIndex, pageSize);\n    }\n    return calculatedRange;\n  }\n\n  // load 3 pages at once because a missing page will be loaded anyway\n  return newRange;\n};\n\nexport const rowToPageIndex: PureComputed<[number, number]> = (\n  rowIndex, pageSize,\n) => Math.floor(rowIndex / pageSize);\n\nexport const recalculateBounds: PureComputed<[number, number, number], Interval> = (\n  middleIndex, pageSize, totalCount,\n) => {\n  const currentPageIndex = rowToPageIndex(middleIndex, pageSize);\n\n  const prevPageIndex = currentPageIndex - 1;\n  const nextPageIndex = currentPageIndex + 2;\n  const start = Math.max(0, prevPageIndex * pageSize);\n  const end = Math.min(nextPageIndex * pageSize, totalCount);\n\n  return {\n    start,\n    end,\n  };\n};\n\nexport const trimRowsToInterval: PureComputed<[VirtualRows, Interval]> = (\n  virtualRows, targetInterval,\n) => {\n  const rowsInterval = intervalUtil.getRowsInterval(virtualRows);\n  const intersection = intervalUtil.intersect(rowsInterval, targetInterval);\n  if (intervalUtil.empty === intersection) {\n    return emptyVirtualRows;\n  }\n\n  const rows = pluckSubarray(\n    virtualRows.rows, virtualRows.skip, intersection.start, intersection.end,\n  );\n\n  return {\n    rows,\n    skip: intersection.start,\n  };\n};\n\nexport const getAvailableRowCount: PureComputed<[boolean, number, number, number], number> = (\n  isInfiniteScroll, newRowCount, lastRowCount, totalRowCount,\n) => {\n  return (isInfiniteScroll\n    ? Math.min(\n        Math.max(newRowCount, lastRowCount),\n        totalRowCount)\n    : totalRowCount\n  );\n};\n\nexport const getForceReloadInterval: PureComputed<[VirtualRows, number, number], Interval> = (\n  virtualRows, pageSize, totalRowCount,\n) => {\n  const { start, end: intervalEnd } = intervalUtil.getRowsInterval(virtualRows);\n  const end = Math.min(\n    Math.max(start + pageSize * 2, intervalEnd),\n    Math.max(start + pageSize * 2, totalRowCount),\n  );\n  return {\n    start,\n    end,\n  };\n};\n\nexport const getRequestMeta: GetRequestMeta = (\n  referenceIndex, virtualRows, pageSize, totalRowCount, forceReload, isInfiniteScroll,\n) => {\n  const actualBounds = forceReload\n    ? getForceReloadInterval(virtualRows, pageSize!, totalRowCount)\n    : recalculateBounds(referenceIndex, pageSize!, totalRowCount);\n  const requestedRange = forceReload\n    ? actualBounds\n    : calculateRequestedRange(\n        virtualRows, actualBounds, pageSize!, referenceIndex, isInfiniteScroll,\n      );\n\n  return { requestedRange, actualBounds };\n};\n\nexport const needFetchMorePages: PureComputed<[VirtualRows, number, number], boolean> = (\n  virtualRows, referenceIndex,  pageSize,\n) => {\n  const { start, end } = intervalUtil.getRowsInterval(virtualRows);\n  const loadCount = end - start;\n  const topTriggerIndex = start > 0 ? start + pageSize : 0;\n  const bottomTriggerIndex = Math.max(topTriggerIndex + pageSize, end - pageSize * 1.5);\n\n  if (loadCount <= 0) {\n    return false;\n  }\n\n  return (referenceIndex < topTriggerIndex || bottomTriggerIndex < referenceIndex);\n};\n\nexport const getReferenceIndex: PureComputed<[GridViewport], number> = (\n  { rows: [top, bottom] },\n) => (\n  (top + bottom) / 2\n);\n\nexport const shouldSendRequest: PureComputed<[Interval, number, number], boolean> = (\n  { start, end }, requestedPageIndex, requestedEndIndex,\n) => {\n  const loadCount = (end - start);\n  return (start !== requestedPageIndex || end !== requestedEndIndex) && loadCount > 0;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { emptyVirtualRows } from './helpers';\nimport { Interval, VirtualRows } from '../../types';\n\nconst empty: Interval = {\n  start: Number.POSITIVE_INFINITY,\n  end: Number.NEGATIVE_INFINITY,\n};\n\nconst getRowsInterval: PureComputed<[VirtualRows], Interval> = r => (\n  r === emptyVirtualRows\n    ? empty\n    : {\n      start: r.skip,\n      end: r.skip + r.rows.length,\n    }\n);\n\nconst getLength = (a: Interval) => a.end - a.start;\n\nconst intersect = (a: Interval, b: Interval) => {\n  if (a.end < b.start || b.end < a.start) {\n    return empty;\n  }\n\n  return {\n    start: Math.max(a.start, b.start),\n    end: Math.min(a.end, b.end),\n  };\n};\n\nconst difference = (a: Interval, b: Interval) => {\n  if (empty === intervalUtil.intersect(a, b)) {\n    return a;\n  }\n\n  if (b.end < a.end) {\n    return {\n      start: b.end,\n      end: a.end,\n    };\n  }\n  if (a.start < b.start) {\n    return {\n      start: a.start,\n      end: b.start,\n    };\n  }\n  return empty;\n};\n\nexport const intervalUtil = {\n  empty,\n\n  getRowsInterval,\n  getLength,\n\n  intersect,\n  difference,\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_BAND_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_GROUP_TYPE } from '../table-group-row/constants';\nimport { getColumnMeta } from './helpers';\nimport { splitHeaderColumnChains, generateSimpleChains } from '../table-header-row/helpers';\nimport {\n  ColumnBands, GetHeaderColumnChainsFn, ShouldSplitChainFn,\n  GetMaxNestedLevelFn, TableRow, TableColumn, HeaderColumnChainRows,\n  BandLevels, BandColumnChainExtension, HeaderColumnChain, VisibleBoundary, GridViewport,\n} from '../../types';\nimport { intervalUtil } from '../virtual-table-state/utils';\n\nexport const tableRowsWithBands: PureComputed<\n  [TableRow[], ColumnBands[], TableColumn[]]\n> = (\n  tableHeaderRows, columnBands, tableColumns,\n) => {\n  const tableDataColumns = tableColumns.filter(column => column.type === TABLE_DATA_TYPE);\n  const getMaxNestedLevel: GetMaxNestedLevelFn = (bands, level = 0, result = null) => (\n    bands.reduce((acc, column) => {\n      if (column.children !== undefined) {\n        return getMaxNestedLevel(column.children, level + 1, acc);\n      }\n      const isDataColumn = tableDataColumns.findIndex(\n        dataColumn => !!dataColumn.column && dataColumn.column.name === column.columnName,\n      ) > -1;\n      if (level > acc.level && isDataColumn) {\n        return { ...acc, level };\n      }\n      return acc;\n    }, result || { level: 0 })\n  );\n\n  const tableBandHeaders = Array.from({\n    length: getMaxNestedLevel(columnBands as ColumnBands[], 0).level,\n  })\n    .map((row, index) => ({\n      key: `${TABLE_BAND_TYPE.toString()}_${index}`,\n      type: TABLE_BAND_TYPE,\n      level: index,\n    }));\n  return [...tableBandHeaders, ...tableHeaderRows];\n};\n\nexport const tableHeaderColumnChainsWithBands: GetHeaderColumnChainsFn<\n  TableRow[], TableColumn[], ColumnBands[]\n> = (\n  tableHeaderRows, tableColumns, bands,\n) => {\n  const chains = generateSimpleChains(tableHeaderRows, tableColumns);\n  const maxBandRowIndex = tableHeaderRows\n    .filter(row => row.type === TABLE_BAND_TYPE)\n    .length;\n  const rawBandChains = chains.slice(0, maxBandRowIndex);\n\n  let currentBand: any = null;\n  const shouldSplitChain: ShouldSplitChainFn = (chain, column, rowIndex) => {\n    if (rowIndex > maxBandRowIndex) return false;\n\n    const columnName = column.column && column.column.name || '';\n    currentBand = getColumnMeta(columnName, bands, rowIndex);\n    return !chain\n      || chain.key !== currentBand.key\n      || chain.columns[0].type === TABLE_GROUP_TYPE;\n  };\n  const extendChainProps = () => ({\n    bandTitle: currentBand?.title,\n    key: currentBand?.key,\n  });\n\n  const bandChains = splitHeaderColumnChains(\n    rawBandChains,\n    tableColumns,\n    shouldSplitChain,\n    extendChainProps,\n  );\n\n  return [...bandChains, ...chains.slice(maxBandRowIndex)];\n};\n\nconst getBandLevel: PureComputed<[ColumnBands[], string, number?], number> = (\n  bands, bandTitle, level = 0,\n) => {\n  for (const band of bands) {\n    if (band.title === bandTitle) {\n      return level;\n    }\n    if (band.children !== undefined) {\n      const result = getBandLevel(band.children, bandTitle, level + 1);\n      if (result >= 0) return result;\n    }\n  }\n  return -1;\n};\n\nconst getBandLevels = (columnsBands: readonly ColumnBands[], levels = {}, level = 0) => {\n  columnsBands.forEach((band) => {\n    if (band.title) {\n      levels[band.title] = level;\n    }\n    if (band.children) {\n      getBandLevels(band.children, levels, level + 1);\n    }\n  });\n  return levels;\n};\n\nexport const columnBandLevels: PureComputed<[ColumnBands[]], BandLevels> = columnsBands => (\n  getBandLevels(columnsBands)\n);\n\nexport const bandLevelsVisibility: PureComputed<\n  [VisibleBoundary[], HeaderColumnChainRows<BandColumnChainExtension>, BandLevels],\n  boolean[]\n> = (columnIntervals, tableHeaderColumnChains, bandLevels) => {\n  const rowsWithBands = tableHeaderColumnChains\n    .filter(r => r.filter(ch => !!ch.bandTitle).length);\n\n  const visibleIntervals = columnIntervals.map(([start, end]) => ({ start, end }));\n\n  const isBandChainVisible = (chain: HeaderColumnChain) => (\n    visibleIntervals.some(interval => (\n      intervalUtil.intersect(\n        interval,\n        { start: chain.start, end: chain.start + chain.columns.length - 1 },\n      ) !== intervalUtil.empty\n    ),\n  ));\n\n  const getVisibleBandsByLevel = (level: number) => (\n    // Note: a visible band level always matches with it's row\n    rowsWithBands[level]\n    ? rowsWithBands[level].filter(chain => (\n        bandLevels[chain.bandTitle] === level && isBandChainVisible(chain)\n      ))\n    : []\n  );\n\n  return rowsWithBands.reduce((acc, _, index) => {\n    const rowBands = getVisibleBandsByLevel(index);\n    return [...acc, !!rowBands.length];\n  }, [] as boolean[]);\n};\n\nexport const columnVisibleIntervals: PureComputed<\n  [GridViewport, TableColumn[]],\n  VisibleBoundary[]\n> = (\n  viewport, tableColumns,\n) => (\n  viewport ? viewport.columns : [[0, tableColumns.length]]\n);\n","import { toggle } from '../../utils/common-reducers';\nimport { ToggleRowFieldReducer } from '../../types';\n\nexport const toggleDetailRowExpanded: ToggleRowFieldReducer = (\n  prevExpanded, { rowId, state },\n) => toggle(prevExpanded, [rowId], state);\n","export const TABLE_DETAIL_TYPE = Symbol('detail');\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DETAIL_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { IsSpecificCellFn, IsSpecificRowFn, TableColumn, RowId } from '../../types';\n\nexport const isDetailRowExpanded: PureComputed<[RowId[], RowId], boolean> = (\n  expandedDetailRowIds, rowId,\n) => expandedDetailRowIds.indexOf(rowId) > -1;\n\nexport const isDetailToggleTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE;\n\nexport const isDetailTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_DETAIL_TYPE;\n\nexport const isDetailTableCell: PureComputed<[TableColumn, TableColumn[]], boolean> = (\n  tableColumn, tableColumns,\n) => tableColumns.indexOf(tableColumn) === 0;\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DETAIL_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableRow, TableColumn, CellColSpanGetter } from '../../types';\n\nexport const tableRowsWithExpandedDetail: PureComputed<[TableRow[], number[], number]> = (\n  tableRows, expandedDetailRowIds, rowHeight,\n) => {\n  let result = tableRows;\n  expandedDetailRowIds\n    .forEach((expandedRowId) => {\n      const rowIndex = result.findIndex(\n        tableRow => tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId,\n      );\n      if (rowIndex === -1) return;\n      const insertIndex = rowIndex + 1;\n      const { row, rowId } = result[rowIndex];\n      result = [\n        ...result.slice(0, insertIndex),\n        {\n          rowId,\n          row,\n          key: `${TABLE_DETAIL_TYPE.toString()}_${rowId}`,\n          type: TABLE_DETAIL_TYPE,\n          height: rowHeight,\n        },\n        ...result.slice(insertIndex),\n      ];\n    });\n  return result;\n};\n\nexport const tableColumnsWithDetail: PureComputed<[TableColumn[], number]> = (\n  tableColumns, toggleColumnWidth,\n) => [\n  { key: TABLE_DETAIL_TYPE.toString(), type: TABLE_DETAIL_TYPE, width: toggleColumnWidth },\n  ...tableColumns,\n];\n\nexport const tableDetailCellColSpanGetter: CellColSpanGetter = getTableCellColSpan => (params) => {\n  const { tableRow, tableColumns, tableColumn } = params;\n  if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n    return tableColumns.length;\n  }\n  return getTableCellColSpan(params);\n};\n","export const TABLE_SELECT_TYPE = Symbol('select');\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_SELECT_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_HEADING_TYPE } from '../table-header-row/constants';\nimport { IsSpecificCellFn, TableRow } from '../../types';\n\nexport const isSelectTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE;\nexport const isSelectAllTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE;\n\nexport const isRowHighlighted: PureComputed<[boolean, any[], TableRow, any[]?], boolean> = (\n  highlightRow, selection, tableRow, focused,\n) => {\n  const highlightion = selection ? selection.concat(focused || []) : focused;\n  return !!(highlightRow && highlightion && highlightion.includes(tableRow.rowId));\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_SELECT_TYPE } from './constants';\nimport { TableColumn } from '../../types';\n\nexport const tableColumnsWithSelection: PureComputed<[TableColumn[], number, boolean|undefined]> = (\n  tableColumns, selectionColumnWidth, showSelectionColumn,\n) => {\n  if (showSelectionColumn) {\n    return [\n      { key: TABLE_SELECT_TYPE.toString(), type: TABLE_SELECT_TYPE, width: selectionColumnWidth },\n      ...tableColumns,\n    ];\n  }\n  return tableColumns;\n};\n","import { TABLE_DATA_TYPE, TABLE_NODATA_TYPE } from './constants';\nimport {\n  IsSpecificCellFn, IsSpecificRowFn, TableRow, TableColumn, CheckColumnExtensionsFn,\n} from '../../types';\nimport { TABLE_STUB_TYPE } from '../../utils/virtual-table';\nimport { isValidValue } from '../table-column-resizing/helpers';\n\nconst VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nconst TABLE_ERROR = 'The columnExtension property of the Table plugin is given an invalid value.';\n\nexport const isDataTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isHeaderStubTableCell: IsSpecificCellFn<TableRow, TableRow[]> = (\n  tableRow, headerRows,\n) => headerRows.indexOf(tableRow) > -1;\nexport const isDataTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_DATA_TYPE;\nexport const isNoDataTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_NODATA_TYPE;\nexport const isNoDataTableCell: IsSpecificCellFn<TableColumn, TableColumn[]> = (\n  tableColumn, tableColumns,\n) => tableColumns.indexOf(tableColumn as any) === 0;\nexport const isStubTableCell: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_STUB_TYPE\n);\n\nexport const checkTableColumnExtensions: CheckColumnExtensionsFn = (columnExtensions) => {\n  if (columnExtensions) {\n    columnExtensions.map((column) => {\n      const { width } = column;\n      if (typeof width === 'string') {\n        if (!isValidValue(width, VALID_UNITS)) {\n          throw new Error(TABLE_ERROR);\n        }\n      }\n    });\n  }\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  GridColumnExtension, GetColumnExtensionValueGetterFn,\n} from '../types';\n\nexport const getColumnExtension: PureComputed<\n  [GridColumnExtension[] | undefined, string], GridColumnExtension\n> = (columnExtensions, columnName) => {\n  if (!columnExtensions) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {} as GridColumnExtension;\n  }\n  const columnExtension = columnExtensions.find(extension => extension.columnName === columnName);\n  if (!columnExtension) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {} as GridColumnExtension;\n  }\n  return columnExtension;\n};\n\nexport const getColumnExtensionValueGetter: GetColumnExtensionValueGetterFn = (\n  columnExtensions, extensionName, defaultValue,\n) => (columnName) => {\n  if (columnExtensions) {\n    const columnExtension = getColumnExtension(columnExtensions, columnName);\n    const extensionValue = columnExtension[extensionName];\n    return extensionValue !== undefined ? extensionValue : defaultValue;\n  }\n  return defaultValue;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE, TABLE_NODATA_TYPE } from './constants';\nimport { getColumnExtension } from '../../utils/column-extension';\nimport { GridColumnExtension, GetCellColSpanFn } from './../../types/table.types';\nimport { Row, GetRowIdFn } from '../../types';\nimport { convertWidth } from '../table-column-resizing/helpers';\n\nexport const tableColumnsWithDataRows: PureComputed<[any[], GridColumnExtension[]]> = (\n  columns, columnExtensions,\n) => columns.map((column) => {\n  const { name } = column;\n  const columnExtension = getColumnExtension(columnExtensions as GridColumnExtension[], name);\n  const width = convertWidth(columnExtension.width!);\n  return {\n    column,\n    key: `${TABLE_DATA_TYPE.toString()}_${name}`,\n    type: TABLE_DATA_TYPE,\n    width,\n    align: columnExtension.align,\n    wordWrapEnabled: columnExtension.wordWrapEnabled,\n  };\n});\n\nexport const tableRowsWithDataRows: PureComputed<[Row[], GetRowIdFn, number]> = (\n  rows, getRowId, isRemoteRowsLoading,\n) => (\n  !rows.length && !isRemoteRowsLoading\n    ? [{ key: TABLE_NODATA_TYPE.toString(), type: TABLE_NODATA_TYPE }]\n    : rows.map((row, dataIndex) => {\n      const rowId = getRowId(row);\n      return {\n        row,\n        // dataIndex,\n        rowId,\n        type: TABLE_DATA_TYPE,\n        key: `${TABLE_DATA_TYPE.toString()}_${rowId}`,\n      };\n    }));\n\nexport const tableCellColSpanGetter: GetCellColSpanFn = (params) => {\n  const { tableRow, tableColumns, tableColumn } = params;\n  if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n    return tableColumns.length;\n  }\n  return 1;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableColumn } from '../../types';\n\nexport const visibleTableColumns: PureComputed<[TableColumn[], string[]]> = (\n  tableColumns = [], hiddenColumnNames,\n) => tableColumns.filter(tableColumn => tableColumn.type !== TABLE_DATA_TYPE\n    || hiddenColumnNames.indexOf(tableColumn.column!.name) === -1);\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableColumn } from '../../types';\n\nexport const tableDataColumnsExist = (tableColumns: TableColumn[]) => tableColumns.some(\n  column => column.type === TABLE_DATA_TYPE,\n);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { Column } from '../../types/grid-core.types';\nimport { ColumnChooserItem } from '../../types';\n\nexport const columnChooserItems: PureComputed<[Column[], string[]], ColumnChooserItem[]> = (\n  columns, hiddenColumnNames,\n) => columns.map(column => ({\n  column,\n  hidden: hiddenColumnNames.indexOf(column.name) !== -1,\n}));\n","import { PureReducer } from '@devexpress/dx-core';\n\nexport const toggleColumn: PureReducer<string[], string> = (\n  hiddenColumnNames, columnName,\n) => (\n  hiddenColumnNames.indexOf(columnName) === -1\n    ? [...hiddenColumnNames, columnName]\n    : hiddenColumnNames.filter(hiddenColumn => hiddenColumn !== columnName)\n);\n","import { toggle } from '../../utils/common-reducers';\nimport { ToggleRowFieldReducer } from '../../types';\n\nexport const toggleRowExpanded: ToggleRowFieldReducer = (\n  prevExpanded, { rowId, state },\n) => toggle(prevExpanded, [rowId], state);\n","export const GRID_TREE_NODE_TYPE = Symbol('treeNode');\n","import { PureComputed } from '@devexpress/dx-core';\nimport { GRID_TREE_NODE_TYPE } from './constants';\nimport {\n  RowsWithTreeMetaMap, RowsWithCollapsedRowsMetaMap, IsSpecificTreeRowGetter, GetRowIdFn,\n  GetRowLevelKeyFn, GetCollapsedRowsFn, CustomTreeRowsWithMetaComputed,\n  UnwrapRowsComputed, GetTreeRowLevelGetter, ExpandedTreeRowsFn, Row,\n} from '../../types';\n\nexport const customTreeRowsWithMeta: CustomTreeRowsWithMetaComputed = (\n  rows, getChildRows,\n) => {\n  const rowsToProcess = [{ row: null, level: -1 }] as Row[];\n  const treeRows = [] as { row: Row, level: number, leaf: boolean }[];\n\n  while (rowsToProcess?.length) {\n    const { row: currentRow, level } = rowsToProcess.shift()!;\n    const rowIndex = treeRows.findIndex(({ row }) => row === currentRow);\n    const nestedRows = getChildRows(currentRow, rows as Row[])?.map(\n      (childRow: Row) => ({\n        row: childRow,\n        level: level + 1,\n        leaf: !getChildRows(childRow, rows as Row[]),\n      }),\n    );\n\n    if (nestedRows) {\n      if (rowIndex > -1) {\n        treeRows.splice(rowIndex + 1, 0, ...nestedRows);\n      } else {\n        treeRows.push(...nestedRows);\n      }\n      rowsToProcess.push(...nestedRows);\n    }\n  }\n\n  const result = treeRows.reduce((acc, { row, level, leaf }) => {\n    acc.rows.push(row);\n    acc.treeMeta.push([row, { level, leaf }]);\n\n    return acc;\n  }, { rows: [] as Row[], treeMeta: [] as any[] });\n\n  return {\n    rows: result.rows,\n    treeMeta: new Map(result.treeMeta),\n  };\n};\n\nexport const customTreeRowIdGetter: PureComputed<[GetRowIdFn, RowsWithTreeMetaMap]> = (\n  getRowId, { rows, treeMeta },\n) => {\n  const firstNestedRowIndex = rows.findIndex(row => treeMeta.get(row)!.level > 0);\n  if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== undefined) {\n    return getRowId;\n  }\n  const map = new Map(rows\n    .map((row, rowIndex) => [row, rowIndex] as [any, any]));\n  return row => map.get(row);\n};\n\nexport const customTreeRowLevelKeyGetter: PureComputed<\n  [GetRowLevelKeyFn, RowsWithTreeMetaMap]\n> = (\n  getRowLevelKey, { treeMeta },\n) => (row) => {\n  const rowMeta = treeMeta.get(row);\n  if (rowMeta !== undefined) {\n    return `${GRID_TREE_NODE_TYPE.toString()}_${rowMeta.level}`;\n  }\n  return getRowLevelKey && getRowLevelKey();\n};\n\nexport const expandedTreeRows: ExpandedTreeRowsFn = (\n  { rows, treeMeta }, getRowId, expandedRowIds,\n) => {\n  const expandedRowIdsSet = new Set(expandedRowIds);\n\n  let currentExpanded = true;\n  let currentLevel = 0;\n\n  const collapsedRowsMeta = new Map();\n  const resultRows: object[] = [];\n\n  rows.forEach((row) => {\n    const rowMeta = treeMeta.get(row);\n    const level = rowMeta && rowMeta.level;\n    if (level === undefined && currentExpanded) {\n      resultRows.push(row);\n    } else if (!currentExpanded && (level === undefined || level > currentLevel)) {\n      const lastRow = resultRows[resultRows.length - 1];\n      let collapsedItems = collapsedRowsMeta.get(lastRow);\n      if (!collapsedItems) {\n        collapsedItems = [];\n        collapsedRowsMeta.set(lastRow, collapsedItems);\n      }\n      collapsedItems.push(row);\n    } else {\n      currentExpanded = expandedRowIdsSet.has(getRowId(row));\n      currentLevel = level!;\n\n      resultRows.push(row);\n    }\n  });\n\n  return {\n    treeMeta,\n    collapsedRowsMeta,\n    rows: resultRows,\n  };\n};\n\nexport const collapsedTreeRowsGetter: PureComputed<\n  [GetCollapsedRowsFn, RowsWithCollapsedRowsMetaMap]\n> = (\n  getCollapsedRows, { collapsedRowsMeta },\n) => row => collapsedRowsMeta.get(row) || (getCollapsedRows && getCollapsedRows(row));\n\nexport const isTreeRowLeafGetter: IsSpecificTreeRowGetter = ({ treeMeta }) => (row) => {\n  const rowMeta = treeMeta.get(row);\n  return rowMeta && rowMeta.leaf;\n};\n\nexport const getTreeRowLevelGetter: GetTreeRowLevelGetter = ({ treeMeta }) => (row) => {\n  const rowMeta = treeMeta.get(row);\n  return (rowMeta && rowMeta.level) as number;\n};\n\nexport const unwrappedCustomTreeRows: UnwrapRowsComputed = ({ rows }) => rows;\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { IsSpecificCellFn, TableRow, TableColumn } from '../../types';\n\nexport const isTreeTableCell: IsSpecificCellFn<TableRow, TableColumn, string> = (\n  tableRow, tableColumn, forColumnName,\n) => tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE\n  && tableColumn.column!.name === forColumnName;\n","export const changeSearchValue = (\n  prevSearchValue: string, searchValue: string,\n) => searchValue;\n","import { SearchFilterExpressionFn, FilterExpression } from '../../types';\n\nexport const searchFilterExpression: SearchFilterExpressionFn = (\n  searchValue, columns, filterExpression,\n) => {\n  const filters = columns.map(({ name }) => ({ columnName: name, value: searchValue }));\n  const selfFilterExpression: FilterExpression = { filters, operator: 'or' };\n  if (!filterExpression) {\n    return selfFilterExpression;\n  }\n  return {\n    operator: 'and',\n    filters: [filterExpression as FilterExpression, selfFilterExpression],\n  };\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { GetAvailableFilterOperationsFn, FilterOperation } from '../../types';\n\nexport const getAvailableFilterOperationsGetter: PureComputed<\n  [GetAvailableFilterOperationsFn, FilterOperation[], string[]]\n> = (\n  getAvailableFilterOperations,\n  availableFilterOperations,\n  columnNames,\n) => columnName => (columnNames.indexOf(columnName) > -1 && availableFilterOperations)\n// tslint:disable-next-line: max-line-length\n    || (typeof getAvailableFilterOperations === 'function' && getAvailableFilterOperations(columnName))\n    || undefined;\n","export const FIXED_COLUMN_LEFT_SIDE = 'left';\nexport const FIXED_COLUMN_RIGHT_SIDE = 'right';\nexport const TABLE_FIXED_TYPE = Symbol('fixed');\n","import { slice } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  FIXED_COLUMN_LEFT_SIDE, TABLE_FIXED_TYPE,\n} from './constants';\nimport { findChainByColumnIndex } from '../table-header-row/helpers';\nimport {\n  GetFixedColumnKeysFn, IsSpecificRowFn, CalculatePositionFn, CalculateFixedColumnPropsFn,\n} from '../../types';\n\nexport const getFixedColumnKeys: GetFixedColumnKeysFn = (tableColumns, fixedNames) => tableColumns\n  .filter(tableColumn => (\n    (tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column!.name) !== -1)\n    || fixedNames.indexOf(tableColumn.type) !== -1\n  ))\n  .map(({ key }) => key);\n\nexport const isFixedTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_FIXED_TYPE;\n\nconst calculatePosition: CalculatePositionFn = (array, index, tableColumnDimensions) => (\n  index === 0\n    ? 0\n    : array\n      .slice(0, index)\n      .reduce((acc, target) => acc + tableColumnDimensions[target] || 0, 0)\n);\n\nexport const calculateFixedColumnProps: CalculateFixedColumnPropsFn = (\n  { tableColumn },\n  { leftColumns, rightColumns },\n  tableColumns,\n  tableColumnDimensions,\n  tableHeaderColumnChains,\n) => {\n  const side = tableColumn.fixed!;\n  const targetArray = side === FIXED_COLUMN_LEFT_SIDE\n    ? getFixedColumnKeys(tableColumns, leftColumns)\n    : slice(getFixedColumnKeys(tableColumns, rightColumns)).reverse();\n\n  const index = tableColumns.findIndex(({ key }) => key === tableColumn.key);\n  const fixedIndex = targetArray.indexOf(tableColumn.key);\n  const columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index)!;\n\n  const showLeftDivider = columnChain.start === index && index !== 0;\n  const showRightDivider = columnChain.start + columnChain.columns.length - 1 === index\n    && index < tableColumns.length - 1;\n\n  const position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);\n\n  return {\n    showRightDivider,\n    showLeftDivider,\n    position,\n    side,\n  };\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { FIXED_COLUMN_LEFT_SIDE, FIXED_COLUMN_RIGHT_SIDE, TABLE_FIXED_TYPE } from './constants';\nimport { splitHeaderColumnChains, generateSimpleChains } from '../table-header-row/helpers';\nimport {\n  FixedColumnName, TableColumn, FixedColumnSide, TableRow, HeaderColumnChainRows,\n  ShouldSplitChainFn,\n} from '../../types';\n\nexport const tableColumnsWithFixed: PureComputed<\n  [TableColumn[], FixedColumnName[], FixedColumnName[]]\n> = (\n  tableColumns, leftColumns, rightColumns,\n) => tableColumns\n  .map((tableColumn) => {\n    let fixed!: FixedColumnSide;\n    if ((tableColumn.type === TABLE_DATA_TYPE\n      && leftColumns.indexOf(tableColumn.column!.name) !== -1)\n      || leftColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_LEFT_SIDE;\n    }\n    if ((tableColumn.type === TABLE_DATA_TYPE\n      && rightColumns.indexOf(tableColumn.column!.name) !== -1)\n      || rightColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_RIGHT_SIDE;\n    }\n    return fixed ? { ...tableColumn, fixed } : tableColumn;\n  });\n\nexport const tableHeaderRowsWithFixed: PureComputed<[TableRow[]]> = tableHeaderRows => [\n  ...tableHeaderRows,\n  { key: TABLE_FIXED_TYPE.toString(), type: TABLE_FIXED_TYPE, height: 0 },\n];\n\nexport const tableHeaderColumnChainsWithFixed: PureComputed<\n  [HeaderColumnChainRows, TableRow[], TableColumn[]]\n> = (\n  tableHeaderColumnChains, tableHeaderRows, tableColumns,\n) => {\n  const chains = tableHeaderColumnChains\n    || generateSimpleChains(tableHeaderRows, tableColumns);\n\n  const shouldSplitChain: ShouldSplitChainFn = (currentGroup, column) => (\n    !currentGroup || (currentGroup as any).fixed !== column.fixed\n  );\n  const extendChainProps = (column: TableColumn) => ({\n    fixed: column.fixed,\n  });\n  return splitHeaderColumnChains(\n    chains,\n    tableColumns,\n    shouldSplitChain,\n    extendChainProps,\n  );\n};\n","import {\n  SummaryValue, SummaryCalculator,\n  DefaultSummaryCalculators,\n  Row,\n  TotalSummaryValuesFn,\n  GroupSummaryValuesFn,\n  TreeSummaryValuesFn,\n  RowsSummaryValuesFn,\n  ExpandRowsFn,\n  TableRow,\n  GroupLevel,\n} from '../../types';\n\nconst defaultSummaryCalculators: DefaultSummaryCalculators = {\n  count: rows => rows.length,\n  sum: (rows, getValue) => rows.reduce((acc, row) => acc + getValue(row), 0),\n  max: (rows, getValue) => (rows.length\n    ? rows.reduce((acc, row) => Math.max(acc, getValue(row)), -Infinity)\n    : null),\n  min: (rows, getValue) => (rows.length\n    ? rows.reduce((acc, row) => Math.min(acc, getValue(row)), Infinity)\n    : null),\n  avg: (rows, getValue) => (rows.length\n    ? rows.reduce((acc, row) => acc + getValue(row), 0) / rows.length\n    : null),\n};\n\nexport const defaultSummaryCalculator: SummaryCalculator = (type, rows, getValue) => {\n  const summaryCalculator = defaultSummaryCalculators[type];\n  if (!summaryCalculator) {\n    throw new Error(`The summary type '${type}' is not defined`);\n  }\n  return summaryCalculator(rows, getValue);\n};\n\nconst rowsSummary: RowsSummaryValuesFn = (\n  rows, summaryItems, getCellValue, calculator,\n) => summaryItems\n  .reduce((acc, { type, columnName }) => {\n    const getValue = (row: Row) => getCellValue(row, columnName);\n    acc.push(calculator(type, rows as any[], getValue));\n    return acc;\n  }, [] as SummaryValue[]);\n\nconst expandRows: ExpandRowsFn = (\n  rows, getRowLevelKey, getCollapsedRows, isGroupRow, includeGroupRow = false,\n) => {\n  const shouldIncludeRow = includeGroupRow || !isGroupRow\n    ? () => true\n    : (row: TableRow) => !isGroupRow(row);\n\n  return rows\n    .reduce((acc, row) => {\n      if (getRowLevelKey && getRowLevelKey(row)) {\n        if (shouldIncludeRow(row)) {\n          acc.push(row);\n        }\n        const collapsedRows = getCollapsedRows && getCollapsedRows(row);\n        if (collapsedRows) {\n          acc.push(...collapsedRows);\n        }\n        return acc;\n      }\n      acc.push(row);\n      return acc;\n    }, [] as TableRow[]);\n};\n\nexport const totalSummaryValues: TotalSummaryValuesFn = (\n  rows,\n  summaryItems,\n  getCellValue,\n  getRowLevelKey,\n  isGroupRow,\n  getCollapsedRows,\n  calculator = defaultSummaryCalculator,\n) => {\n  const plainRows = expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow);\n  return rowsSummary(plainRows, summaryItems, getCellValue, calculator);\n};\n\nexport const groupSummaryValues: GroupSummaryValuesFn = (\n  rows,\n  summaryItems,\n  getCellValue,\n  getRowLevelKey,\n  isGroupRow,\n  getCollapsedRows,\n  calculator = defaultSummaryCalculator,\n) => {\n  let levels: GroupLevel[] = [];\n  const getLevelIndex = (levelKey: string) => (\n    levels.findIndex(level => level.levelKey === levelKey)\n  );\n  const summaries = {};\n\n  const anyRowLevelSummaryExist = summaryItems.some(item => (\n    !(item as any).showInGroupFooter\n  ));\n  const expandedRows = anyRowLevelSummaryExist\n    ? expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow, true)\n    : rows;\n\n  expandedRows.forEach((row) => {\n    const levelKey = getRowLevelKey(row);\n    const collapsedRows = getCollapsedRows && getCollapsedRows(row);\n    let levelIndex = getLevelIndex(levelKey);\n    if (levelIndex > -1) {\n      levels.forEach((level) => {\n        summaries[level.row.compoundKey] = rowsSummary(\n          level.rows, summaryItems, getCellValue, calculator,\n        );\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n    if (isGroupRow!(row)) {\n      levels.push({\n        levelKey,\n        row,\n        rows: [],\n      });\n      levelIndex = getLevelIndex(levelKey);\n    }\n    // when row level summary exists, these rows had already been expanded earlier\n    const isCollapsedNestedGroupRow = collapsedRows && levelIndex > 0 && !anyRowLevelSummaryExist;\n    const rowsToAppend = !levelKey ? [row] : collapsedRows;\n    if (!levelKey || isCollapsedNestedGroupRow) {\n      levels.forEach((level) => {\n        level.rows.push(...rowsToAppend);\n      });\n    }\n  }, {});\n  levels.forEach((level) => {\n    summaries[level.row.compoundKey] = rowsSummary(\n      level.rows, summaryItems, getCellValue, calculator,\n    );\n  });\n  return summaries;\n};\n\nexport const treeSummaryValues: TreeSummaryValuesFn = (\n  rows,\n  summaryItems,\n  getCellValue,\n  getRowLevelKey,\n  isGroupRow,\n  getRowId,\n  calculator = defaultSummaryCalculator,\n) => {\n  let levels: any[] = [];\n  const summaries = {};\n  rows.forEach((row) => {\n    const levelKey = getRowLevelKey(row);\n    if (!levelKey) {\n      levels[levels.length - 1].rows.push(row);\n      return;\n    }\n    const levelIndex = levels.findIndex(level => level.levelKey === levelKey);\n    if (levelIndex > -1) {\n      levels.slice(levelIndex).forEach((level) => {\n        if (level.rows.length) {\n          summaries[getRowId(level.row)] = rowsSummary(\n            level.rows, summaryItems, getCellValue, calculator,\n          );\n        }\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n    if (!isGroupRow || !isGroupRow(row)) {\n      if (levels.length) {\n        levels[levels.length - 1].rows.push(row);\n      }\n      levels.push({\n        levelKey,\n        row,\n        rows: [],\n      });\n    }\n  }, {});\n  levels.forEach((level) => {\n    if (level.rows.length) {\n      summaries[getRowId(level.row)] = rowsSummary(\n        level.rows, summaryItems, getCellValue, calculator,\n      );\n    }\n  });\n  return summaries;\n};\n","export const TABLE_TOTAL_SUMMARY_TYPE = Symbol('totalSummary');\nexport const TABLE_GROUP_SUMMARY_TYPE = Symbol('groupSummary');\nexport const TABLE_TREE_SUMMARY_TYPE = Symbol('treeSummary');\n\nexport const defaultFormatlessSummaries = ['count'];\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  TABLE_TOTAL_SUMMARY_TYPE, TABLE_GROUP_SUMMARY_TYPE, TABLE_TREE_SUMMARY_TYPE,\n} from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  GetColumnSummariesFn, IsSpecificCellFn, IsSpecificRowFn, SummaryItem,\n  GetGroupInlineSummariesFn, ColumnInlineSummaries, GroupSummaryItem,\n} from '../../types';\n\nexport const isTotalSummaryTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isGroupSummaryTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isTreeSummaryTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isTotalSummaryTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_TOTAL_SUMMARY_TYPE\n);\nexport const isGroupSummaryTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_GROUP_SUMMARY_TYPE\n);\nexport const isTreeSummaryTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_TREE_SUMMARY_TYPE\n);\n\nexport const getColumnSummaries: GetColumnSummariesFn = (\n  summaryItems, columnName, summaryValues, predicate = () => true,\n) => summaryItems\n  .map((item, index) => [item, index] as [SummaryItem, number])\n  .filter(([item]) => item.columnName === columnName && predicate(item))\n  .map(([item, index]) => ({\n    type: item.type,\n    value: summaryValues[index],\n  }));\n\nexport const isFooterSummary: PureComputed<[SummaryItem], boolean> = summaryItem => (\n  (summaryItem as GroupSummaryItem).showInGroupFooter!\n);\nexport const isInlineGroupCaptionSummary: PureComputed<[SummaryItem], boolean> = summaryItem => (\n  !((summaryItem as GroupSummaryItem).showInGroupFooter ||\n  (summaryItem as GroupSummaryItem).alignByColumn)\n);\nexport const groupFooterSummaryExists: PureComputed<[GroupSummaryItem[]], boolean> =\n  groupSummaryItems => groupSummaryItems?.some(isFooterSummary);\n\nexport const getGroupInlineSummaries: GetGroupInlineSummariesFn = (\n  summaryItems, columns, summaryValues,\n) => {\n  if (!summaryItems.some(isInlineGroupCaptionSummary)) {\n    return [];\n  }\n\n  return columns.reduce((acc, column) => {\n    const colName = column.name;\n    const summaries = getColumnSummaries(\n      summaryItems, colName, summaryValues, isInlineGroupCaptionSummary,\n    );\n    if (summaries.length) {\n      acc.push({\n        column,\n        summaries,\n      });\n    }\n\n    return acc;\n  }, [] as ColumnInlineSummaries[]);\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  TABLE_TOTAL_SUMMARY_TYPE,\n  TABLE_GROUP_SUMMARY_TYPE,\n  TABLE_TREE_SUMMARY_TYPE,\n} from './constants';\nimport {\n  TableRow, RowLevel, TableRowsWithSummariesFn,\n} from '../../types';\nimport { groupFooterSummaryExists } from './helpers';\n\nexport const tableRowsWithTotalSummaries: PureComputed<[TableRow[]]> = footerRows => [\n  { key: TABLE_TOTAL_SUMMARY_TYPE.toString(), type: TABLE_TOTAL_SUMMARY_TYPE },\n  ...footerRows,\n];\n\nexport const tableRowsWithSummaries: TableRowsWithSummariesFn = (\n  tableRows, groupSummaryItems, treeSummaryItems, getRowLevelKey, isGroupRow, getRowId,\n) => {\n  const hasGroupFooterSummary = groupFooterSummaryExists(groupSummaryItems);\n  if (!getRowLevelKey || !(hasGroupFooterSummary || treeSummaryItems.length)) return tableRows;\n\n  const result: TableRow[] = [];\n  const closeLevel = (level: RowLevel) => {\n    if (!level.opened) return;\n    if (hasGroupFooterSummary && isGroupRow && isGroupRow(level.row)) {\n      const { compoundKey } = level.row;\n      result.push({\n        key: `${TABLE_GROUP_SUMMARY_TYPE.toString()}_${compoundKey}`,\n        type: TABLE_GROUP_SUMMARY_TYPE,\n        row: level.row,\n      });\n    } else if (treeSummaryItems.length) {\n      const rowId = getRowId(level.row);\n      result.push({\n        key: `${TABLE_TREE_SUMMARY_TYPE.toString()}_${rowId}`,\n        type: TABLE_TREE_SUMMARY_TYPE,\n        row: level.row,\n      });\n    }\n  };\n\n  let levels: RowLevel[] = [];\n  tableRows.forEach((tableRow) => {\n    const { row } = tableRow;\n    const levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      const levelIndex = levels.findIndex(level => level.levelKey === levelKey);\n      if (levelIndex > -1) {\n        levels.slice(levelIndex).reverse().forEach(closeLevel);\n        levels = levels.slice(0, levelIndex);\n      }\n      if (!isGroupRow || !isGroupRow(row)) {\n        levels = levels.map(level => ({\n          ...level,\n          opened: true,\n        }));\n      }\n      levels.push({\n        levelKey,\n        row,\n        opened: false,\n      });\n    } else {\n      levels = levels.map(level => ({\n        ...level,\n        opened: true,\n      }));\n    }\n    result.push(tableRow);\n  });\n  levels.slice().reverse().forEach(closeLevel);\n\n  return result;\n};\n","import { GroupSummaryItem } from '../../types';\n\nexport const prepareGroupSummaryItems = (items: GroupSummaryItem[]) => (\n  !!items\n    ? items.map(item => ({\n      ...item,\n      showInGroupFooter: (\n        item.showInGroupFooter === undefined && !item.alignByColumn\n      )\n        ? true\n        : item.showInGroupFooter,\n    }))\n    : items\n);\n","import { ReadonlyObject, PureComputed } from '@devexpress/dx-core';\nimport {\n  TABLE_FILTER_TYPE, TABLE_HEADING_TYPE, TABLE_DATA_TYPE, TABLE_BAND_TYPE,\n  TABLE_TOTAL_SUMMARY_TYPE, TABLE_STUB_TYPE,\n  TABLE_GROUP_TYPE,\n} from '@devexpress/dx-grid-core';\nimport {\n    GetNextFocusedElementFn, FocusedElement, TableColumn, TableRow,\n    GetElementFn, GetElementPrevNextPartFn, Elements, RowId, GetInnerElementsFn,\n    OnFocusedCellChangeFn, ScrollToColumnFn, GetNextPrevPartFn,\n    GetNextPrevCellFromBodyFn, GetPrevCellFromHeadingFn, GetNextCellFromHeadingFn,\n    GetCellNextPrevPartFn, FocusedElementWScrolling, InlineEditing,\n} from '../../types';\n\nconst HEADING_TYPE = TABLE_HEADING_TYPE.toString();\nconst FILTER_TYPE = TABLE_FILTER_TYPE.toString();\nconst DATA_TYPE = TABLE_DATA_TYPE.toString();\nconst BAND_TYPE = TABLE_BAND_TYPE.toString();\nconst TOTAL_SUMMARY_TYPE = TABLE_TOTAL_SUMMARY_TYPE.toString();\nconst STUB_TYPE = TABLE_STUB_TYPE.toString();\nconst GROUP_TYPE = TABLE_GROUP_TYPE.toString();\n\nconst tableParts = [HEADING_TYPE, FILTER_TYPE, DATA_TYPE, TOTAL_SUMMARY_TYPE];\n\nconst getIndex: PureComputed<[TableColumn[] | TableRow [], string], number> = (arr, key) => {\n  return arr.findIndex((el: TableColumn | TableRow) => {\n    return el.key === key;\n  });\n};\n\nconst isSpanInput: PureComputed<[any[]], boolean> = (innerElements) => {\n  return innerElements[0].tagName === 'SPAN' ||\n  innerElements[0].tagName === 'INPUT' && innerElements[0].type === 'text';\n};\n\nconst isDefined = (value: any): value is boolean => {\n  return value !== undefined;\n};\n\nconst hasInsideElements: PureComputed<[any[], number?], boolean> = (\n  innerElements, focusedElementIndex,\n) => {\n  if ((innerElements.length && focusedElementIndex === undefined) ||\n  (isDefined(focusedElementIndex) && focusedElementIndex < innerElements.length - 1)) {\n    if (innerElements.length === 1 && focusedElementIndex === undefined) {\n      return !isSpanInput(innerElements);\n    }\n    return true;\n  }\n  return false;\n};\n\nconst getIndexInnerElement: PureComputed<[\n  Elements, string, string, number,\n], number | undefined> = (\n  elements, rowKey, columnKey, direction,\n) => {\n  const innerElements = getInnerElements(elements, rowKey, columnKey);\n  const index = direction > 0 ? 0 : innerElements.length - 1;\n\n  return cellEmptyOrHasSpanAndInput(elements, rowKey, columnKey) ? undefined : index;\n};\n\nconst getNextPrevClosestColumnKey: PureComputed<\n  [TableColumn[], number, string, Elements, number], string | undefined\n> = (tableColumns, columnIndex, rowKey, elements, direction) => {\n  let columnKey;\n  if (direction > 0) {\n    for (let i = columnIndex; i <= tableColumns.length - 1; i += 1) {\n      if (elements[rowKey][tableColumns[i].key]) {\n        columnKey = tableColumns[i].key;\n        break;\n      }\n    }\n  } else {\n    for (let i = columnIndex; i >= 0; i -= 1) {\n      if (elements[rowKey][tableColumns[i].key]) {\n        columnKey = tableColumns[i].key;\n        break;\n      }\n    }\n  }\n  return columnKey;\n};\n\nconst shouldBeScrolled = (\n  elements: ReadonlyObject<Elements>, key1: string, key2: string,\n  scrollToColumn?: ScrollToColumnFn,\n): scrollToColumn is ScrollToColumnFn => {\n  if (scrollToColumn && !elements[key1][key2]) {\n    return Object.keys(elements[key1]).some((column) => {\n      return column.includes(STUB_TYPE);\n    });\n  }\n  return false;\n};\n\nconst convertPart: PureComputed<\n  [string, Elements, TableRow[]], string | void\n> = (part, elements, tableBodyRows) => {\n  if (part === DATA_TYPE && elements[tableBodyRows[0].key]) {\n    return DATA_TYPE;\n  }\n  if (elements[part]) {\n    return part;\n  }\n  return;\n};\n\nconst getLastPart: PureComputed<\n  [Elements, TableRow[], number?], string | void\n> = (elements, tableBodyRows, partIndex) => {\n  let index = partIndex || tableParts.length;\n  let part;\n\n  do {\n    index = index - 1;\n    part = convertPart(tableParts[index], elements, tableBodyRows);\n  } while (index > 0 && !part);\n\n  return part;\n};\n\nconst getRowKey: PureComputed<[string, string, string?]> = (part, key, headerRowKey) => {\n  if (headerRowKey && part === HEADING_TYPE) {\n    return headerRowKey;\n  }\n  return part === DATA_TYPE ? key : part;\n};\n\nconst getPrevPart: GetNextPrevPartFn = (\n  focusedElement, elements, tableBodyRows,\n) => {\n  const index = tableParts.findIndex((p) => {\n    return p === focusedElement.part;\n  });\n  if (index === 0) {\n    return;\n  }\n  return getLastPart(elements, tableBodyRows, index);\n};\n\nconst getNextPart: GetNextPrevPartFn = (\n  focusedElement, elements, tableBodyRows,\n) => {\n  const index = tableParts.findIndex((p) => {\n    return p === focusedElement.part;\n  });\n  if (index === tableParts.length - 1) {\n    return;\n  }\n  const part = tableParts.find((p, i) => {\n    if (i > index) {\n      return convertPart(p, elements, tableBodyRows);\n    }\n    return false;\n  });\n  return part;\n};\n\nconst getCellNextPart: GetElementPrevNextPartFn = (\n  focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn,\n) => {\n  const part = getNextPart(focusedElement, elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n\n  const rowKey = getRowKey(part, tableBodyRows[0].key);\n  const columnKey = tableColumns[0].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey,\n        columnKey,\n        part,\n      },\n      scrolling: 'left',\n    };\n  }\n  return {\n    element: {\n      rowKey,\n      columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n      part,\n    },\n  };\n};\n\nconst getCellPrevPart: GetElementPrevNextPartFn = (\n  focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn,\n) => {\n  const part = getPrevPart(focusedElement, elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n\n  const rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);\n  const columnKeyIndex = tableColumns.length - 1;\n  const columnKey = tableColumns[columnKeyIndex].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey,\n        columnKey,\n        part,\n      },\n      scrolling: 'right',\n    };\n  }\n  const nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnKeyIndex,\n    rowKey, elements, -1);\n  return {\n    element: nextColumnKey ? {\n      rowKey,\n      columnKey: nextColumnKey,\n      index: getIndexInnerElement(elements, rowKey, nextColumnKey, -1),\n      part,\n    } : undefined,\n  };\n};\n\nconst getPrevCellFromBody: GetNextPrevCellFromBodyFn = (\n  columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements,\n  scrollToColumn,\n) => {\n  let prevRowKey = focusedElement.rowKey;\n  let prevColumnKey;\n  if (columnIndex === 0 && rowIndex === 0) {\n    return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  if (columnIndex === 0) {\n    prevRowKey = tableBodyRows[rowIndex - 1].key;\n    if (prevRowKey.includes(GROUP_TYPE)) {\n      prevColumnKey = getNextPrevClosestColumnKey(\n        tableColumns, tableColumns.length - 1, prevRowKey, elements, -1,\n      );\n    } else {\n      prevColumnKey = tableColumns[tableColumns.length - 1].key;\n    }\n    if (prevColumnKey && shouldBeScrolled(elements, prevRowKey, prevColumnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey: prevRowKey,\n          columnKey: prevColumnKey,\n          part: focusedElement.part,\n        },\n        scrolling: 'right',\n      };\n    }\n  } else {\n    prevColumnKey = getNextPrevClosestColumnKey(\n      tableColumns, columnIndex - 1, prevRowKey, elements, -1,\n    );\n  }\n\n  return {\n    element: prevColumnKey ? {\n      rowKey: prevRowKey,\n      columnKey: prevColumnKey,\n      index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1),\n      part: focusedElement.part,\n    } : undefined,\n  };\n};\n\nconst getPrevCellFromHeading: GetPrevCellFromHeadingFn = (\n  tableHeaderRows, tableColumns, columnIndex,\n  { rowKey, part }, elements,\n) => {\n  let prevColumnKey;\n  let prevRowKey;\n  const headIndex = getIndex(tableHeaderRows, rowKey);\n  prevColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex - 1, rowKey, elements, -1);\n  if (prevColumnKey) {\n    return {\n      element: {\n        columnKey: prevColumnKey,\n        rowKey,\n        part,\n        index: getIndexInnerElement(elements, rowKey, prevColumnKey, -1),\n      },\n    };\n  }\n  if (headIndex > 0) {\n    let abort = false;\n    for (let i = headIndex - 1; i >= 0 && !abort; i -= 1) {\n      for (let j = tableColumns.length - 1; j >= 0; j -= 1) {\n        if (elements[tableHeaderRows[i].key][tableColumns[j].key]) {\n          prevColumnKey = tableColumns[j].key;\n          prevRowKey = tableHeaderRows[i].key;\n          abort = true;\n          break;\n        }\n      }\n    }\n    if (prevColumnKey && prevRowKey) {\n      return {\n        element: {\n          columnKey: prevColumnKey,\n          rowKey: prevRowKey,\n          part,\n          index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1),\n        },\n      };\n    }\n  }\n\n  return {};\n};\n\nconst getPrevElement: GetElementFn = (\n  focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn,\n) => {\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  const rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n\n  if (isDefined(focusedElement.index) && focusedElement.index > 0) {\n    return { element: { ...focusedElement, index: focusedElement.index - 1 } };\n  }\n\n  if (focusedElement.part === DATA_TYPE) {\n    return getPrevCellFromBody(columnIndex, rowIndex, tableColumns,\n      tableBodyRows, focusedElement, elements, scrollToColumn);\n  }\n\n  if (focusedElement.part === HEADING_TYPE) {\n    const cell = getPrevCellFromHeading(tableHeaderRows, tableColumns, columnIndex,\n      focusedElement, elements);\n    if (cell.element) {\n      return {\n        element: {\n          ...cell.element,\n          index: getIndexInnerElement(elements, cell.element.rowKey, cell.element.columnKey, -1),\n        },\n      };\n    }\n    return { element: cell.element };\n  }\n\n  if (columnIndex === 0) {\n    return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  const rowKey = focusedElement.part;\n  const columnKey = tableColumns[columnIndex - 1].key;\n  return {\n    element: {\n      rowKey,\n      columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, -1),\n      part: focusedElement.part,\n    },\n  };\n};\n\nconst getNextCellFromBody: GetNextPrevCellFromBodyFn = (\n  columnIndex, rowIndex, tableColumns,\n  tableBodyRows, focusedElement, elements, scrollToColumn,\n) => {\n  let nextRowKey = focusedElement.rowKey;\n  let nextColumnKey;\n\n  if (columnIndex === tableColumns.length - 1 && rowIndex === tableBodyRows.length - 1) {\n    return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  if (columnIndex === tableColumns.length - 1) {\n    nextRowKey = tableBodyRows[rowIndex + 1].key;\n    nextColumnKey = tableColumns[0].key;\n    if (shouldBeScrolled(elements, nextRowKey, nextColumnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey: nextRowKey,\n          columnKey: nextColumnKey,\n          part: focusedElement.part,\n        },\n        scrolling: 'left',\n      };\n    }\n  } else {\n    nextColumnKey = getNextPrevClosestColumnKey(\n      tableColumns, columnIndex + 1, nextRowKey, elements, 1,\n    );\n    if (!nextColumnKey) {\n      if (rowIndex === tableBodyRows.length - 1) {\n        return getCellNextPart(\n          focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn,\n        );\n      }\n      nextRowKey = tableBodyRows[rowIndex + 1].key;\n      nextColumnKey = tableColumns[0].key;\n    }\n  }\n\n  return {\n    element: {\n      rowKey: nextRowKey,\n      columnKey: nextColumnKey,\n      index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1),\n      part: focusedElement.part,\n    },\n  };\n};\n\nconst getNextCellFromHeading: GetNextCellFromHeadingFn = (\n  tableHeaderRows, tableBodyRows, tableColumns,\n  columnIndex, focusedElement, elements,\n  scrollToColumn,\n) => {\n  const headIndex = getIndex(tableHeaderRows, focusedElement.rowKey);\n  let nextRowKey;\n  let nextColumnKey = getNextPrevClosestColumnKey(\n    tableColumns, columnIndex + 1, focusedElement.rowKey, elements, 1,\n  );\n  if (nextColumnKey) {\n    return {\n      element: {\n        columnKey: nextColumnKey,\n        rowKey: focusedElement.rowKey,\n        part: focusedElement.part,\n        index: getIndexInnerElement(elements, focusedElement.rowKey, nextColumnKey, 1),\n      },\n    };\n  }\n  if (headIndex !== tableHeaderRows.length - 1) {\n    let abort = false;\n    for (let i = headIndex + 1; i <= tableHeaderRows.length - 1 && !abort; i += 1) {\n      for (let j = 0; j <= tableColumns.length - 1; j += 1) {\n        if (elements[tableHeaderRows[i].key][tableColumns[j].key]) {\n          nextColumnKey = tableColumns[j].key;\n          nextRowKey = tableHeaderRows[i].key;\n          abort = true;\n          break;\n        }\n      }\n    }\n    if (nextColumnKey && nextRowKey) {\n      return {\n        element: {\n          columnKey: nextColumnKey,\n          rowKey: nextRowKey,\n          part: focusedElement.part,\n          index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1),\n        },\n      };\n    }\n  }\n\n  return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n};\n\nconst getNextElement: GetElementFn = (\n  focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn,\n) => {\n  const innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  const rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n\n  if (hasInsideElements(innerElements, focusedElement.index)) {\n    return {\n      element: {\n        ...focusedElement,\n        index: !isDefined(focusedElement.index) ? 0 : focusedElement.index + 1,\n      },\n    };\n  }\n\n  if (focusedElement.part === DATA_TYPE) {\n    return getNextCellFromBody(columnIndex, rowIndex, tableColumns,\n      tableBodyRows, focusedElement, elements, scrollToColumn);\n  }\n\n  if (focusedElement.part === HEADING_TYPE) {\n    return getNextCellFromHeading(tableHeaderRows, tableBodyRows, tableColumns, columnIndex,\n      focusedElement, elements, scrollToColumn);\n  }\n\n  if (columnIndex === tableColumns.length - 1) {\n    return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n\n  const rowKey = focusedElement.rowKey;\n  const columnKey = tableColumns[columnIndex + 1].key;\n  return {\n    element: {\n      rowKey,\n      columnKey,\n      part: focusedElement.part,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n    },\n  };\n};\n\nconst hasCellInput: PureComputed<[any], boolean> = (innerElements) => {\n  return innerElements.length ? innerElements[0].tagName === 'INPUT' : false;\n};\n\nconst cellEmptyOrHasSpanAndInput: PureComputed<[\n  Elements, string, string\n], boolean> = (elements, key1, key2) => {\n  const innerElements = getInnerElements(elements, key1, key2);\n  if (innerElements.length) {\n    return isSpanInput(innerElements);\n  }\n  return true;\n};\n\nconst getCellRightLeft: PureComputed<[number, FocusedElement, TableColumn[], Elements],\nFocusedElement | undefined> = (\n  direction, focusedElement, tableColumns, elements,\n) => {\n  if (focusedElement.part !== DATA_TYPE) {\n    return;\n  }\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  if (tableColumns[columnIndex + direction]) {\n    const columnKey = getNextPrevClosestColumnKey(\n      tableColumns, columnIndex + direction, focusedElement.rowKey, elements, direction,\n    );\n    if (columnKey) {\n      return {\n        rowKey: focusedElement.rowKey,\n        columnKey,\n        part: focusedElement.part,\n      };\n    }\n  }\n  return;\n};\n\nconst getFirstCell: PureComputed<\n  [Elements, TableRow[], TableColumn[], TableRow[], ScrollToColumnFn?, boolean?],\n  FocusedElementWScrolling\n> = (\n  elements, tableBodyRows, tableColumns, tableHeaderRows, scrollToColumn, withInnerElements,\n) => {\n  const part = tableParts.find((p) => {\n    return convertPart(p, elements, tableBodyRows);\n  });\n  if (!part) {\n    return {};\n  }\n  const rowKey = getRowKey(part, tableBodyRows[0].key, tableHeaderRows[0].key);\n  const columnKey = tableColumns[0].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey,\n        columnKey,\n        part,\n      },\n      scrolling: 'left',\n    };\n  }\n\n  return {\n    element: {\n      rowKey,\n      columnKey,\n      index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : undefined,\n      part,\n    },\n  };\n};\n\nconst getLastCell: PureComputed<[Elements, TableRow[], TableColumn[]], FocusedElementWScrolling> = (\n  elements, tableBodyRows, tableColumns,\n) => {\n  const part = getLastPart(elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n\n  const rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);\n  const columnKey = getNextPrevClosestColumnKey(\n    tableColumns, tableColumns.length - 1, rowKey, elements, -1,\n  );\n\n  return {\n    element: columnKey ? {\n      rowKey,\n      columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n      part,\n    } : undefined,\n  };\n};\n\nconst getToolbarPagingElements: PureComputed<[Elements]> = (elements) => {\n  return {\n    toolbarElements: elements.toolbar && getInnerElements(elements, 'toolbar', 'none'),\n    pagingElements: elements.paging && getInnerElements(elements, 'paging', 'none')\n    .filter((el: any) => {\n      return !el.hasAttribute('disabled') && el.getAttribute('tabindex') !== '-1';\n    }),\n  };\n};\n\nconst getFirstCellInLastPart: PureComputed<[\n  Elements, TableRow[], TableColumn[], ScrollToColumnFn?, boolean?\n], FocusedElementWScrolling> = (\n  elements, tableBodyRows, tableColumns, scrollToColumn, withInnerElements,\n) => {\n  const lastPart = getLastPart(elements, tableBodyRows);\n  if (lastPart) {\n    const columnKey = tableColumns[0].key;\n    const rowKey = getRowKey(lastPart, tableBodyRows[0].key);\n    if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey,\n          columnKey,\n          part: lastPart,\n        },\n        scrolling: 'left',\n      };\n    }\n    return {\n      element: {\n        columnKey,\n        rowKey,\n        index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : undefined,\n        part: lastPart,\n      },\n    };\n  }\n  return {};\n};\n\nconst applyEnterAction: PureComputed<[\n  Elements, InlineEditing, TableColumn[], TableRow[], FocusedElement?\n], FocusedElement | undefined> = (\n  elements, { commitChangedRows, stopEditCells, startEditCells },\n  tableColumns, tableBodyRows, focusedElement,\n) => {\n  if (!focusedElement) {\n    return;\n  }\n  const innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  const rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n\n  if (focusedElement.part === DATA_TYPE && commitChangedRows) {\n    if (focusedElement.index === 0) {\n      commitChangedRows({ rowIds: [tableBodyRows[rowIndex].rowId] });\n      stopEditCells!({\n        editingCells: [{\n          rowId: tableBodyRows[rowIndex].rowId,\n          columnName: tableColumns[columnIndex].column!.name,\n        }],\n      });\n      return {\n        part: focusedElement.part,\n        columnKey: focusedElement.columnKey,\n        rowKey: focusedElement.rowKey,\n      };\n    }\n    startEditCells!({\n      editingCells: [{\n        rowId: tableBodyRows[rowIndex].rowId,\n        columnName: tableColumns[columnIndex].column!.name,\n      }],\n    });\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n      index: 0,\n    };\n\n  }\n  if (!isDefined(focusedElement.index) && innerElements.length && isSpanInput(innerElements)) {\n    if (innerElements[0].tagName === 'SPAN') {\n      innerElements[0].click();\n    }\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n      index: 0,\n    };\n  }\n\n  if (focusedElement.index === 0 && hasCellInput(innerElements)) {\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n    };\n  }\n\n  return;\n};\n\nconst applyEscapeAction: PureComputed<[\n  Elements, InlineEditing, TableColumn[], TableRow[], FocusedElement?\n], FocusedElement | undefined> = (\n  elements, { cancelChangedRows, stopEditCells }, tableColumns, tableBodyRows, focusedElement,\n) => {\n  if (!focusedElement) {\n    return;\n  }\n  const innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  const rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n\n  if (focusedElement.index === 0 && hasCellInput(innerElements)) {\n    if (focusedElement.part === DATA_TYPE && cancelChangedRows) {\n      cancelChangedRows({\n        rowIds: [tableBodyRows[rowIndex].rowId],\n      });\n      stopEditCells!({\n        editingCells: [{\n          rowId: tableBodyRows[rowIndex].rowId,\n          columnName: tableColumns[columnIndex].column!.name,\n        }],\n      });\n    }\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n    };\n  }\n  return;\n};\n\nconst actionOnCheckbox: PureComputed<[Elements, FocusedElement?], void> = (\n  elements, focusedElement,\n) => {\n  if (!focusedElement || isDefined(focusedElement.index)) {\n    return;\n  }\n\n  const el = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey, 'input')\n  .filter((element: any) => {\n    return element.type === 'checkbox';\n  });\n  if (el[0]) {\n    el[0].click();\n  }\n};\n\nconst actionOnTreeMode: PureComputed<[Elements, RowId[], number, FocusedElement], void> = (\n  elements, expandedRowIds, direction, focusedElement,\n) => {\n  if (!focusedElement || isDefined(focusedElement.index) || !expandedRowIds) {\n    return;\n  }\n  const el = getInnerElements(\n    elements, focusedElement.rowKey, focusedElement.columnKey, 'button, i',\n  );\n  const index = getIndexFromKey(focusedElement.rowKey);\n  if (direction > 0 && expandedRowIds.indexOf(index) === -1 ||\n  direction < 0 && expandedRowIds.indexOf(index) > -1) {\n    if (el[0]) {\n      el[0].click();\n    }\n  }\n};\n\nexport const getInnerElements: GetInnerElementsFn = (\n  elements, key1, key2, query = '[tabIndex], input, button, a',\n) => {\n  return Array.from(elements[key1][key2][0].current.querySelectorAll(query)).filter((el: any) => {\n    return !el.hasAttribute('disabled') && el.getAttribute('tabindex') !== '-1';\n  });\n};\n\nconst getCellTopBottom: PureComputed<[number, FocusedElement, TableRow[], TableColumn[], Elements],\nFocusedElement | undefined> = (\n  direction, focusedElement, tableBodyRows, tableColumns, elements,\n) => {\n  if (focusedElement.part !== DATA_TYPE) {\n    return;\n  }\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  const rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (tableBodyRows[rowIndex + direction]) {\n    const columnKey = getNextPrevClosestColumnKey(\n      tableColumns, columnIndex, tableBodyRows[rowIndex + direction].key, elements, -1,\n    );\n    if (columnKey) {\n      return {\n        rowKey: tableBodyRows[rowIndex + direction].key,\n        columnKey,\n        part: focusedElement.part,\n      };\n    }\n  }\n  return;\n};\n\nconst isCtrlMetaKey = (event: any) => {\n  return event.ctrlKey || event.metaKey;\n};\n\nconst getIndexFromKey = (key: string) => {\n  const array = key.split('_');\n  return Number(array[array.length - 1]);\n};\n\nconst getCellNextPrevPart: GetCellNextPrevPartFn = (focusedElement, elements,\n  tableBodyRows, tableColumns, direction,\n  scrollToColumn) => {\n  const part = direction > 0 ? getNextPart(focusedElement, elements, tableBodyRows) :\n  getPrevPart(focusedElement, elements, tableBodyRows);\n  if (part) {\n    const rowKey = getRowKey(part, tableBodyRows[0].key);\n    const columnKey = tableColumns[0].key;\n    return {\n      element: {\n        part,\n        rowKey,\n        columnKey,\n      },\n      scrolling: shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn) ? 'left' : undefined,\n    };\n  }\n\n  return {};\n};\n\nconst applyFocusOnToolbarPaging: PureComputed<\n  [Elements, number], void\n> = (elements, direction) => {\n  if (direction > 0 && elements.paging) {\n    getInnerElements(elements, 'paging', 'none')[0].focus();\n  }\n  if (direction < 0 && elements.toolbar) {\n    getInnerElements(elements, 'toolbar', 'none')[0].focus();\n  }\n};\n\nexport const getClosestCellByRow: PureComputed<\n  [TableRow[], FocusedElement, Elements], FocusedElement\n> = (\n  tableBodyRows, focusedElement, elements,\n) => {\n  const currentIndex = getIndexFromKey(focusedElement.rowKey);\n  const bodyRow = tableBodyRows.find((row) => {\n    return getIndexFromKey(row.key) > currentIndex;\n  });\n  const rowKey = bodyRow ? bodyRow.key : tableBodyRows[tableBodyRows.length - 1].key;\n  const columnKey = focusedElement.columnKey;\n  return {\n    rowKey,\n    columnKey,\n    part: focusedElement.part,\n    index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n  };\n};\n\nexport const getNextFocusedCell: GetNextFocusedElementFn = (\n  tableColumns, tableBodyRows, tableHeaderRows,\n  expandedRowIds, elements, event, inlineEditing, focusedElement,\n  scrollToColumn,\n) => {\n  if (!focusedElement) {\n    const { toolbarElements, pagingElements } = getToolbarPagingElements(elements);\n    const hasFocus = (innerElements: readonly any[]) => {\n      return innerElements.some((el: any) => {\n        return event.target === el;\n      });\n    };\n    if (isCtrlMetaKey(event)) {\n      if (event.key === 'ArrowDown' &&\n      (toolbarElements && hasFocus(toolbarElements) || !toolbarElements)) {\n        return getFirstCell(elements, tableBodyRows, tableColumns,\n          tableHeaderRows, scrollToColumn);\n      }\n      if (event.key === 'ArrowUp' &&\n      (pagingElements && hasFocus(pagingElements) || !pagingElements)) {\n        return getFirstCellInLastPart(elements, tableBodyRows, tableColumns, scrollToColumn);\n      }\n    } else if (event.key === 'Tab') {\n      if (toolbarElements && event.target === toolbarElements[toolbarElements.length - 1] &&\n         !event.shiftKey) {\n        return getFirstCell(elements, tableBodyRows, tableColumns,\n          tableHeaderRows, scrollToColumn, true);\n      }\n      if (pagingElements && event.target === pagingElements[0] && event.shiftKey) {\n        if (scrollToColumn) {\n          return getFirstCellInLastPart(elements, tableBodyRows,\n            tableColumns, scrollToColumn, true);\n        }\n        return getLastCell(elements, tableBodyRows, tableColumns);\n      }\n      const { element } = !event.shiftKey ? getFirstCell(elements, tableBodyRows, tableColumns,\n        tableHeaderRows, undefined, true) :\n        getLastCell(elements, tableBodyRows, tableColumns);\n\n      if (element &&\n        event.target === elements[element.rowKey][element.columnKey][0].current) {\n        return { element };\n      }\n    }\n    return {};\n  }\n  let cell;\n  switch (event.key) {\n    case 'Enter':\n      cell = {\n        element: applyEnterAction(elements, inlineEditing, tableColumns,\n          tableBodyRows, focusedElement),\n      };\n      break;\n    case 'Escape':\n      cell = {\n        element: applyEscapeAction(elements, inlineEditing, tableColumns,\n          tableBodyRows, focusedElement),\n      };\n      break;\n    case ' ':\n      actionOnCheckbox(elements, focusedElement);\n      break;\n    case 'Tab':\n      if (event.shiftKey) {\n        cell = getPrevElement(focusedElement, tableBodyRows, tableColumns,\n          tableHeaderRows, elements, scrollToColumn);\n      } else {\n        cell = getNextElement(focusedElement, tableBodyRows, tableColumns,\n          tableHeaderRows, elements, scrollToColumn);\n      }\n      break;\n    case 'ArrowUp':\n      if (isCtrlMetaKey(event)) {\n        cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows,\n          tableColumns, -1, scrollToColumn);\n        if (!cell.element) {\n          applyFocusOnToolbarPaging(elements, -1);\n        }\n      } else {\n        cell = {\n          element: getCellTopBottom(-1, focusedElement, tableBodyRows, tableColumns, elements),\n        };\n      }\n      break;\n    case 'ArrowDown':\n      if (isCtrlMetaKey(event)) {\n        cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows,\n          tableColumns, 1, scrollToColumn);\n        if (!cell.element) {\n          applyFocusOnToolbarPaging(elements, 1);\n        }\n      } else {\n        cell = {\n          element: getCellTopBottom(1, focusedElement, tableBodyRows, tableColumns, elements),\n        };\n      }\n      break;\n    case 'ArrowLeft':\n      if (isCtrlMetaKey(event)) {\n        actionOnTreeMode(elements, expandedRowIds, -1, focusedElement);\n      } else {\n        cell = { element: getCellRightLeft(-1, focusedElement, tableColumns, elements) };\n      }\n      break;\n    case 'ArrowRight':\n      if (isCtrlMetaKey(event)) {\n        actionOnTreeMode(elements, expandedRowIds, 1, focusedElement);\n      } else {\n        cell = { element: getCellRightLeft(1, focusedElement, tableColumns, elements) };\n      }\n      break;\n  }\n  return cell || {};\n};\n\nexport const getPart = (key: string): string => {\n  if (tableParts.find(t => t === key)) {\n    return key;\n  }\n  if (key.includes(BAND_TYPE)) {\n    return HEADING_TYPE;\n  }\n  return DATA_TYPE;\n};\n\nexport const getIndexToFocus: PureComputed<[\n  string, string, Elements, any, InlineEditing, string,\n], number | undefined> = (\n  key1, key2, elements, event, { startEditCells }, part,\n) => {\n  if (startEditCells && part === DATA_TYPE) {\n    return 0;\n  }\n  const innerElements = getInnerElements(elements, key1, key2);\n  const index = innerElements.findIndex((el) => {\n    return event.target === el;\n  });\n  return index !== -1 ? index : undefined;\n};\n\nexport const filterHeaderRows = (tableHeaderRows: TableRow[]) => {\n  return tableHeaderRows.filter(row =>\n    row.key.includes(BAND_TYPE) || row.key.includes(HEADING_TYPE));\n};\n\nexport const isRowFocused: PureComputed<[TableRow, string?], boolean> = (\n  tableRow, focusedRowKey,\n) => {\n  if (focusedRowKey) {\n    return tableRow.key === focusedRowKey;\n  }\n  return false;\n};\n\nexport const isCellExist: PureComputed<[Elements, FocusedElement], boolean> = (\n  elements, focusedElement,\n) => {\n  return !!(elements[focusedElement.rowKey] &&\n    elements[focusedElement.rowKey][focusedElement.columnKey]);\n};\n\nexport const isTabArrowUpDown = (event: any): boolean => {\n  return event.key === 'Tab' || isCtrlMetaKey(event) && (event.key === 'ArrowDown' || event.key === 'ArrowUp');\n};\n\nexport const focus: PureComputed<\n  [Elements, FocusedElement?,\n  FocusedElement?, OnFocusedCellChangeFn?], void\n> = (\n  elements, focusedElement, prevFocusedElement, onFocusedCellChange,\n) => {\n  if (!focusedElement || !elements[focusedElement.rowKey] ||\n      !elements[focusedElement.rowKey][focusedElement.columnKey]) {\n    return;\n  }\n  const el = focusedElement.index === undefined ?\n  elements[focusedElement.rowKey][focusedElement.columnKey][0] :\n  getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey)[focusedElement.index];\n\n  if (el) {\n    el.focus ? el.focus() : el.current.focus();\n    if (onFocusedCellChange &&\n        (prevFocusedElement?.rowKey !== focusedElement.rowKey ||\n          prevFocusedElement?.columnKey !== focusedElement.columnKey)) {\n      onFocusedCellChange({\n        rowKey: focusedElement.rowKey, columnKey: focusedElement.columnKey,\n      });\n    }\n  }\n};\n\nexport const isCellFocused: PureComputed<[\n  TableRow, TableColumn, FocusedElement?\n], boolean> = (row, column, focusedElement) => {\n  if (!focusedElement || isDefined(focusedElement.index)) {\n    return false;\n  }\n  return focusedElement.rowKey === row.key && focusedElement.columnKey === column.key;\n};\n","import {\n    FocusedElement, TableRow,\n} from '../../types';\n\nexport const getFocusing = (tableBodyRows: TableRow[], focusedElement?: FocusedElement) => {\n  if (!focusedElement) {\n    return [];\n  }\n  const focusedRow = tableBodyRows.find((row) => {\n    return row.key === focusedElement.rowKey;\n  });\n  return focusedRow ? [focusedRow.rowId] : [];\n};\n","import { GetTargetColumnGeometriesFn, GetNodeGeometriesFn } from '../types';\n\nexport const getTargetColumnGeometries: GetTargetColumnGeometriesFn = (\n  columnGeometries, sourceIndex,\n) => {\n  const sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;\n  const getWidthDifference = (index: number) => columnGeometries[index].right\n                                      - columnGeometries[index].left\n                                      - sourceWidth;\n\n  return columnGeometries\n    .map(({\n      top, right, bottom, left,\n    }, targetIndex) => {\n      let leftBorder = left;\n      if (targetIndex > 0 && targetIndex <= sourceIndex) {\n        leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));\n      }\n      if (targetIndex > sourceIndex) {\n        leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));\n      }\n      let rightBorder = right;\n      if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {\n        rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));\n      }\n      if (targetIndex < sourceIndex) {\n        rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));\n      }\n\n      return {\n        top,\n        bottom,\n        right: rightBorder,\n        left: leftBorder,\n      };\n    });\n};\n\nexport const getCellGeometries: GetNodeGeometriesFn = (node) => {\n  const { left, right, width } = node.getBoundingClientRect();\n  const styleLeft = parseInt(node.style.left?.toString().replace('px', ''), 10);\n  const styleRight = parseInt(node.style.right?.toString().replace('px', ''), 10);\n\n  if (!isNaN(styleLeft)) {\n    const calculatedLeft = Math.max(styleLeft, left);\n    return {\n      left: calculatedLeft,\n      right: calculatedLeft + width,\n      isFixed: true,\n    };\n  }\n\n  if (!isNaN(styleRight)) {\n    // NOTE: get tableContainer (parent of first DIV element) to calculate 'right' value\n    let tableContainer = node as HTMLElement | null;\n    while (tableContainer && tableContainer.nodeName !== 'DIV') {\n      tableContainer = tableContainer.parentNode as HTMLElement;\n    }\n    tableContainer = tableContainer?.parentNode as HTMLElement;\n\n    if (tableContainer) {\n      const { width: tableWidth } = tableContainer.getBoundingClientRect();\n      const calculatedRight = Math.min(tableWidth - styleRight, right);\n      return {\n        left: calculatedRight - width,\n        right: calculatedRight,\n        isFixed: true,\n      };\n    }\n  }\n\n  return { left, right };\n};\n","import { easeOutCubic } from '@devexpress/dx-core';\nimport {\n  GetTableColumnGeometriesFn, GetTableTargetColumnIndexFn, ColumnAnimation,\n  GetColumnAnimationsFn, ColumnGeometry, FilterActiveAnimationsFn, EvalAnimationsFn,\n} from '../types';\n\nexport const getTableColumnGeometries: GetTableColumnGeometriesFn = (columns, tableWidth) => {\n  const columnWidths = columns\n    .map(column => column.width);\n\n  const freeSpace = tableWidth;\n  const restrictedSpace = columnWidths\n    .reduce(\n      (accum, width) => (accum as number)! + (typeof width === 'number' ? width : 0), 0) as number;\n  const freeSpacePortions = columnWidths\n    .reduce(\n      (accum, width) => (accum as number)! + (typeof width !== 'number' ? 1 : 0), 0) as number;\n  const freeSpacePortion = (freeSpace - restrictedSpace!) / freeSpacePortions!;\n\n  let lastRightPosition = 0;\n  return columnWidths\n    .map(width => (typeof width !== 'number' ? freeSpacePortion : width))\n    .map((width) => {\n      lastRightPosition += width;\n      return {\n        left: lastRightPosition - width,\n        right: lastRightPosition,\n      };\n    });\n};\n\nexport const getTableTargetColumnIndex: GetTableTargetColumnIndexFn = (\n  columnGeometries, offset,\n) => {\n  const indexes = columnGeometries.reduce((acc, { left, right }, index) => {\n    if (offset >= left && offset < right) {\n      acc.push(index);\n    }\n    return acc;\n  }, [] as number[]);\n\n  if (columnGeometries.some(({ left, right }) => left <= 0 && right <= 0)) {\n    if (indexes.some(index => columnGeometries[index].isFixed ||\n      columnGeometries[index].left <= 0 && columnGeometries[index].right <= 0)) {\n      return -1;\n    }\n  }\n\n  if (indexes.length === 2) {\n    return indexes.find(index => columnGeometries[index].isFixed)!;\n  }\n  if (indexes.length === 1) {\n    return indexes[0];\n  }\n  return -1;\n};\n\nconst ANIMATION_DURATION = 200;\n\nconst getAnimationProgress = (animation: ColumnAnimation) => (\n  new Date().getTime() - animation.startTime) / ANIMATION_DURATION;\n\nexport const getAnimations: GetColumnAnimationsFn = (\n  prevColumns,\n  nextColumns,\n  tableWidth,\n  prevAnimations,\n) => {\n  const resizing = prevColumns.map(column => column.key).join()\n    === nextColumns.map(column => column.key).join();\n\n  const prevColumnGeometries = new Map<string, ColumnGeometry>(\n    getTableColumnGeometries(prevColumns, tableWidth)\n      .map((geometry, index) => [prevColumns[index].key, geometry] as [string, ColumnGeometry])\n      .map(([key, geometry]) => {\n        const animation = prevAnimations.get(key);\n        if (!animation) return [key, geometry];\n        const progress = easeOutCubic(getAnimationProgress(animation));\n        const { to, from } = animation.left!;\n        const left = ((to - from) * progress) + from;\n        return [key, {\n          left,\n          right: geometry.right - (geometry.left - left),\n        }];\n      // tslint:disable-next-line:array-type\n      }) as [string, ColumnGeometry][],\n    );\n\n  const nextColumnGeometries = new Map(\n    getTableColumnGeometries(nextColumns, tableWidth)\n      // tslint:disable-next-line:array-type\n      .map((geometry, index) => [nextColumns[index].key, geometry]) as [string, ColumnGeometry][],\n  );\n\n  return new Map([...nextColumnGeometries.keys()]\n    .map((key) => {\n      const prev: any = prevColumnGeometries.get(key);\n      const next: any = nextColumnGeometries.get(key);\n\n      const result: ColumnAnimation = { startTime: new Date().getTime(), style: {} };\n      const takePrevColumnIntoAccount = !!prevAnimations.get(key) || (prev && !resizing);\n      if (Math.abs((takePrevColumnIntoAccount ? prev!.left : next!.left) - next!.left) > 1) {\n        result.left = { from: prev.left, to: next.left };\n      }\n      return [key, result] as [string, ColumnAnimation];\n    })\n    .filter((animation: [string, ColumnAnimation]) => animation[1].left));\n};\n\nexport const filterActiveAnimations: FilterActiveAnimationsFn = animations => new Map(\n  [...animations.entries()]\n    .filter(([, animation]) => getAnimationProgress(animation) < 1),\n);\n\nexport const evalAnimations: EvalAnimationsFn = animations => new Map([...animations.entries()]\n  .map(([key, animation]): [string, object] => {\n    const progress = easeOutCubic(getAnimationProgress(animation));\n    const result = { ...animation.style };\n    if (animation.left) {\n      const offset = (animation.left.to - animation.left.from) * (progress - 1);\n      (result as any).transform = `translateX(${offset}px)`;\n    }\n    return [key, result];\n  }));\n","import { getTargetColumnGeometries } from './column-geometries';\nimport { TargetColumnGeometry, GetGroupCellTargetIndexFn } from '../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nconst isOnTheSameLine: PureComputed<[TargetColumnGeometry, number], boolean> = (geometry, y) => (\n  y >= geometry.top && y <= geometry.bottom\n);\n\nconst rectToObject = ({\n  top, right, bottom, left,\n}: TargetColumnGeometry) => ({\n  top, right, bottom, left,\n});\n\nconst collapseGapsBetweenItems: PureComputed<[TargetColumnGeometry[]]> = geometries => (\n  geometries.map((geometry, index) => {\n    if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {\n      return {\n        ...geometry,\n        right: geometries[index + 1].left,\n      };\n    }\n    return geometry;\n  }));\n\nexport const getGroupCellTargetIndex: GetGroupCellTargetIndexFn = (\n  geometries, sourceIndex, { x, y },\n) => {\n  if (geometries.length === 0) return 0;\n\n  const targetGeometries = sourceIndex !== -1\n    ? getTargetColumnGeometries(geometries, sourceIndex)\n    : geometries.map(rectToObject);\n\n  const targetIndex = collapseGapsBetweenItems(targetGeometries)\n    .findIndex((geometry, index) => {\n      const inVerticalBounds = isOnTheSameLine(geometry, y);\n      const inHorizontalBounds = x >= geometry.left && x <= geometry.right;\n      const shouldGoFirst = index === 0 && x < geometry.left;\n      const shouldGoOnLineBreak = !inVerticalBounds\n        && !!geometries[index - 1]\n        && isOnTheSameLine(geometries[index - 1], y);\n\n      return (inVerticalBounds && inHorizontalBounds)\n        || shouldGoFirst\n        || shouldGoOnLineBreak;\n    });\n\n  return targetIndex === -1 ? geometries.length : targetIndex;\n};\n","import { PureComputed } from '@devexpress/dx-core';\n\ntype CompareFn = (...args: [any, any]) => boolean;\n/** @internal */\nexport const arraysEqual: PureComputed<[any[], any[], CompareFn?], boolean> = (\n  arrA, arrB, comparator = (a, b) => a === b,\n) => {\n  if (arrA.length !== arrB.length) {\n    return false;\n  }\n  for (let i = 0; i < arrA.length; i += 1) {\n    if (!comparator(arrA[i], arrB[i])) {\n      return false;\n    }\n  }\n  return true;\n};\n","import { GridViewport } from '../../types';\n\n/** @internal */\nexport const emptyViewport: GridViewport = {\n  columns: [[0, 0]],\n  rows: [0, 0],\n  headerRows: [0, 0],\n  footerRows: [0, 0],\n  top: 0,\n  left: 0,\n  width: 800,\n  height: 600,\n};\n\nexport const TOP_POSITION = Symbol('top');\nexport const BOTTOM_POSITION = Symbol('bottom');\nexport const LEFT_POSITION = Symbol('left');\nexport const RIGHT_POSITION = Symbol('right');\n","import {\n  getRowsVisibleBoundary, getColumnBoundaries,\n} from '../../utils/virtual-table';\nimport {\n  GetViewportFn,\n  CheckTableColumnWidths,\n  TableColumn,\n  GetScrollHeightByIndex,\n  GetScrollPosition,\n  GetTopRowId,\n  GetScrollLeft,\n  IsColumnsWidthDifferent,\n} from '../../types';\nimport { arraysEqual } from './utils';\nimport { TOP_POSITION, BOTTOM_POSITION, LEFT_POSITION } from './constants';\n\nconst VALID_UNITS = ['px', ''];\n/* tslint:disable max-line-length */\nconst VIRTUAL_TABLE_ERROR = 'The columnExtension property of the VirtualTable plugin is given an invalid value.';\n\nexport const getViewport: GetViewportFn = (\n  state, getters, getRowHeight, getColumnWidth,\n) => {\n  const {\n    viewportTop, skipItems, viewportLeft, containerWidth, containerHeight,\n  } = state;\n  const {\n    loadedRowsStart,\n    bodyRows: tableBodyRows,\n    columns: tableColumns,\n    headerRows: tableHeaderRows = [],\n    footerRows: tableFooterRows = [],\n    isDataRemote,\n    viewport,\n  } = getters;\n\n  const rows = getRowsVisibleBoundary(\n    tableBodyRows, viewportTop, containerHeight,\n    getRowHeight, skipItems, loadedRowsStart, isDataRemote,\n  );\n  const headerRows = getRowsVisibleBoundary(\n    tableHeaderRows, 0, 0,\n    getRowHeight, [0, 0], 0, false,\n  );\n  const footerRows = getRowsVisibleBoundary(\n    tableFooterRows, 0, 0,\n    getRowHeight, [0, 0], 0, false,\n  );\n  const columns = getColumnBoundaries(\n    tableColumns, viewportLeft, containerWidth, getColumnWidth,\n  );\n\n  // NOTE: prevent unnecessary updates\n  // e.g. when rows changed but bounds remain the same.\n  let result = viewport;\n  if (viewportTop !== viewport.top) {\n    result = { ...result, top: viewportTop };\n  }\n  if (viewportLeft !== viewport.left) {\n    result = { ...result, left: viewportLeft };\n  }\n  if (containerWidth !== viewport.width) {\n    result = { ...result, width: containerWidth };\n  }\n  if (containerHeight !== viewport.height) {\n    result = { ...result, height: containerHeight };\n  }\n  if (!arraysEqual(rows, viewport.rows)) {\n    result = { ...result, rows };\n  }\n  if (!arraysEqual(headerRows, viewport.headerRows)) {\n    result = { ...result, headerRows };\n  }\n  if (!arraysEqual(footerRows, viewport.footerRows)) {\n    result = { ...result, footerRows };\n  }\n  if (!arraysEqual(columns, viewport.columns, arraysEqual)) {\n    result = { ...result, columns };\n  }\n\n  return result;\n};\n\nexport const checkColumnWidths: CheckTableColumnWidths = (tableColumns) => {\n  return tableColumns.reduce((acc, tableColumn) => {\n    const { width } = tableColumn;\n    if (typeof width === 'string') {\n      const numb = parseInt(width, 10);\n      const unit = numb ? width.substr(numb.toString().length) : width;\n      const isValidUnit = VALID_UNITS.some(validUnit => validUnit === unit);\n      if (!isValidUnit) {\n        throw new Error(VIRTUAL_TABLE_ERROR);\n      }\n      acc.push({ ...tableColumn, width: numb });\n    } else {\n      acc.push(tableColumn);\n    }\n    return acc;\n  }, []  as TableColumn[]);\n};\n\nexport const calculateScrollHeight: GetScrollHeightByIndex = (rowHeight, index) =>\n  index > -1 ? rowHeight * index : undefined;\n\nexport const getScrollTop: GetScrollPosition = (rows, rowsCount, rowId, rowHeight, isDataRemote) => {\n  if (rowId === TOP_POSITION) {\n    return 0;\n  }\n  if (rowId === BOTTOM_POSITION) {\n    return rowsCount * rowHeight;\n  }\n\n  const searchIndexRequired = !isDataRemote && rowId !== undefined;\n  const indexById = searchIndexRequired\n    ? rows.findIndex(row => row.rowId === rowId)\n    : undefined;\n\n  return calculateScrollHeight(\n    rowHeight,\n    indexById!,\n  );\n};\n\nexport const getScrollLeft: GetScrollLeft = (columnCount, columnWidth, columnId) => {\n  if (!columnId) {\n    return;\n  }\n  if (columnId === LEFT_POSITION) {\n    return 0;\n  }\n  return columnCount * columnWidth;\n};\n\nexport const getTopRowId: GetTopRowId = (viewport, tableBodyRows, isDataRemote) => {\n  const hasViewportRows = viewport && viewport.rows;\n  const hasBodyRows = tableBodyRows && tableBodyRows.length;\n  if (hasViewportRows && hasBodyRows && !isDataRemote) {\n    const index = viewport.rows[0];\n\n    return index < tableBodyRows.length ? tableBodyRows[index].rowId : undefined;\n  }\n\n  return undefined;\n};\n\nexport const isColumnsWidthDifferent: IsColumnsWidthDifferent = (prevColumns, columns) => {\n  return prevColumns.some((column) => {\n    const currentColumn = columns.find(c => c.key === column.key);\n    return currentColumn ? currentColumn.width !== column.width : true;\n  });\n};\n","import { mergeRows } from './helpers';\nimport { intervalUtil } from './utils';\nimport { VirtualRowsWithCacheFn, PlainRowsFn, LoadedRowsStartFn } from '../../types';\n\nexport const virtualRowsWithCache: VirtualRowsWithCacheFn = (skip, rows, cache) => {\n  const rowsInterval = intervalUtil.getRowsInterval({ skip, rows });\n  const cacheInterval = intervalUtil.getRowsInterval(cache);\n\n  return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);\n};\n\nexport const plainRows: PlainRowsFn = (virtualRows, availableRowCount) => {\n  return virtualRows.rows.length > availableRowCount\n    ? virtualRows.rows.slice(0, availableRowCount)\n    : virtualRows.rows;\n};\n\nexport const loadedRowsStart: LoadedRowsStartFn = virtualRows => virtualRows.skip;\n","export const ROOT_GROUP = '__root__';\nexport const DEFAULT_COLUMN_WIDTH = 150;\n","// tslint:disable-next-line: no-submodule-imports\nimport * as Excel from 'exceljs';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  TableColumn, FindRangesFn, ExportRowsFn,\n  CloseSheetFn,\n  ExportSummaryItemsFn,\n  RemoveEmptyGroupsFn,\n} from '../../types';\nimport { ROOT_GROUP, DEFAULT_COLUMN_WIDTH } from './constants';\n\nexport const exportHeader = (worksheet: Excel.Worksheet, columns: TableColumn[]) => {\n  const cols = columns\n    .map(({ column, width }) => ({\n      width: (width as number || DEFAULT_COLUMN_WIDTH) / 8,\n      key: column?.name,\n    }));\n  worksheet.columns = cols;\n\n  const headerRow = columns.reduce((acc, { column: { name, title } = {} }) => ({\n    ...acc,\n    [name!]: title,\n  }), {});\n  worksheet.addRow(headerRow);\n\n  worksheet.views.push({\n    state: 'frozen', ySplit: worksheet.lastRow!.number,\n  });\n};\n\nexport const findRanges: FindRangesFn = (groupTree, compoundKey, level, maxLevel, result = []) => {\n  if (level !== maxLevel) {\n    const ranges = (groupTree[compoundKey] as string[]).reduce((acc, groupKey) => (\n      [...acc, ...findRanges(groupTree, groupKey, level + 1, maxLevel, result)]\n    ), [] as Array<number[]>);\n    return [...result, ...ranges];\n  }\n  return [...result, groupTree[compoundKey] as number[]];\n};\n\nexport const exportRows: ExportRowsFn = (\n  worksheet, allRows, dataColumns, columns, isGroupRow, outlineLevels,\n  rowsOffset, getCellValue, getCloseGroup, customizeCell,\n) => {\n  let currentLevel = 0;\n  let openGroups: any[] = [];\n  const closeGroup = getCloseGroup(rowsOffset);\n\n  allRows.forEach((row) => {\n    let excelRow;\n\n    if (isGroupRow && isGroupRow(row)) {\n      currentLevel = outlineLevels[row.groupedBy];\n\n      // close nested groups first\n      openGroups.slice(currentLevel).reverse().forEach(closeGroup);\n\n      openGroups = openGroups.slice(0, currentLevel);\n      openGroups[currentLevel] = { groupedBy: row.groupedBy, compoundKey: row.compoundKey };\n\n      // add group row\n      const title = dataColumns.find(({ name }) => name === row.groupedBy)?.title;\n      excelRow = { [columns[0].column!.name]: `${title}: ${row.value}` };\n\n      worksheet.addRow(excelRow);\n      const lastIndex = worksheet.lastRow!.number;\n\n      // merge into single cell\n      worksheet.mergeCells(lastIndex, 1, lastIndex, columns.length);\n      worksheet.lastRow!.getCell(1).font = { bold: true };\n\n      if (currentLevel > 0) {\n        worksheet.lastRow!.outlineLevel = currentLevel;\n      }\n      currentLevel += 1;\n    } else {\n      excelRow = columns.reduce((acc, { column }) => ({\n        ...acc,\n        ...(column ? { [column.name]: getCellValue(row, column.name) } : null),\n      }), {});\n      worksheet.addRow(excelRow);\n      worksheet.lastRow!.outlineLevel = currentLevel;\n    }\n\n    worksheet.lastRow!.eachCell((cell, colNumber) => {\n      customizeCell(cell, row, columns[colNumber - 1].column!);\n    });\n  });\n\n  openGroups.reverse().forEach(closeGroup);\n};\n\nexport const closeSheet: CloseSheetFn = (\n  worksheet, groupTree, maxGroupLevel, rowsOffset, totalSummaryItems, exportSummary,\n) => {\n  exportSummaryItems(\n    worksheet, groupTree, totalSummaryItems, ROOT_GROUP, -1,\n    rowsOffset, maxGroupLevel, exportSummary,\n  );\n};\n\nexport const normalizeRanges: PureComputed<[number[][], number]> = (ranges, offset) => (\n  ranges.map(range => range.map(index => + index + offset))\n);\n\nexport const exportSummaryItems: ExportSummaryItemsFn = (\n  worksheet, groupTree, summaryItems, groupKey, groupLevel,\n  rowsOffset, maxGroupLevel, exportSummary,\n) => {\n  if (!summaryItems) return;\n\n  worksheet.addRow({});\n\n  const ranges = normalizeRanges(\n    findRanges(groupTree, groupKey, groupLevel, maxGroupLevel),\n    rowsOffset,\n  );\n\n  summaryItems.forEach((s) => {\n    exportSummary(s, ranges);\n  });\n};\n\nexport const removeEmptyGroups: RemoveEmptyGroupsFn = (rows, grouping, isGroupRow) => {\n  if (!grouping) return rows;\n\n  const groupingColumns = grouping.map(({ columnName }) => columnName);\n  const result: any[] = [];\n  let groupChain: any[] = [];\n\n  rows.forEach((row) => {\n    if (isGroupRow(row)) {\n      const level = groupingColumns.indexOf(row.groupedBy);\n      if (level === groupChain.length) {\n        groupChain.push(row);\n      } else {\n        groupChain = [...groupChain.slice(0, level), row];\n      }\n    } else {\n      if (groupChain.length > 0) {\n        result.push(...groupChain);\n        groupChain = Array.from({ length: groupChain.length });\n      }\n      result.push(row);\n    }\n  });\n\n  return result.filter(row => !!row);\n};\n","import {\n  OutlineLevelsFn, FilterSelectedRowsFn, GetRowsToExportFn, Row, BuildGroupTreeFn,\n  GetExportSummaryFn, GetCloseGroupFn, Grouping, RowId,\n} from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { ROOT_GROUP } from './constants';\nimport { exportSummaryItems, removeEmptyGroups } from './helpers';\nimport { TABLE_DATA_TYPE } from '../table/constants';\n\nexport const groupOutlineLevels: OutlineLevelsFn = grouping => (\n  grouping?.reduce((acc, { columnName }, index) => ({\n    ...acc,\n    [columnName]: index,\n  }), {}) || {}\n);\n\nconst filterSelectedRows: FilterSelectedRowsFn = (rows, selection, getRowId, isGroupRow) => {\n  const selectionSet = new Set<RowId>(selection);\n  return rows.filter(row => (\n    isGroupRow && isGroupRow(row)) || selectionSet.has(getRowId(row)),\n  );\n};\n\nexport const rowsToExport: GetRowsToExportFn = (\n  rows, selection, grouping, getCollapsedRows, getRowId, isGroupRow,\n) => {\n  const expandRows: PureComputed<[Row[]]> = collapsedRows => (\n    collapsedRows.reduce((acc, row) => (\n      [...acc, row, ...(expandRows(getCollapsedRows!(row) || []))]\n    ), [])\n  );\n\n  const expandedRows = getCollapsedRows ? expandRows(rows) : rows;\n\n  if (!selection) {\n    return expandedRows;\n  }\n\n  const filteredRows = filterSelectedRows(expandedRows, selection, getRowId, isGroupRow);\n  return removeEmptyGroups(filteredRows, grouping, isGroupRow);\n};\n\nexport const buildGroupTree: BuildGroupTreeFn = (\n  rows, outlineLevels, grouping, isGroupRow, groupSummaryItems,\n) => {\n  const groupTree = { [ROOT_GROUP]: [] as any[] };\n\n  if (!grouping?.length) {\n    groupTree[ROOT_GROUP] = [0, rows.length - 1];\n    return groupTree;\n  }\n\n  const maxLevel = Object.keys(outlineLevels).length - 1;\n  const groupSummaryExists = !!groupSummaryItems;\n  const parentChain = { '-1': ROOT_GROUP };\n  let lastDataIndex = 0;\n  let openGroup = '';\n  let index = 0;\n  let level = 0;\n  let prevLevel = 0;\n\n  rows.forEach((row) => {\n    const { groupedBy, compoundKey } = row;\n    if (isGroupRow(row)) {\n      level = outlineLevels[groupedBy];\n      groupTree[compoundKey] = [];\n      parentChain[level] = compoundKey;\n      if (level <= maxLevel) {\n        groupTree[parentChain[level - 1]].push(compoundKey);\n      }\n      if (level === maxLevel) {\n        if (openGroup) {\n          // close previous group\n          groupTree[openGroup].push(lastDataIndex);\n        }\n        openGroup = compoundKey;\n        if (groupSummaryExists && lastDataIndex > 0) {\n          index += 1;\n        }\n        groupTree[compoundKey].push(index + 1); // first row index\n      } else if (groupSummaryExists && level < prevLevel) {\n        // jump over summary rows\n        index += maxLevel - level;\n      }\n      prevLevel = level;\n    } else {\n      lastDataIndex = index;\n    }\n    index += 1;\n  });\n\n  if (openGroup) {\n    groupTree[openGroup].push(lastDataIndex);\n  }\n\n  return groupTree;\n};\n\nconst operations = {\n  count: 'COUNTA',\n};\nexport const exportSummaryGetter: GetExportSummaryFn = (\n  worksheet, tableColumns, customizeSummaryCell, defaultSummaryMessages,\n) => (\n  { columnName, type }, ranges,\n) => {\n  const { column } = tableColumns.find(({ column: dataColumn, type: columnType }) => (\n    columnType === TABLE_DATA_TYPE && dataColumn && dataColumn.name === columnName\n  )) || {};\n  // NOTE: column is hidden or the grid grouped by this column\n  if (!column) {\n    return;\n  }\n\n  const row = worksheet.lastRow!;\n  const letter = worksheet.getColumn(columnName).letter;\n  const operation = operations[type] || type.toUpperCase();\n  const rangesStr = ranges.map(range => (\n    range\n      .map(r => `${letter}${r}`)\n      .filter((val, index, arr) => arr.indexOf(val) === index)\n      .join(':')\n  )).join(',');\n\n  const cell = row.getCell(columnName);\n  cell.value = {\n    formula: `${operation}(${rangesStr})`,\n    date1904: false,\n  };\n  cell.numFmt = `\"${defaultSummaryMessages[type]}:\" 0`;\n\n  const summary = {\n    type,\n    ranges,\n  };\n  customizeSummaryCell(cell, column!, summary);\n};\n\nexport const closeGroupGetter: GetCloseGroupFn = (\n  worksheet, groupTree, outlineLevels, maxGroupLevel, groupSummaryItems, exportSummary,\n) => rowsOffset => (group) => {\n  const { groupedBy, compoundKey } = group;\n\n  exportSummaryItems(\n    worksheet, groupTree, groupSummaryItems, compoundKey, outlineLevels[groupedBy],\n    rowsOffset, maxGroupLevel, exportSummary,\n  );\n};\n\nexport const maximumGroupLevel: PureComputed<[Grouping[]], number> = grouping => (\n  (grouping || []).length - 1\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}